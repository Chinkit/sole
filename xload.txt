
x-load:     file format elf32-littlearm


Disassembly of section .text:

40200800 <_start>:
#include <config.h>
#include <asm/arch/cpu.h>

.globl _start
_start:
	b	reset
40200800:	ea000012 	b	40200850 <reset>
 	ldr	pc, _hang
40200804:	e59ff014 	ldr	pc, [pc, #20]	; 40200820 <_hang>
	ldr	pc, _hang
40200808:	e59ff010 	ldr	pc, [pc, #16]	; 40200820 <_hang>
	ldr	pc, _hang
4020080c:	e59ff00c 	ldr	pc, [pc, #12]	; 40200820 <_hang>
	ldr	pc, _hang
40200810:	e59ff008 	ldr	pc, [pc, #8]	; 40200820 <_hang>
	ldr	pc, _hang
40200814:	e59ff004 	ldr	pc, [pc, #4]	; 40200820 <_hang>
	ldr	pc, _hang
40200818:	e51ff000 	ldr	pc, [pc, #0]	; 40200820 <_hang>
	ldr	pc, _hang
4020081c:	e51ff004 	ldr	pc, [pc, #-4]	; 40200820 <_hang>

40200820 <_hang>:
40200820:	40200960 	.word	0x40200960
40200824:	12345678 	.word	0x12345678
40200828:	12345678 	.word	0x12345678
4020082c:	12345678 	.word	0x12345678
40200830:	12345678 	.word	0x12345678
40200834:	12345678 	.word	0x12345678
40200838:	12345678 	.word	0x12345678
4020083c:	12345678 	.word	0x12345678

40200840 <_end_vect>:
40200840:	40200800 	.word	0x40200800

40200844 <_armboot_start>:
40200844:	40200800 	.word	0x40200800

40200848 <_bss_start>:
40200848:	40204f70 	.word	0x40204f70

4020084c <_bss_end>:
4020084c:	40208064 	.word	0x40208064

40200850 <reset>:

reset:
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0,cpsr
40200850:	e10f0000 	mrs	r0, CPSR
	bic	r0,r0,#0x1f
40200854:	e3c0001f 	bic	r0, r0, #31
	orr	r0,r0,#0xd3
40200858:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr,r0
4020085c:	e129f000 	msr	CPSR_fc, r0

	/* Copy vectors to mask ROM indirect addr */
	adr     r0, _start              /* r0 <- current position of code   */
40200860:	e24f0068 	sub	r0, pc, #104	; 0x68
	add     r0, r0, #4				/* skip reset vector			*/
40200864:	e2800004 	add	r0, r0, #4
	mov     r2, #64                 /* r2 <- size to copy  */
40200868:	e3a02040 	mov	r2, #64	; 0x40
	add     r2, r0, r2              /* r2 <- source end address         */
4020086c:	e0802002 	add	r2, r0, r2
	mov     r1, #SRAM_OFFSET0         /* build vect addr */
40200870:	e3a01101 	mov	r1, #1073741824	; 0x40000000
	mov     r3, #SRAM_OFFSET1
40200874:	e3a03602 	mov	r3, #2097152	; 0x200000
	add     r1, r1, r3
40200878:	e0811003 	add	r1, r1, r3
	mov     r3, #SRAM_OFFSET2
4020087c:	e3a03b3e 	mov	r3, #63488	; 0xf800
	add     r1, r1, r3
40200880:	e0811003 	add	r1, r1, r3

40200884 <next>:
next:
	ldmia   r0!, {r3-r10}           /* copy from source address [r0]    */
40200884:	e8b007f8 	ldm	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}
	stmia   r1!, {r3-r10}           /* copy to   target address [r1]    */
40200888:	e8a107f8 	stmia	r1!, {r3, r4, r5, r6, r7, r8, r9, sl}
	cmp     r0, r2                  /* until source end address [r2]    */
4020088c:	e1500002 	cmp	r0, r2
	bne     next                    /* loop until equal */
40200890:	1afffffb 	bne	40200884 <next>

	bl	cpy_clk_code            /* put dpll adjust code behind vectors */
40200894:	eb00003a 	bl	40200984 <cpy_clk_code>

	/* the mask ROM code should have PLL and others stable */
	bl  cpu_init_crit
40200898:	eb000017 	bl	402008fc <cpu_init_crit>

4020089c <relocate>:

relocate:				/* relocate U-Boot to RAM	    */
	adr	r0, _start		/* r0 <- current position of code   */
4020089c:	e24f00a4 	sub	r0, pc, #164	; 0xa4
	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
402008a0:	e51f1068 	ldr	r1, [pc, #-104]	; 40200840 <_end_vect>
	cmp r0, r1                  	/* no need to relocate if XIP       */
402008a4:	e1500001 	cmp	r0, r1
	beq stack_setup			/* skip txt cpy if XIP(SRAM, SDRAM) */
402008a8:	0a000007 	beq	402008cc <stack_setup>

	ldr	r2, _armboot_start
402008ac:	e51f2070 	ldr	r2, [pc, #-112]	; 40200844 <_armboot_start>
	ldr	r3, _bss_start
402008b0:	e51f3070 	ldr	r3, [pc, #-112]	; 40200848 <_bss_start>
	sub	r2, r3, r2		/* r2 <- size of armboot            */
402008b4:	e0432002 	sub	r2, r3, r2
	add	r2, r0, r2		/* r2 <- source end address         */
402008b8:	e0802002 	add	r2, r0, r2

402008bc <copy_loop>:

copy_loop:
	ldmia	r0!, {r3-r10}		/* copy from source address [r0]    */
402008bc:	e8b007f8 	ldm	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}
	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
402008c0:	e8a107f8 	stmia	r1!, {r3, r4, r5, r6, r7, r8, r9, sl}
	cmp	r0, r2			/* until source end addreee [r2]    */
402008c4:	e1500002 	cmp	r0, r2
	ble	copy_loop
402008c8:	dafffffb 	ble	402008bc <copy_loop>

402008cc <stack_setup>:

	/* Set up the stack						    */
stack_setup:
	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
402008cc:	e51f0094 	ldr	r0, [pc, #-148]	; 40200840 <_end_vect>
	sub	sp, r0, #128		/* leave 32 words for abort-stack   */
402008d0:	e240d080 	sub	sp, r0, #128	; 0x80
	and	sp, sp, #~7		/* 8 byte alinged for (ldr/str)d    */
402008d4:	e3cdd007 	bic	sp, sp, #7

402008d8 <clear_bss>:

	/* Clear BSS (if any).  Is below tx (watch load addr - need space)  */
clear_bss:
	ldr	r0, _bss_start		/* find start of bss segment        */
402008d8:	e51f0098 	ldr	r0, [pc, #-152]	; 40200848 <_bss_start>
	ldr	r1, _bss_end		/* stop here                        */
402008dc:	e51f1098 	ldr	r1, [pc, #-152]	; 4020084c <_bss_end>
	mov 	r2, #0x00000000		/* clear value                      */
402008e0:	e3a02000 	mov	r2, #0

402008e4 <clbss_l>:
clbss_l:
	str	r2, [r0]		/* clear BSS location               */
402008e4:	e5802000 	str	r2, [r0]
	cmp	r0, r1			/* are we at the end yet            */
402008e8:	e1500001 	cmp	r0, r1
	add	r0, r0, #4		/* increment clear index pointer    */
402008ec:	e2800004 	add	r0, r0, #4
	bne	clbss_l                 /* keep clearing till at end        */
402008f0:	1afffffb 	bne	402008e4 <clbss_l>

	ldr	pc, _start_armboot	/* jump to C code                   */
402008f4:	e51ff004 	ldr	pc, [pc, #-4]	; 402008f8 <_start_armboot>

402008f8 <_start_armboot>:
402008f8:	402029e8 	.word	0x402029e8

402008fc <cpu_init_crit>:
 */
cpu_init_crit:
	/*
	 * Invalidate L1 I/D
	 */
        mov	r0, #0                 /* set up for MCR */
402008fc:	e3a00000 	mov	r0, #0
        mcr	p15, 0, r0, c8, c7, 0  /* invalidate TLBs */
40200900:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
        mcr	p15, 0, r0, c7, c5, 1  /* invalidate icache */
40200904:	ee070f35 	mcr	15, 0, r0, cr7, cr5, {1}

	/* Invalide L2 cache (gp device call point)
	 * - warning, this may have issues on EMU/HS devices
	 * this call can corrupt r0-r5
	 */
	mov r12, #0x1		@ set up to invalide L2
40200908:	e3a0c001 	mov	ip, #1
smi: 	.word 0xE1600070	@ Call SMI monitor
*/
	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
4020090c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
40200910:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
40200914:	e3c00007 	bic	r0, r0, #7
	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
40200918:	e3800002 	orr	r0, r0, #2
#ifndef CONFIG_ICACHE_OFF
	orr	r0, r0, #0x00001800	@ set bit 11,12 (---I Z---) BTB,I-Cache
4020091c:	e3800b06 	orr	r0, r0, #6144	; 0x1800
#endif
	mcr	p15, 0, r0, c1, c0, 0
40200920:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

	/*
         * Jump to board specific initialization... The Mask ROM will have already initialized
         * basic memory.  Go here to bump up clock rate and handle wake up conditions.
	 */
	adr	r0, _start		/* r0 <- current position of code   */
40200924:	e24f0f4b 	sub	r0, pc, #300	; 0x12c
	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
40200928:	e51f10f0 	ldr	r1, [pc, #-240]	; 40200840 <_end_vect>
	cmp     r0, r1                  /* pass on info about skipping some init portions */
4020092c:	e1500001 	cmp	r0, r1
	moveq   r0,#0x1                 /* flag to skip prcm and sdrc setup */
40200930:	03a00001 	moveq	r0, #1
	movne   r0,#0x0
40200934:	13a00000 	movne	r0, #0

	mov	ip, lr          /* persevere link reg across call */
40200938:	e1a0c00e 	mov	ip, lr
	bl	lowlevel_init   /* go setup pll,mux,memory */
4020093c:	eb00005b 	bl	40200ab0 <lowlevel_init>
	mov	lr, ip          /* restore link */
40200940:	e1a0e00c 	mov	lr, ip
	mov	pc, lr          /* back to my caller */
40200944:	e1a0f00e 	mov	pc, lr
40200948:	e320f000 	nop	{0}
4020094c:	e320f000 	nop	{0}
40200950:	e320f000 	nop	{0}
40200954:	e320f000 	nop	{0}
40200958:	e320f000 	nop	{0}
4020095c:	e320f000 	nop	{0}

40200960 <do_hang>:
/*
 * exception handler
 */
 	.align  5
do_hang:
	ldr	sp, _TEXT_BASE		/* use 32 words abort stack */
40200960:	e51fd128 	ldr	sp, [pc, #-296]	; 40200840 <_end_vect>
   	bl	hang			/* hang and never return */
40200964:	eb000819 	bl	402029d0 <hang>
40200968:	e320f000 	nop	{0}
4020096c:	e320f000 	nop	{0}
40200970:	e320f000 	nop	{0}
40200974:	e320f000 	nop	{0}
40200978:	e320f000 	nop	{0}
4020097c:	e320f000 	nop	{0}

40200980 <_TEXT_BASE>:
 * R1 = SRAM destination address.
 *************************************************************************/
.global cpy_clk_code
 cpy_clk_code:
        /* Copy DPLL code into SRAM */
        adr     r0, go_to_speed         /* get addr of clock setting code */
40200980:	40200800 	.word	0x40200800

40200984 <cpy_clk_code>:
40200984:	e28f001c 	add	r0, pc, #28
        mov     r2, #384                /* r2 size to copy (div by 32 bytes) */
40200988:	e3a02d06 	mov	r2, #384	; 0x180
        mov     r1, r1                  /* r1 <- dest address (passed in) */
4020098c:	e1a01001 	mov	r1, r1
        add     r2, r2, r0              /* r2 <- source end address */
40200990:	e0822000 	add	r2, r2, r0

40200994 <next2>:
next2:
        ldmia   r0!, {r3-r10}           /* copy from source address [r0]    */
40200994:	e8b007f8 	ldm	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}
        stmia   r1!, {r3-r10}           /* copy to   target address [r1]    */
40200998:	e8a107f8 	stmia	r1!, {r3, r4, r5, r6, r7, r8, r9, sl}
        cmp     r0, r2                  /* until source end address [r2]    */
4020099c:	e1500002 	cmp	r0, r2
        bne     next2
402009a0:	1afffffb 	bne	40200994 <next2>
	mov	pc, lr                  /* back to caller */
402009a4:	e1a0f00e 	mov	pc, lr

402009a8 <go_to_speed>:
 *        L3 when its not in self refresh seems bad for it.  Normally, this code
 *        runs from flash before SDR is init so that should be ok.
 ******************************************************************************/
.global go_to_speed
 go_to_speed:
        stmfd sp!, {r4-r6}
402009a8:	e92d0070 	push	{r4, r5, r6}

        /* move into fast relock bypass */
        ldr     r4, pll_ctl_add
402009ac:	e59f40d8 	ldr	r4, [pc, #216]	; 40200a8c <pll_ctl_add>
        str     r0, [r4]
402009b0:	e5840000 	str	r0, [r4]

402009b4 <wait1>:
wait1:
        ldr     r5, [r3]       /* get status */
402009b4:	e5935000 	ldr	r5, [r3]
        and     r5, r5, #0x1   /* isolate core status */
402009b8:	e2055001 	and	r5, r5, #1
        cmp     r5, #0x1       /* still locked? */
402009bc:	e3550001 	cmp	r5, #1
        beq     wait1          /* if lock, loop */
402009c0:	0afffffb 	beq	402009b4 <wait1>

	/* set new dpll dividers _after_ in bypass */
	ldr     r5, pll_div_add1
402009c4:	e59f50c4 	ldr	r5, [pc, #196]	; 40200a90 <pll_div_add1>
        str     r1, [r5]          /* set m, n, m2 */
402009c8:	e5851000 	str	r1, [r5]
        ldr     r5, pll_div_add2
402009cc:	e59f50c0 	ldr	r5, [pc, #192]	; 40200a94 <pll_div_add2>
        str     r2, [r5]          /* set l3/l4/.. dividers*/
402009d0:	e5852000 	str	r2, [r5]
        ldr     r5, pll_div_add3  /* wkup */
402009d4:	e59f50bc 	ldr	r5, [pc, #188]	; 40200a98 <pll_div_add3>
        ldr     r2, pll_div_val3  /* rsm val */
402009d8:	e59f20bc 	ldr	r2, [pc, #188]	; 40200a9c <pll_div_val3>
        str     r2, [r5]
402009dc:	e5852000 	str	r2, [r5]
        ldr     r5, pll_div_add4  /* gfx */
402009e0:	e59f50b8 	ldr	r5, [pc, #184]	; 40200aa0 <pll_div_add4>
        ldr     r2, pll_div_val4
402009e4:	e59f20b8 	ldr	r2, [pc, #184]	; 40200aa4 <pll_div_val4>
        str     r2, [r5]
402009e8:	e5852000 	str	r2, [r5]
        ldr     r5, pll_div_add5  /* emu */
402009ec:	e59f50b4 	ldr	r5, [pc, #180]	; 40200aa8 <pll_div_add5>
        ldr     r2, pll_div_val5
402009f0:	e59f20b4 	ldr	r2, [pc, #180]	; 40200aac <pll_div_val5>
        str     r2, [r5]
402009f4:	e5852000 	str	r2, [r5]

        /* now prepare GPMC (flash) for new dpll speed */
	/* flash needs to be stable when we jump back to it */
        ldr     r5, flash_cfg3_addr
402009f8:	e59f5074 	ldr	r5, [pc, #116]	; 40200a74 <flash_cfg3_addr>
        ldr     r2, flash_cfg3_val
402009fc:	e59f2074 	ldr	r2, [pc, #116]	; 40200a78 <flash_cfg3_val>
        str     r2, [r5]
40200a00:	e5852000 	str	r2, [r5]
        ldr     r5, flash_cfg4_addr
40200a04:	e59f5070 	ldr	r5, [pc, #112]	; 40200a7c <flash_cfg4_addr>
        ldr     r2, flash_cfg4_val
40200a08:	e59f2070 	ldr	r2, [pc, #112]	; 40200a80 <flash_cfg4_val>
        str     r2, [r5]
40200a0c:	e5852000 	str	r2, [r5]
        ldr     r5, flash_cfg5_addr
40200a10:	e59f5070 	ldr	r5, [pc, #112]	; 40200a88 <flash_cfg5_addr>
        ldr     r2, flash_cfg5_val
40200a14:	e59f2068 	ldr	r2, [pc, #104]	; 40200a84 <flash_cfg5_val>
        str     r2, [r5]
40200a18:	e5852000 	str	r2, [r5]
        ldr     r5, flash_cfg1_addr
40200a1c:	e59f504c 	ldr	r5, [pc, #76]	; 40200a70 <flash_cfg1_addr>
        ldr     r2, [r5]
40200a20:	e5952000 	ldr	r2, [r5]
        orr     r2, r2, #0x3     /* up gpmc divider */
40200a24:	e3822003 	orr	r2, r2, #3
        str     r2, [r5]
40200a28:	e5852000 	str	r2, [r5]

        /* lock DPLL3 and wait a bit */
        orr     r0, r0, #0x7   /* set up for lock mode */
40200a2c:	e3800007 	orr	r0, r0, #7
        str     r0, [r4]       /* lock */
40200a30:	e5840000 	str	r0, [r4]
        nop                    /* ARM slow at this point working at sys_clk */
40200a34:	e320f000 	nop	{0}
        nop
40200a38:	e320f000 	nop	{0}
        nop
40200a3c:	e320f000 	nop	{0}
        nop
40200a40:	e320f000 	nop	{0}

40200a44 <wait2>:
wait2:
        ldr     r5, [r3]       /* get status */
40200a44:	e5935000 	ldr	r5, [r3]
        and     r5, r5, #0x1   /* isolate core status */
40200a48:	e2055001 	and	r5, r5, #1
        cmp     r5, #0x1       /* still locked? */
40200a4c:	e3550001 	cmp	r5, #1
        bne     wait2          /* if lock, loop */
40200a50:	1afffffb 	bne	40200a44 <wait2>
        nop
40200a54:	e320f000 	nop	{0}
        nop
40200a58:	e320f000 	nop	{0}
        nop
40200a5c:	e320f000 	nop	{0}
        nop
40200a60:	e320f000 	nop	{0}
        ldmfd sp!, {r4-r6}
40200a64:	e8bd0070 	pop	{r4, r5, r6}
        mov     pc, lr           /* back to caller, locked */
40200a68:	e1a0f00e 	mov	pc, lr

40200a6c <_go_to_speed>:
40200a6c:	402009a8 	.word	0x402009a8

40200a70 <flash_cfg1_addr>:
40200a70:	6e000060 	.word	0x6e000060

40200a74 <flash_cfg3_addr>:
40200a74:	6e000068 	.word	0x6e000068

40200a78 <flash_cfg3_val>:
40200a78:	00060602 	.word	0x00060602

40200a7c <flash_cfg4_addr>:
40200a7c:	6e00006c 	.word	0x6e00006c

40200a80 <flash_cfg4_val>:
40200a80:	11091109 	.word	0x11091109

40200a84 <flash_cfg5_val>:
40200a84:	01141f1f 	.word	0x01141f1f

40200a88 <flash_cfg5_addr>:
40200a88:	6e000070 	.word	0x6e000070

40200a8c <pll_ctl_add>:
40200a8c:	48004d00 	.word	0x48004d00

40200a90 <pll_div_add1>:
40200a90:	48004d40 	.word	0x48004d40

40200a94 <pll_div_add2>:
40200a94:	48004a40 	.word	0x48004a40

40200a98 <pll_div_add3>:
40200a98:	48004c40 	.word	0x48004c40

40200a9c <pll_div_val3>:
40200a9c:	00000004 	.word	0x00000004

40200aa0 <pll_div_add4>:
40200aa0:	48004b40 	.word	0x48004b40

40200aa4 <pll_div_val4>:
40200aa4:	00000003 	.word	0x00000003

40200aa8 <pll_div_add5>:
40200aa8:	48005140 	.word	0x48005140

40200aac <pll_div_val5>:
40200aac:	03020a50 	.word	0x03020a50

40200ab0 <lowlevel_init>:

#endif

.globl lowlevel_init
lowlevel_init:
	ldr	sp,	SRAM_STACK
40200ab0:	e59fd018 	ldr	sp, [pc, #24]	; 40200ad0 <SRAM_STACK>
        str     ip,	[sp]    /* stash old link register */
40200ab4:	e58dc000 	str	ip, [sp]
	mov	ip,	lr	/* save link reg across call */
40200ab8:	e1a0c00e 	mov	ip, lr
        bl      s_init          /* go setup pll,mux,memory */
40200abc:	eb00056f 	bl	40202080 <s_init>
        ldr     ip,	[sp]    /* restore save ip */
40200ac0:	e59dc000 	ldr	ip, [sp]
	mov	lr,	ip	/* restore link reg */
40200ac4:	e1a0e00c 	mov	lr, ip

	/* back to arch calling code */
	mov	pc,	lr
40200ac8:	e1a0f00e 	mov	pc, lr

40200acc <REG_CONTROL_STATUS>:
40200acc:	480022f0 	.word	0x480022f0

40200ad0 <SRAM_STACK>:
40200ad0:	4020fffc 	.word	0x4020fffc

40200ad4 <mpu_dpll_param>:
40200ad4:	000000fe 	.word	0x000000fe
40200ad8:	00000007 	.word	0x00000007
40200adc:	00000005 	.word	0x00000005
40200ae0:	00000001 	.word	0x00000001
40200ae4:	000000fa 	.word	0x000000fa
40200ae8:	00000005 	.word	0x00000005
40200aec:	00000007 	.word	0x00000007
40200af0:	00000001 	.word	0x00000001
40200af4:	0000017d 	.word	0x0000017d
40200af8:	0000000c 	.word	0x0000000c
40200afc:	00000003 	.word	0x00000003
40200b00:	00000001 	.word	0x00000001
40200b04:	000001f4 	.word	0x000001f4
40200b08:	0000000c 	.word	0x0000000c
40200b0c:	00000003 	.word	0x00000003
40200b10:	00000001 	.word	0x00000001
40200b14:	00000179 	.word	0x00000179
40200b18:	00000012 	.word	0x00000012
40200b1c:	00000004 	.word	0x00000004
40200b20:	00000001 	.word	0x00000001
40200b24:	00000271 	.word	0x00000271
40200b28:	00000017 	.word	0x00000017
40200b2c:	00000003 	.word	0x00000003
40200b30:	00000001 	.word	0x00000001
40200b34:	0000017d 	.word	0x0000017d
40200b38:	00000019 	.word	0x00000019
40200b3c:	00000003 	.word	0x00000003
40200b40:	00000001 	.word	0x00000001
40200b44:	000000fa 	.word	0x000000fa
40200b48:	0000000c 	.word	0x0000000c
40200b4c:	00000007 	.word	0x00000007
40200b50:	00000001 	.word	0x00000001
40200b54:	000001fa 	.word	0x000001fa
40200b58:	00000032 	.word	0x00000032
40200b5c:	00000003 	.word	0x00000003
40200b60:	00000001 	.word	0x00000001
40200b64:	00000271 	.word	0x00000271
40200b68:	0000002f 	.word	0x0000002f
40200b6c:	00000003 	.word	0x00000003
40200b70:	00000001 	.word	0x00000001

40200b74 <get_mpu_dpll_param>:
.word 0x01


.globl get_mpu_dpll_param
get_mpu_dpll_param:
	adr r0, mpu_dpll_param
40200b74:	e24f00a8 	sub	r0, pc, #168	; 0xa8
	mov pc, lr
40200b78:	e1a0f00e 	mov	pc, lr

40200b7c <iva_dpll_param>:
40200b7c:	0000007d 	.word	0x0000007d
40200b80:	00000005 	.word	0x00000005
40200b84:	00000007 	.word	0x00000007
40200b88:	00000001 	.word	0x00000001
40200b8c:	000000b4 	.word	0x000000b4
40200b90:	00000005 	.word	0x00000005
40200b94:	00000007 	.word	0x00000007
40200b98:	00000001 	.word	0x00000001
40200b9c:	000000fa 	.word	0x000000fa
40200ba0:	0000000c 	.word	0x0000000c
40200ba4:	00000003 	.word	0x00000003
40200ba8:	00000001 	.word	0x00000001
40200bac:	00000168 	.word	0x00000168
40200bb0:	0000000c 	.word	0x0000000c
40200bb4:	00000003 	.word	0x00000003
40200bb8:	00000001 	.word	0x00000001
40200bbc:	00000082 	.word	0x00000082
40200bc0:	00000009 	.word	0x00000009
40200bc4:	00000007 	.word	0x00000007
40200bc8:	00000001 	.word	0x00000001
40200bcc:	000000e1 	.word	0x000000e1
40200bd0:	0000000b 	.word	0x0000000b
40200bd4:	00000006 	.word	0x00000006
40200bd8:	00000001 	.word	0x00000001
40200bdc:	0000007d 	.word	0x0000007d
40200be0:	0000000c 	.word	0x0000000c
40200be4:	00000007 	.word	0x00000007
40200be8:	00000001 	.word	0x00000001
40200bec:	000000b4 	.word	0x000000b4
40200bf0:	0000000c 	.word	0x0000000c
40200bf4:	00000007 	.word	0x00000007
40200bf8:	00000001 	.word	0x00000001
40200bfc:	0000013f 	.word	0x0000013f
40200c00:	00000030 	.word	0x00000030
40200c04:	00000003 	.word	0x00000003
40200c08:	00000001 	.word	0x00000001
40200c0c:	000000e1 	.word	0x000000e1
40200c10:	00000017 	.word	0x00000017
40200c14:	00000006 	.word	0x00000006
40200c18:	00000001 	.word	0x00000001

40200c1c <get_iva_dpll_param>:
.word 0x01


.globl get_iva_dpll_param
get_iva_dpll_param:
	adr r0, iva_dpll_param
40200c1c:	e24f00a8 	sub	r0, pc, #168	; 0xa8
	mov pc, lr
40200c20:	e1a0f00e 	mov	pc, lr

40200c24 <core_dpll_param>:
40200c24:	0000019f 	.word	0x0000019f
40200c28:	0000000e 	.word	0x0000000e
40200c2c:	00000003 	.word	0x00000003
40200c30:	00000001 	.word	0x00000001
40200c34:	000000a6 	.word	0x000000a6
40200c38:	00000005 	.word	0x00000005
40200c3c:	00000007 	.word	0x00000007
40200c40:	00000001 	.word	0x00000001
40200c44:	000001b2 	.word	0x000001b2
40200c48:	00000010 	.word	0x00000010
40200c4c:	00000003 	.word	0x00000003
40200c50:	00000001 	.word	0x00000001
40200c54:	0000014c 	.word	0x0000014c
40200c58:	0000000c 	.word	0x0000000c
40200c5c:	00000003 	.word	0x00000003
40200c60:	00000001 	.word	0x00000001
40200c64:	0000019f 	.word	0x0000019f
40200c68:	00000017 	.word	0x00000017
40200c6c:	00000003 	.word	0x00000003
40200c70:	00000001 	.word	0x00000001
40200c74:	0000019f 	.word	0x0000019f
40200c78:	00000017 	.word	0x00000017
40200c7c:	00000003 	.word	0x00000003
40200c80:	00000001 	.word	0x00000001
40200c84:	000001b2 	.word	0x000001b2
40200c88:	00000021 	.word	0x00000021
40200c8c:	00000003 	.word	0x00000003
40200c90:	00000001 	.word	0x00000001
40200c94:	000000a6 	.word	0x000000a6
40200c98:	0000000c 	.word	0x0000000c
40200c9c:	00000007 	.word	0x00000007
40200ca0:	00000001 	.word	0x00000001
40200ca4:	0000019f 	.word	0x0000019f
40200ca8:	0000002f 	.word	0x0000002f
40200cac:	00000003 	.word	0x00000003
40200cb0:	00000001 	.word	0x00000001
40200cb4:	0000019f 	.word	0x0000019f
40200cb8:	0000002f 	.word	0x0000002f
40200cbc:	00000003 	.word	0x00000003
40200cc0:	00000001 	.word	0x00000001

40200cc4 <get_core_dpll_param>:
.word 0x03
.word 0x01

.globl get_core_dpll_param
get_core_dpll_param:
	adr r0, core_dpll_param
40200cc4:	e24f00a8 	sub	r0, pc, #168	; 0xa8
	mov pc, lr
40200cc8:	e1a0f00e 	mov	pc, lr

40200ccc <per_dpll_param>:
40200ccc:	000000d8 	.word	0x000000d8
40200cd0:	00000005 	.word	0x00000005
40200cd4:	00000007 	.word	0x00000007
40200cd8:	00000009 	.word	0x00000009
40200cdc:	000001b0 	.word	0x000001b0
40200ce0:	0000000c 	.word	0x0000000c
40200ce4:	00000003 	.word	0x00000003
40200ce8:	00000009 	.word	0x00000009
40200cec:	000000e1 	.word	0x000000e1
40200cf0:	00000009 	.word	0x00000009
40200cf4:	00000007 	.word	0x00000007
40200cf8:	00000009 	.word	0x00000009
40200cfc:	000000d8 	.word	0x000000d8
40200d00:	0000000c 	.word	0x0000000c
40200d04:	00000007 	.word	0x00000007
40200d08:	00000009 	.word	0x00000009
40200d0c:	000000e1 	.word	0x000000e1
40200d10:	00000013 	.word	0x00000013
40200d14:	00000007 	.word	0x00000007
40200d18:	00000009 	.word	0x00000009

40200d1c <get_per_dpll_param>:
.word 0x07
.word 0x09

.globl get_per_dpll_param
get_per_dpll_param:
	adr r0, per_dpll_param
40200d1c:	e24f0058 	sub	r0, pc, #88	; 0x58
	mov pc, lr
40200d20:	e1a0f00e 	mov	pc, lr

40200d24 <mpu_36x_dpll_param>:
40200d24:	0000012c 	.word	0x0000012c
40200d28:	0000000c 	.word	0x0000000c
40200d2c:	00000000 	.word	0x00000000
40200d30:	00000001 	.word	0x00000001
40200d34:	0000012c 	.word	0x0000012c
40200d38:	0000000c 	.word	0x0000000c
40200d3c:	00000000 	.word	0x00000000
40200d40:	00000001 	.word	0x00000001
40200d44:	0000012c 	.word	0x0000012c
40200d48:	0000000c 	.word	0x0000000c
40200d4c:	00000000 	.word	0x00000000
40200d50:	00000001 	.word	0x00000001
40200d54:	0000012c 	.word	0x0000012c
40200d58:	0000000c 	.word	0x0000000c
40200d5c:	00000000 	.word	0x00000000
40200d60:	00000001 	.word	0x00000001

40200d64 <iva_36x_dpll_param>:
40200d64:	0000000a 	.word	0x0000000a
	...
40200d70:	00000001 	.word	0x00000001
40200d74:	0000000a 	.word	0x0000000a
	...
40200d80:	00000001 	.word	0x00000001
40200d84:	0000000a 	.word	0x0000000a
	...
40200d90:	00000001 	.word	0x00000001
40200d94:	0000000a 	.word	0x0000000a
	...
40200da0:	00000001 	.word	0x00000001

40200da4 <core_36x_dpll_param>:
40200da4:	000000c8 	.word	0x000000c8
40200da8:	0000000c 	.word	0x0000000c
40200dac:	00000000 	.word	0x00000000
40200db0:	00000001 	.word	0x00000001
40200db4:	000000c8 	.word	0x000000c8
40200db8:	0000000c 	.word	0x0000000c
40200dbc:	00000000 	.word	0x00000000
40200dc0:	00000001 	.word	0x00000001
40200dc4:	000000c8 	.word	0x000000c8
40200dc8:	0000000c 	.word	0x0000000c
40200dcc:	00000000 	.word	0x00000000
40200dd0:	00000001 	.word	0x00000001
40200dd4:	000000c8 	.word	0x000000c8
40200dd8:	0000000c 	.word	0x0000000c
40200ddc:	00000000 	.word	0x00000000
40200de0:	00000001 	.word	0x00000001

40200de4 <per_36x_dpll_param>:
40200de4:	00006590 	.word	0x00006590
40200de8:	000001b0 	.word	0x000001b0
40200dec:	0000000c 	.word	0x0000000c
40200df0:	00000009 	.word	0x00000009
40200df4:	00000010 	.word	0x00000010
40200df8:	00000009 	.word	0x00000009
40200dfc:	00000004 	.word	0x00000004
40200e00:	00000003 	.word	0x00000003
40200e04:	00000001 	.word	0x00000001
40200e08:	00006590 	.word	0x00006590
40200e0c:	000001b0 	.word	0x000001b0
40200e10:	0000000c 	.word	0x0000000c
40200e14:	00000009 	.word	0x00000009
40200e18:	00000010 	.word	0x00000010
40200e1c:	00000009 	.word	0x00000009
40200e20:	00000004 	.word	0x00000004
40200e24:	00000003 	.word	0x00000003
40200e28:	00000001 	.word	0x00000001
40200e2c:	00006590 	.word	0x00006590
40200e30:	000001b0 	.word	0x000001b0
40200e34:	0000000c 	.word	0x0000000c
40200e38:	00000009 	.word	0x00000009
40200e3c:	00000010 	.word	0x00000010
40200e40:	00000009 	.word	0x00000009
40200e44:	00000004 	.word	0x00000004
40200e48:	00000003 	.word	0x00000003
40200e4c:	00000001 	.word	0x00000001
40200e50:	00006590 	.word	0x00006590
40200e54:	000001b0 	.word	0x000001b0
40200e58:	0000000c 	.word	0x0000000c
40200e5c:	00000009 	.word	0x00000009
40200e60:	00000010 	.word	0x00000010
40200e64:	00000009 	.word	0x00000009
40200e68:	00000004 	.word	0x00000004
40200e6c:	00000003 	.word	0x00000003
40200e70:	00000001 	.word	0x00000001

40200e74 <get_36x_mpu_dpll_param>:
.word 26000,    432,   12,     9,      16,     9,     4,      3,      1
.word 26000,    432,   12,     9,      16,     9,     4,      3,      1

.globl get_36x_mpu_dpll_param
get_36x_mpu_dpll_param:
	adr	r0, mpu_36x_dpll_param
40200e74:	e24f0f56 	sub	r0, pc, #344	; 0x158
	mov	pc, lr
40200e78:	e1a0f00e 	mov	pc, lr

40200e7c <get_36x_iva_dpll_param>:

.globl get_36x_iva_dpll_param
get_36x_iva_dpll_param:
	adr	r0, iva_36x_dpll_param
40200e7c:	e24f0e12 	sub	r0, pc, #288	; 0x120
	mov	pc, lr
40200e80:	e1a0f00e 	mov	pc, lr

40200e84 <get_36x_core_dpll_param>:

.globl get_36x_core_dpll_param
get_36x_core_dpll_param:
	adr	r0, core_36x_dpll_param
40200e84:	e24f00e8 	sub	r0, pc, #232	; 0xe8
	mov	pc, lr
40200e88:	e1a0f00e 	mov	pc, lr

40200e8c <get_36x_per_dpll_param>:

.globl get_36x_per_dpll_param
get_36x_per_dpll_param:
	adr	r0, per_36x_dpll_param
40200e8c:	e24f00b0 	sub	r0, pc, #176	; 0xb0
	mov	pc, lr
40200e90:	e1a0f00e 	mov	pc, lr

40200e94 <delay>:
 * Routine: delay
 * Description: spinning delay to use before udelay works
 ******************************************************/
static inline void delay(unsigned long loops)
{
	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
40200e94:	e2500001 	subs	r0, r0, #1
40200e98:	1afffffd 	bne	40200e94 <delay>
			  "bne 1b":"=r" (loops):"0"(loops));
}
40200e9c:	e12fff1e 	bx	lr

40200ea0 <udelay>:

void udelay (unsigned long usecs) {
	delay(usecs);
40200ea0:	eafffffb 	b	40200e94 <delay>

40200ea4 <board_init>:
 * Description: Early hardware init.
 *****************************************/
int board_init (void)
{
	return 0;
}
40200ea4:	e3a00000 	mov	r0, #0
40200ea8:	e12fff1e 	bx	lr

40200eac <get_device_type>:
 *  get_device_type(): tell if GP/HS/EMU/TST
 *************************************************************/
u32 get_device_type(void)
{
        int mode;
        mode = __raw_readl(CONTROL_STATUS) & (DEVICE_MASK);
40200eac:	e59f3008 	ldr	r3, [pc, #8]	; 40200ebc <get_device_type+0x10>
40200eb0:	e59302f0 	ldr	r0, [r3, #752]	; 0x2f0
        return(mode >>= 8);
}
40200eb4:	e7e20450 	ubfx	r0, r0, #8, #3
40200eb8:	e12fff1e 	bx	lr
40200ebc:	48002000 	.word	0x48002000

40200ec0 <get_sysboot_value>:
 * get_sysboot_value(void) - return SYS_BOOT[4:0]
 ************************************************/
u32 get_sysboot_value(void)
{
        int mode;
        mode = __raw_readl(CONTROL_STATUS) & (SYSBOOT_MASK);
40200ec0:	e59f3008 	ldr	r3, [pc, #8]	; 40200ed0 <get_sysboot_value+0x10>
40200ec4:	e59302f0 	ldr	r0, [r3, #752]	; 0x2f0
        return mode;
}
40200ec8:	e200003f 	and	r0, r0, #63	; 0x3f
40200ecc:	e12fff1e 	bx	lr
40200ed0:	48002000 	.word	0x48002000

40200ed4 <get_mem_type>:
/*************************************************************
 * Routine: get_mem_type(void) - returns the kind of memory connected
 * to GPMC that we are trying to boot form. Uses SYS BOOT settings.
 *************************************************************/
u32 get_mem_type(void)
{
40200ed4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
        u32   mem_type = get_sysboot_value();
40200ed8:	ebfffff8 	bl	40200ec0 <get_sysboot_value>
40200edc:	e350002f 	cmp	r0, #47	; 0x2f
40200ee0:	959f3008 	ldrls	r3, [pc, #8]	; 40200ef0 <get_mem_type+0x1c>
40200ee4:	83a00000 	movhi	r0, #0
40200ee8:	97930100 	ldrls	r0, [r3, r0, lsl #2]
            case 13:
            case 19:
            case 25:
            default:    return GPMC_NOR;
        }
}
40200eec:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
40200ef0:	40204870 	.word	0x40204870

40200ef4 <get_cpu_rev>:
	u32 cpuid=0;
	/* On ES1.0 the IDCODE register is not exposed on L4
	 * so using CPU ID to differentiate
	 * between ES2.0 and ES1.0.
	 */
	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 0":"=r" (cpuid));
40200ef4:	ee103f10 	mrc	15, 0, r3, cr0, cr0, {0}
	if((cpuid  & 0xf) == 0x0)
40200ef8:	e313000f 	tst	r3, #15
		return CPU_3430_ES1;
	else
		return CPU_3430_ES2;

}
40200efc:	03a00001 	moveq	r0, #1
40200f00:	13a00002 	movne	r0, #2
40200f04:	e12fff1e 	bx	lr

40200f08 <is_cpu_family>:
u32 is_cpu_family(void)
{
	u32 cpuid = 0, cpu_family = 0;
	u16 hawkeye;

	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 0":"=r"(cpuid));
40200f08:	ee103f10 	mrc	15, 0, r3, cr0, cr0, {0}
	if ((cpuid & 0xf) == 0x0) {
40200f0c:	e313000f 	tst	r3, #15
40200f10:	0a00000b 	beq	40200f44 <is_cpu_family+0x3c>
		cpu_family = CPU_OMAP34XX;
	} else {
		cpuid = __raw_readl(OMAP34XX_CONTROL_ID);
40200f14:	e59f3030 	ldr	r3, [pc, #48]	; 40200f4c <is_cpu_family+0x44>
		hawkeye  = (cpuid >> HAWKEYE_SHIFT) & 0xffff;

		switch (hawkeye) {
40200f18:	e30b2868 	movw	r2, #47208	; 0xb868

	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 0":"=r"(cpuid));
	if ((cpuid & 0xf) == 0x0) {
		cpu_family = CPU_OMAP34XX;
	} else {
		cpuid = __raw_readl(OMAP34XX_CONTROL_ID);
40200f1c:	e5933204 	ldr	r3, [r3, #516]	; 0x204
		hawkeye  = (cpuid >> HAWKEYE_SHIFT) & 0xffff;

		switch (hawkeye) {
40200f20:	e7ef3653 	ubfx	r3, r3, #12, #16
40200f24:	e1530002 	cmp	r3, r2
40200f28:	03a00c35 	moveq	r0, #13568	; 0x3500
40200f2c:	012fff1e 	bxeq	lr
40200f30:	e2822029 	add	r2, r2, #41	; 0x29
40200f34:	e1530002 	cmp	r3, r2
40200f38:	1a000001 	bne	40200f44 <is_cpu_family+0x3c>
40200f3c:	e3a00c36 	mov	r0, #13824	; 0x3600
			case HAWKEYE_AM35XX:
				cpu_family = CPU_AM35XX;
				break;
			case HAWKEYE_OMAP36XX:
				cpu_family = CPU_OMAP36XX;
				break;
40200f40:	e12fff1e 	bx	lr
40200f44:	e3a00b0d 	mov	r0, #13312	; 0x3400
				cpu_family = CPU_OMAP34XX;
				break;
		}
	}
	return cpu_family;
}
40200f48:	e12fff1e 	bx	lr
40200f4c:	4830a000 	.word	0x4830a000

40200f50 <cpu_is_3410>:
/******************************************
 * cpu_is_3410(void) - returns true for 3410
 ******************************************/
u32 cpu_is_3410(void)
{
40200f50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int status;
	if(get_cpu_rev() < CPU_3430_ES2) {
40200f54:	ebffffe6 	bl	40200ef4 <get_cpu_rev>
40200f58:	e3500001 	cmp	r0, #1
40200f5c:	93a00000 	movls	r0, #0
40200f60:	949df004 	popls	{pc}		; (ldrls pc, [sp], #4)
		return 0;
	} else {
		/* read scalability status and return 1 for 3410*/
		status = __raw_readl(CONTROL_SCALABLE_OMAP_STATUS);
40200f64:	e59f3014 	ldr	r3, [pc, #20]	; 40200f80 <cpu_is_3410+0x30>
40200f68:	e593044c 	ldr	r0, [r3, #1100]	; 0x44c
40200f6c:	e7e10450 	ubfx	r0, r0, #8, #2
40200f70:	e3500002 	cmp	r0, #2
40200f74:	13a00000 	movne	r0, #0
40200f78:	03a00001 	moveq	r0, #1
		if (((status >> 8) & 0x3) == 0x2)
			return 1;
		else
			return 0;
	}
}
40200f7c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
40200f80:	48002000 	.word	0x48002000

40200f84 <sr32>:
void sr32(u32 addr, u32 start_bit, u32 num_bits, u32 value)
{
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
	--msk;
	tmp = __raw_readl(addr) & ~(msk << start_bit);
40200f84:	e590c000 	ldr	ip, [r0]

/*****************************************************************
 * sr32 - clear & set a value in a bit range for a 32 bit address
 *****************************************************************/
void sr32(u32 addr, u32 start_bit, u32 num_bits, u32 value)
{
40200f88:	e92d4010 	push	{r4, lr}
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
	--msk;
	tmp = __raw_readl(addr) & ~(msk << start_bit);
40200f8c:	e3e04000 	mvn	r4, #0
40200f90:	e1e04214 	mvn	r4, r4, lsl r2
40200f94:	e1ccc114 	bic	ip, ip, r4, lsl r1
	tmp |=  value << start_bit;
40200f98:	e18cc113 	orr	ip, ip, r3, lsl r1
	__raw_writel(tmp, addr);
40200f9c:	e580c000 	str	ip, [r0]
}
40200fa0:	e8bd8010 	pop	{r4, pc}

40200fa4 <wait_on_value>:
/*********************************************************************
 * wait_on_value() - common routine to allow waiting for changes in
 *   volatile regs.
 *********************************************************************/
u32 wait_on_value(u32 read_bit_mask, u32 match_value, u32 read_addr, u32 bound)
{
40200fa4:	e3a0c000 	mov	ip, #0
40200fa8:	e92d4010 	push	{r4, lr}
	u32 i = 0, val;
	do {
		++i;
		val = __raw_readl(read_addr) & read_bit_mask;
40200fac:	e5924000 	ldr	r4, [r2]
		if (val == match_value)
40200fb0:	e0044000 	and	r4, r4, r0
40200fb4:	e1540001 	cmp	r4, r1
40200fb8:	1a000001 	bne	40200fc4 <wait_on_value+0x20>
40200fbc:	e3a00001 	mov	r0, #1
40200fc0:	e8bd8010 	pop	{r4, pc}
 *********************************************************************/
u32 wait_on_value(u32 read_bit_mask, u32 match_value, u32 read_addr, u32 bound)
{
	u32 i = 0, val;
	do {
		++i;
40200fc4:	e28cc001 	add	ip, ip, #1
		val = __raw_readl(read_addr) & read_bit_mask;
		if (val == match_value)
			return (1);
		if (i == bound)
40200fc8:	e15c0003 	cmp	ip, r3
40200fcc:	1afffff6 	bne	40200fac <wait_on_value+0x8>
40200fd0:	e3a00000 	mov	r0, #0
			return (0);
	} while (1);
}
40200fd4:	e8bd8010 	pop	{r4, pc}

40200fd8 <get_sdr_cs_size>:
u32 get_sdr_cs_size(u32 offset)
{
	u32 size;

	/* get ram size field */
	size = __raw_readl(SDRC_MCFG_0 + offset) >> 8;
40200fd8:	e59f300c 	ldr	r3, [pc, #12]	; 40200fec <get_sdr_cs_size+0x14>
40200fdc:	e7900003 	ldr	r0, [r0, r3]
	size &= 0x3FF;          /* remove unwanted bits */
40200fe0:	e7e90450 	ubfx	r0, r0, #8, #10
	size *= SZ_2M;          /* find size in MB */
	return size;
}
40200fe4:	e1a00a80 	lsl	r0, r0, #21
40200fe8:	e12fff1e 	bx	lr
40200fec:	6d000080 	.word	0x6d000080

40200ff0 <make_cs1_contiguous>:
 *  command line mem=xyz use all memory with out discontinuous support
 *  compiled in.  Could do it at the ATAG, but there really is two banks...
 * Called as part of 2nd phase DDR init.
 **************************************************************************/
void make_cs1_contiguous(void)
{
40200ff0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	u32 size, a_add_low, a_add_high;

	size = get_sdr_cs_size(SDRC_CS0_OSET);
40200ff4:	e3a00000 	mov	r0, #0
40200ff8:	ebfffff6 	bl	40200fd8 <get_sdr_cs_size>
	size /= SZ_32M;         /* find size to offset CS1 */
40200ffc:	e1a00ca0 	lsr	r0, r0, #25
	a_add_high = (size & 3) << 8;   /* set up low field */
	a_add_low = (size & 0x3C) >> 2; /* set up high field */
	__raw_writel((a_add_high | a_add_low), SDRC_CS_CFG);
40201000:	e7e33150 	ubfx	r3, r0, #2, #4
40201004:	e2000003 	and	r0, r0, #3
40201008:	e1830400 	orr	r0, r3, r0, lsl #8
4020100c:	e3a0346d 	mov	r3, #1828716544	; 0x6d000000
40201010:	e5830040 	str	r0, [r3, #64]	; 0x40
}
40201014:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

40201018 <config_3430sdram_ddr>:

/*********************************************************************
 * config_3430sdram_ddr() - Init DDR on 3430SDP dev board.
 *********************************************************************/
void config_3430sdram_ddr(void)
{
40201018:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	__raw_writel(SDP_SDRC_DLLAB_CTRL, SDRC_DLLA_CTRL);
	delay(0x2000);	/* give time to lock */
#else
       /* reset sdrc controller */
         __raw_writel(SOFTRESET, SDRC_SYSCONFIG);
         wait_on_value(BIT0, BIT0, SDRC_STATUS, 12000000);
4020101c:	e3a00001 	mov	r0, #1
	/* set up dll */
	__raw_writel(SDP_SDRC_DLLAB_CTRL, SDRC_DLLA_CTRL);
	delay(0x2000);	/* give time to lock */
#else
       /* reset sdrc controller */
         __raw_writel(SOFTRESET, SDRC_SYSCONFIG);
40201020:	e3a0446d 	mov	r4, #1828716544	; 0x6d000000
         wait_on_value(BIT0, BIT0, SDRC_STATUS, 12000000);
40201024:	e1a01000 	mov	r1, r0
40201028:	e59f20d4 	ldr	r2, [pc, #212]	; 40201104 <config_3430sdram_ddr+0xec>
	/* set up dll */
	__raw_writel(SDP_SDRC_DLLAB_CTRL, SDRC_DLLA_CTRL);
	delay(0x2000);	/* give time to lock */
#else
       /* reset sdrc controller */
         __raw_writel(SOFTRESET, SDRC_SYSCONFIG);
4020102c:	e3a03002 	mov	r3, #2
40201030:	e5843010 	str	r3, [r4, #16]

         /* Disble Power Down of CKE cuz of 1 CKE on combo part */
         (*(unsigned int*)0x6D000070) = 0x00000081;

         /* SDRC_Manual command register */
         (*(unsigned int*)0x6D0000a8) = 0x00000000; // NOP command
40201034:	e3a07000 	mov	r7, #0
	__raw_writel(SDP_SDRC_DLLAB_CTRL, SDRC_DLLA_CTRL);
	delay(0x2000);	/* give time to lock */
#else
       /* reset sdrc controller */
         __raw_writel(SOFTRESET, SDRC_SYSCONFIG);
         wait_on_value(BIT0, BIT0, SDRC_STATUS, 12000000);
40201038:	e59f30c8 	ldr	r3, [pc, #200]	; 40201108 <config_3430sdram_ddr+0xf0>

         /* SDRC_Manual command register */
         (*(unsigned int*)0x6D0000a8) = 0x00000000; // NOP command
         delay(5000);
         (*(unsigned int*)0x6D0000a8) = 0x00000001; // Precharge command
         (*(unsigned int*)0x6D0000a8) = 0x00000002; // Auto-refresh command
4020103c:	e3a05002 	mov	r5, #2
	__raw_writel(SDP_SDRC_DLLAB_CTRL, SDRC_DLLA_CTRL);
	delay(0x2000);	/* give time to lock */
#else
       /* reset sdrc controller */
         __raw_writel(SOFTRESET, SDRC_SYSCONFIG);
         wait_on_value(BIT0, BIT0, SDRC_STATUS, 12000000);
40201040:	ebffffd7 	bl	40200fa4 <wait_on_value>
         __raw_writel(0, SDRC_SYSCONFIG);
40201044:	e3a03000 	mov	r3, #0
40201048:	e5843010 	str	r3, [r4, #16]

         /* setup sdrc to ball mux */
         __raw_writel(SDP_SDRC_SHARING, SDRC_SHARING);
4020104c:	e2833c01 	add	r3, r3, #256	; 0x100
40201050:	e5843044 	str	r3, [r4, #68]	; 0x44
         (*(unsigned int*)0x6D0000a8) = 0x00000001; // Precharge command
         (*(unsigned int*)0x6D0000a8) = 0x00000002; // Auto-refresh command
         (*(unsigned int*)0x6D0000a8) = 0x00000002; // Auto-refresh command

         /* SDRC MR0 register */
         (*(int*)0x6D000084) = 0x00000032; // Burst length =4
40201054:	e3a06032 	mov	r6, #50	; 0x32

         /* setup sdrc to ball mux */
         __raw_writel(SDP_SDRC_SHARING, SDRC_SHARING);

         /* SDRC_MCFG0 register */
         (*(unsigned int*)0x6D000080) = 0x02584099;//from Micron
40201058:	e59f30ac 	ldr	r3, [pc, #172]	; 4020110c <config_3430sdram_ddr+0xf4>
4020105c:	e5843080 	str	r3, [r4, #128]	; 0x80

	 if (is_cpu_family() == CPU_OMAP36XX) {
40201060:	ebffffa8 	bl	40200f08 <is_cpu_family>
40201064:	e3500c36 	cmp	r0, #13824	; 0x3600
         /* Disble Power Down of CKE cuz of 1 CKE on combo part */
         (*(unsigned int*)0x6D000070) = 0x00000081;

         /* SDRC_Manual command register */
         (*(unsigned int*)0x6D0000a8) = 0x00000000; // NOP command
         delay(5000);
40201068:	e3010388 	movw	r0, #5000	; 0x1388
         /* SDRC_MCFG0 register */
         (*(unsigned int*)0x6D000080) = 0x02584099;//from Micron

	 if (is_cpu_family() == CPU_OMAP36XX) {
		 /* SDRC_ACTIM_CTRLA0 register */
		 (*(unsigned int*)0x6D00009c) = 0x92e1c4c6;// for 200M
4020106c:	059f309c 	ldreq	r3, [pc, #156]	; 40201110 <config_3430sdram_ddr+0xf8>
		 /* SDRC_ACTIM_CTRLB0 register */
		 (*(unsigned int*)0x6D0000a0) = 0x0002111c;
	 } else {
		 /* SDRC_ACTIM_CTRLA0 register */
		 (*(unsigned int*)0x6D00009c) = 0xaa9db4c6;// for 166M from rkw
40201070:	159f309c 	ldrne	r3, [pc, #156]	; 40201114 <config_3430sdram_ddr+0xfc>
         /* SDRC_MCFG0 register */
         (*(unsigned int*)0x6D000080) = 0x02584099;//from Micron

	 if (is_cpu_family() == CPU_OMAP36XX) {
		 /* SDRC_ACTIM_CTRLA0 register */
		 (*(unsigned int*)0x6D00009c) = 0x92e1c4c6;// for 200M
40201074:	0584309c 	streq	r3, [r4, #156]	; 0x9c
		 /* SDRC_ACTIM_CTRLB0 register */
		 (*(unsigned int*)0x6D0000a0) = 0x0002111c;
	 } else {
		 /* SDRC_ACTIM_CTRLA0 register */
		 (*(unsigned int*)0x6D00009c) = 0xaa9db4c6;// for 166M from rkw
40201078:	1584309c 	strne	r3, [r4, #156]	; 0x9c

	 if (is_cpu_family() == CPU_OMAP36XX) {
		 /* SDRC_ACTIM_CTRLA0 register */
		 (*(unsigned int*)0x6D00009c) = 0x92e1c4c6;// for 200M
		 /* SDRC_ACTIM_CTRLB0 register */
		 (*(unsigned int*)0x6D0000a0) = 0x0002111c;
4020107c:	059f3094 	ldreq	r3, [pc, #148]	; 40201118 <config_3430sdram_ddr+0x100>
	 } else {
		 /* SDRC_ACTIM_CTRLA0 register */
		 (*(unsigned int*)0x6D00009c) = 0xaa9db4c6;// for 166M from rkw
		 /* SDRC_ACTIM_CTRLB0 register */
		 (*(unsigned int*)0x6D0000a0) = 0x00011517;
40201080:	159f3094 	ldrne	r3, [pc, #148]	; 4020111c <config_3430sdram_ddr+0x104>
40201084:	e58430a0 	str	r3, [r4, #160]	; 0xa0
	 }


         (*(unsigned int*)0x6D0000a4) =0x0004DC01;
40201088:	e3a0446d 	mov	r4, #1828716544	; 0x6d000000
4020108c:	e59f308c 	ldr	r3, [pc, #140]	; 40201120 <config_3430sdram_ddr+0x108>

         /* Disble Power Down of CKE cuz of 1 CKE on combo part */
         (*(unsigned int*)0x6D000070) = 0x00000081;

         /* SDRC_Manual command register */
         (*(unsigned int*)0x6D0000a8) = 0x00000000; // NOP command
40201090:	e58470a8 	str	r7, [r4, #168]	; 0xa8
		 /* SDRC_ACTIM_CTRLB0 register */
		 (*(unsigned int*)0x6D0000a0) = 0x00011517;
	 }


         (*(unsigned int*)0x6D0000a4) =0x0004DC01;
40201094:	e58430a4 	str	r3, [r4, #164]	; 0xa4

         /* Disble Power Down of CKE cuz of 1 CKE on combo part */
         (*(unsigned int*)0x6D000070) = 0x00000081;
40201098:	e3a03081 	mov	r3, #129	; 0x81
4020109c:	e5843070 	str	r3, [r4, #112]	; 0x70

         /* SDRC_Manual command register */
         (*(unsigned int*)0x6D0000a8) = 0x00000000; // NOP command
         delay(5000);
402010a0:	ebffff7b 	bl	40200e94 <delay>
         // CAS latency = 3
         // Write Burst = Read Burst
         // Serial Mode

         /* SDRC DLLA control register */
         (*(unsigned int*)0x6D000060) = 0x0000A;
402010a4:	e3a0300a 	mov	r3, #10
         delay(0x20000); // some delay
402010a8:	e3a00802 	mov	r0, #131072	; 0x20000
         // CAS latency = 3
         // Write Burst = Read Burst
         // Serial Mode

         /* SDRC DLLA control register */
         (*(unsigned int*)0x6D000060) = 0x0000A;
402010ac:	e5843060 	str	r3, [r4, #96]	; 0x60
         /* SDRC_Manual command register */
         (*(unsigned int*)0x6D0000a8) = 0x00000000; // NOP command
         delay(5000);
         (*(unsigned int*)0x6D0000a8) = 0x00000001; // Precharge command
         (*(unsigned int*)0x6D0000a8) = 0x00000002; // Auto-refresh command
         (*(unsigned int*)0x6D0000a8) = 0x00000002; // Auto-refresh command
402010b0:	e58450a8 	str	r5, [r4, #168]	; 0xa8

         /* SDRC MR0 register */
         (*(int*)0x6D000084) = 0x00000032; // Burst length =4
402010b4:	e5846084 	str	r6, [r4, #132]	; 0x84
         // Write Burst = Read Burst
         // Serial Mode

         /* SDRC DLLA control register */
         (*(unsigned int*)0x6D000060) = 0x0000A;
         delay(0x20000); // some delay
402010b8:	ebffff75 	bl	40200e94 <delay>

#endif

#ifdef CONFIG_DDR_256MB_STACKED
	make_cs1_contiguous();
402010bc:	ebffffcb 	bl	40200ff0 <make_cs1_contiguous>

	__raw_writel(SDP_SDRC_MDCFG_0_DDR, SDRC_MCFG_0 + SDRC_CS1_OSET);
402010c0:	e59f3044 	ldr	r3, [pc, #68]	; 4020110c <config_3430sdram_ddr+0xf4>
	__raw_writel(MICRON_SDRC_ACTIM_CTRLB_0, SDRC_ACTIM_CTRLB_1);

	__raw_writel(SDP_SDRC_RFR_CTRL, SDRC_RFR_CTRL + SDRC_CS1_OSET);
	/* init sequence for mDDR/mSDR using manual commands */
	__raw_writel(CMD_NOP, SDRC_MANUAL_0 + SDRC_CS1_OSET);
	delay(5000);   /* supposed to be 100us per design spec for mddr/msdr */
402010c4:	e3010388 	movw	r0, #5000	; 0x1388
#endif

#ifdef CONFIG_DDR_256MB_STACKED
	make_cs1_contiguous();

	__raw_writel(SDP_SDRC_MDCFG_0_DDR, SDRC_MCFG_0 + SDRC_CS1_OSET);
402010c8:	e58430b0 	str	r3, [r4, #176]	; 0xb0
	__raw_writel(MICRON_SDRC_ACTIM_CTRLA_0, SDRC_ACTIM_CTRLA_1);
402010cc:	e59f3040 	ldr	r3, [pc, #64]	; 40201114 <config_3430sdram_ddr+0xfc>
402010d0:	e58430c4 	str	r3, [r4, #196]	; 0xc4
	__raw_writel(MICRON_SDRC_ACTIM_CTRLB_0, SDRC_ACTIM_CTRLB_1);
402010d4:	e59f3040 	ldr	r3, [pc, #64]	; 4020111c <config_3430sdram_ddr+0x104>
402010d8:	e58430c8 	str	r3, [r4, #200]	; 0xc8

	__raw_writel(SDP_SDRC_RFR_CTRL, SDRC_RFR_CTRL + SDRC_CS1_OSET);
402010dc:	e59f3040 	ldr	r3, [pc, #64]	; 40201124 <config_3430sdram_ddr+0x10c>
402010e0:	e58430d4 	str	r3, [r4, #212]	; 0xd4
	/* init sequence for mDDR/mSDR using manual commands */
	__raw_writel(CMD_NOP, SDRC_MANUAL_0 + SDRC_CS1_OSET);
402010e4:	e58470d8 	str	r7, [r4, #216]	; 0xd8
	delay(5000);   /* supposed to be 100us per design spec for mddr/msdr */
402010e8:	ebffff69 	bl	40200e94 <delay>
	__raw_writel(CMD_PRECHARGE, SDRC_MANUAL_0 + SDRC_CS1_OSET);
402010ec:	e3a03001 	mov	r3, #1
402010f0:	e58430d8 	str	r3, [r4, #216]	; 0xd8
	__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_0 + SDRC_CS1_OSET);
402010f4:	e58450d8 	str	r5, [r4, #216]	; 0xd8
	__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_0 + SDRC_CS1_OSET);
402010f8:	e58450d8 	str	r5, [r4, #216]	; 0xd8
	__raw_writel(SDP_SDRC_MR_0_DDR, SDRC_MR_0 + SDRC_CS1_OSET);
402010fc:	e58460b4 	str	r6, [r4, #180]	; 0xb4
#endif
}
40201100:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
40201104:	6d000014 	.word	0x6d000014
40201108:	00b71b00 	.word	0x00b71b00
4020110c:	02584099 	.word	0x02584099
40201110:	92e1c4c6 	.word	0x92e1c4c6
40201114:	aa9db4c6 	.word	0xaa9db4c6
40201118:	0002111c 	.word	0x0002111c
4020111c:	00011517 	.word	0x00011517
40201120:	0004dc01 	.word	0x0004dc01
40201124:	0004e201 	.word	0x0004e201

40201128 <get_osc_clk_speed>:
 *************************************************************/
u32 get_osc_clk_speed(void)
{
	u32 start, cstart, cend, cdiff, cdiv, val;

	val = __raw_readl(PRM_CLKSRC_CTRL);
40201128:	e59f30f0 	ldr	r3, [pc, #240]	; 40201220 <get_osc_clk_speed+0xf8>
4020112c:	e5933270 	ldr	r3, [r3, #624]	; 0x270

	if (val & BIT7)
40201130:	e3130080 	tst	r3, #128	; 0x80
		 *      For now, assume divider as 1.
		 */
		cdiv = 1;

	/* enable timer2 */
	val = __raw_readl(CM_CLKSEL_WKUP) | BIT0;
40201134:	e59f30e8 	ldr	r3, [pc, #232]	; 40201224 <get_osc_clk_speed+0xfc>
{
	u32 start, cstart, cend, cdiff, cdiv, val;

	val = __raw_readl(PRM_CLKSRC_CTRL);

	if (val & BIT7)
40201138:	13a01002 	movne	r1, #2
4020113c:	03a01001 	moveq	r1, #1
		 *      For now, assume divider as 1.
		 */
		cdiv = 1;

	/* enable timer2 */
	val = __raw_readl(CM_CLKSEL_WKUP) | BIT0;
40201140:	e5932c40 	ldr	r2, [r3, #3136]	; 0xc40
40201144:	e3822001 	orr	r2, r2, #1
	__raw_writel(val, CM_CLKSEL_WKUP);	/* select sys_clk for GPT1 */
40201148:	e5832c40 	str	r2, [r3, #3136]	; 0xc40

	/* Enable I and F Clocks for GPT1 */
	val = __raw_readl(CM_ICLKEN_WKUP) | BIT0 | BIT2;
4020114c:	e5932c10 	ldr	r2, [r3, #3088]	; 0xc10
40201150:	e3822005 	orr	r2, r2, #5
	__raw_writel(val, CM_ICLKEN_WKUP);
40201154:	e5832c10 	str	r2, [r3, #3088]	; 0xc10
	val = __raw_readl(CM_FCLKEN_WKUP) | BIT0;
40201158:	e5932c00 	ldr	r2, [r3, #3072]	; 0xc00
4020115c:	e3822001 	orr	r2, r2, #1
	__raw_writel(val, CM_FCLKEN_WKUP);
40201160:	e5832c00 	str	r2, [r3, #3072]	; 0xc00

	__raw_writel(0, OMAP34XX_GPT1 + TLDR);	/* start counting at 0 */
40201164:	e28339c5 	add	r3, r3, #3227648	; 0x314000
40201168:	e3a02000 	mov	r2, #0
4020116c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	__raw_writel(GPT_EN, OMAP34XX_GPT1 + TCLR);     /* enable clock */
40201170:	e2822003 	add	r2, r2, #3
40201174:	e5832024 	str	r2, [r3, #36]	; 0x24
	/* enable 32kHz source *//* enabled out of reset */
	/* determine sys_clk via gauging */

	start = 20 + __raw_readl(S32K_CR);	/* start time in 20 cycles */
40201178:	e2833902 	add	r3, r3, #32768	; 0x8000
4020117c:	e5932010 	ldr	r2, [r3, #16]
40201180:	e2822014 	add	r2, r2, #20
	while (__raw_readl(S32K_CR) < start);	/* dead loop till start time */
40201184:	e59f309c 	ldr	r3, [pc, #156]	; 40201228 <get_osc_clk_speed+0x100>
40201188:	e5933010 	ldr	r3, [r3, #16]
4020118c:	e1530002 	cmp	r3, r2
40201190:	3afffffb 	bcc	40201184 <get_osc_clk_speed+0x5c>
	cstart = __raw_readl(OMAP34XX_GPT1 + TCRR);	/* get start sys_clk count */
40201194:	e59f3090 	ldr	r3, [pc, #144]	; 4020122c <get_osc_clk_speed+0x104>
40201198:	e5933028 	ldr	r3, [r3, #40]	; 0x28
	while (__raw_readl(S32K_CR) < (start + 20));	/* wait for 40 cycles */
4020119c:	e59f0084 	ldr	r0, [pc, #132]	; 40201228 <get_osc_clk_speed+0x100>
402011a0:	e590c010 	ldr	ip, [r0, #16]
402011a4:	e2820014 	add	r0, r2, #20
402011a8:	e15c0000 	cmp	ip, r0
402011ac:	3afffffa 	bcc	4020119c <get_osc_clk_speed+0x74>
	cend = __raw_readl(OMAP34XX_GPT1 + TCRR);	/* get end sys_clk count */
402011b0:	e59f2074 	ldr	r2, [pc, #116]	; 4020122c <get_osc_clk_speed+0x104>
	cdiff = cend - cstart;				/* get elapsed ticks */

	if (cdiv == 2)
402011b4:	e3510002 	cmp	r1, #2

	start = 20 + __raw_readl(S32K_CR);	/* start time in 20 cycles */
	while (__raw_readl(S32K_CR) < start);	/* dead loop till start time */
	cstart = __raw_readl(OMAP34XX_GPT1 + TCRR);	/* get start sys_clk count */
	while (__raw_readl(S32K_CR) < (start + 20));	/* wait for 40 cycles */
	cend = __raw_readl(OMAP34XX_GPT1 + TCRR);	/* get end sys_clk count */
402011b8:	e5922028 	ldr	r2, [r2, #40]	; 0x28
	cdiff = cend - cstart;				/* get elapsed ticks */
402011bc:	e0633002 	rsb	r3, r3, r2
	{
		cdiff *= 2;
	}

	/* based on number of ticks assign speed */
	if (cdiff > 19000)
402011c0:	e3042a38 	movw	r2, #19000	; 0x4a38
	cend = __raw_readl(OMAP34XX_GPT1 + TCRR);	/* get end sys_clk count */
	cdiff = cend - cstart;				/* get elapsed ticks */

	if (cdiv == 2)
	{
		cdiff *= 2;
402011c4:	01a03083 	lsleq	r3, r3, #1
	}

	/* based on number of ticks assign speed */
	if (cdiff > 19000)
402011c8:	e1530002 	cmp	r3, r2
402011cc:	859f005c 	ldrhi	r0, [pc, #92]	; 40201230 <get_osc_clk_speed+0x108>
402011d0:	812fff1e 	bxhi	lr
		return (S38_4M);
	else if (cdiff > 15200)
402011d4:	e3032b60 	movw	r2, #15200	; 0x3b60
402011d8:	e1530002 	cmp	r3, r2
402011dc:	859f0050 	ldrhi	r0, [pc, #80]	; 40201234 <get_osc_clk_speed+0x10c>
402011e0:	812fff1e 	bxhi	lr
		return (S26M);
	else if (cdiff > 13000)
402011e4:	e30322c8 	movw	r2, #13000	; 0x32c8
402011e8:	e1530002 	cmp	r3, r2
402011ec:	859f0044 	ldrhi	r0, [pc, #68]	; 40201238 <get_osc_clk_speed+0x110>
402011f0:	812fff1e 	bxhi	lr
		return (S24M);
	else if (cdiff > 9000)
402011f4:	e3022328 	movw	r2, #9000	; 0x2328
402011f8:	e1530002 	cmp	r3, r2
402011fc:	859f0038 	ldrhi	r0, [pc, #56]	; 4020123c <get_osc_clk_speed+0x114>
40201200:	812fff1e 	bxhi	lr
		return (S19_2M);
	else if (cdiff > 7600)
40201204:	e59f2034 	ldr	r2, [pc, #52]	; 40201240 <get_osc_clk_speed+0x118>
40201208:	e3010db0 	movw	r0, #7600	; 0x1db0
4020120c:	e59f1030 	ldr	r1, [pc, #48]	; 40201244 <get_osc_clk_speed+0x11c>
40201210:	e1530000 	cmp	r3, r0
40201214:	91a00002 	movls	r0, r2
40201218:	81a00001 	movhi	r0, r1
		return (S13M);
	else
		return (S12M);
}
4020121c:	e12fff1e 	bx	lr
40201220:	48307000 	.word	0x48307000
40201224:	48004000 	.word	0x48004000
40201228:	48320000 	.word	0x48320000
4020122c:	48318000 	.word	0x48318000
40201230:	0249f000 	.word	0x0249f000
40201234:	018cba80 	.word	0x018cba80
40201238:	016e3600 	.word	0x016e3600
4020123c:	0124f800 	.word	0x0124f800
40201240:	00b71b00 	.word	0x00b71b00
40201244:	00c65d40 	.word	0x00c65d40

40201248 <get_sys_clkin_sel>:
 *   -- input oscillator clock frequency.
 *
 *****************************************************************************/
void get_sys_clkin_sel(u32 osc_clk, u32 *sys_clkin_sel)
{
	if(osc_clk == S38_4M)
40201248:	e59f3050 	ldr	r3, [pc, #80]	; 402012a0 <get_sys_clkin_sel+0x58>
4020124c:	e1500003 	cmp	r0, r3
		*sys_clkin_sel=  4;
40201250:	03a03004 	moveq	r3, #4
 *   -- input oscillator clock frequency.
 *
 *****************************************************************************/
void get_sys_clkin_sel(u32 osc_clk, u32 *sys_clkin_sel)
{
	if(osc_clk == S38_4M)
40201254:	0a00000f 	beq	40201298 <get_sys_clkin_sel+0x50>
		*sys_clkin_sel=  4;
	else if(osc_clk == S26M)
40201258:	e59f3044 	ldr	r3, [pc, #68]	; 402012a4 <get_sys_clkin_sel+0x5c>
4020125c:	e1500003 	cmp	r0, r3
		*sys_clkin_sel = 3;
40201260:	03a03003 	moveq	r3, #3
 *****************************************************************************/
void get_sys_clkin_sel(u32 osc_clk, u32 *sys_clkin_sel)
{
	if(osc_clk == S38_4M)
		*sys_clkin_sel=  4;
	else if(osc_clk == S26M)
40201264:	0a00000b 	beq	40201298 <get_sys_clkin_sel+0x50>
		*sys_clkin_sel = 3;
	else if(osc_clk == S19_2M)
40201268:	e59f3038 	ldr	r3, [pc, #56]	; 402012a8 <get_sys_clkin_sel+0x60>
4020126c:	e1500003 	cmp	r0, r3
		*sys_clkin_sel = 2;
40201270:	03a03002 	moveq	r3, #2
{
	if(osc_clk == S38_4M)
		*sys_clkin_sel=  4;
	else if(osc_clk == S26M)
		*sys_clkin_sel = 3;
	else if(osc_clk == S19_2M)
40201274:	0a000007 	beq	40201298 <get_sys_clkin_sel+0x50>
		*sys_clkin_sel = 2;
	else if(osc_clk == S13M)
40201278:	e59f302c 	ldr	r3, [pc, #44]	; 402012ac <get_sys_clkin_sel+0x64>
4020127c:	e1500003 	cmp	r0, r3
		*sys_clkin_sel = 1;
40201280:	03a03001 	moveq	r3, #1
		*sys_clkin_sel=  4;
	else if(osc_clk == S26M)
		*sys_clkin_sel = 3;
	else if(osc_clk == S19_2M)
		*sys_clkin_sel = 2;
	else if(osc_clk == S13M)
40201284:	0a000003 	beq	40201298 <get_sys_clkin_sel+0x50>
		*sys_clkin_sel = 1;
	else if(osc_clk == S12M)
40201288:	e59f3020 	ldr	r3, [pc, #32]	; 402012b0 <get_sys_clkin_sel+0x68>
4020128c:	e1500003 	cmp	r0, r3
40201290:	112fff1e 	bxne	lr
		*sys_clkin_sel = 0;
40201294:	e3a03000 	mov	r3, #0
40201298:	e5813000 	str	r3, [r1]
4020129c:	e12fff1e 	bx	lr
402012a0:	0249f000 	.word	0x0249f000
402012a4:	018cba80 	.word	0x018cba80
402012a8:	0124f800 	.word	0x0124f800
402012ac:	00c65d40 	.word	0x00c65d40
402012b0:	00b71b00 	.word	0x00b71b00

402012b4 <secure_unlock>:
	__raw_writel(UNLOCK_1, RT_REQ_INFO_PERMISSION_1);
	__raw_writel(UNLOCK_1, RT_READ_PERMISSION_0);
	__raw_writel(UNLOCK_1, RT_WRITE_PERMISSION_0);
	__raw_writel(UNLOCK_2, RT_ADDR_MATCH_1);

	__raw_writel(UNLOCK_3, GPMC_REQ_INFO_PERMISSION_0);
402012b4:	e59f2054 	ldr	r2, [pc, #84]	; 40201310 <secure_unlock+0x5c>
	/* Permission values for registers -Full fledged permissions to all */
	#define UNLOCK_1 0xFFFFFFFF
	#define UNLOCK_2 0x00000000
	#define UNLOCK_3 0x0000FFFF
	/* Protection Module Register Target APE (PM_RT)*/
	__raw_writel(UNLOCK_1, RT_REQ_INFO_PERMISSION_1);
402012b8:	e3e01000 	mvn	r1, #0
402012bc:	e59f3050 	ldr	r3, [pc, #80]	; 40201314 <secure_unlock+0x60>
	__raw_writel(UNLOCK_1, RT_READ_PERMISSION_0);
	__raw_writel(UNLOCK_1, RT_WRITE_PERMISSION_0);
	__raw_writel(UNLOCK_2, RT_ADDR_MATCH_1);
402012c0:	e3a00000 	mov	r0, #0
	/* Permission values for registers -Full fledged permissions to all */
	#define UNLOCK_1 0xFFFFFFFF
	#define UNLOCK_2 0x00000000
	#define UNLOCK_3 0x0000FFFF
	/* Protection Module Register Target APE (PM_RT)*/
	__raw_writel(UNLOCK_1, RT_REQ_INFO_PERMISSION_1);
402012c4:	e5831068 	str	r1, [r3, #104]	; 0x68
	__raw_writel(UNLOCK_1, RT_READ_PERMISSION_0);
402012c8:	e5831050 	str	r1, [r3, #80]	; 0x50
	__raw_writel(UNLOCK_1, RT_WRITE_PERMISSION_0);
402012cc:	e5831058 	str	r1, [r3, #88]	; 0x58
	__raw_writel(UNLOCK_2, RT_ADDR_MATCH_1);
402012d0:	e5830060 	str	r0, [r3, #96]	; 0x60

	__raw_writel(UNLOCK_3, GPMC_REQ_INFO_PERMISSION_0);
402012d4:	e243335a 	sub	r3, r3, #1744830465	; 0x68000001
402012d8:	e5823448 	str	r3, [r2, #1096]	; 0x448
	__raw_writel(UNLOCK_3, GPMC_READ_PERMISSION_0);
402012dc:	e5823450 	str	r3, [r2, #1104]	; 0x450
	__raw_writel(UNLOCK_3, GPMC_WRITE_PERMISSION_0);
402012e0:	e5823458 	str	r3, [r2, #1112]	; 0x458

	__raw_writel(UNLOCK_3, OCM_REQ_INFO_PERMISSION_0);
402012e4:	e5823848 	str	r3, [r2, #2120]	; 0x848
	__raw_writel(UNLOCK_3, OCM_READ_PERMISSION_0);
402012e8:	e5823850 	str	r3, [r2, #2128]	; 0x850
	__raw_writel(UNLOCK_3, OCM_WRITE_PERMISSION_0);
402012ec:	e5823858 	str	r3, [r2, #2136]	; 0x858
	__raw_writel(UNLOCK_2, OCM_ADDR_MATCH_2);
402012f0:	e5820880 	str	r0, [r2, #2176]	; 0x880

	/* IVA Changes */
	__raw_writel(UNLOCK_3, IVA2_REQ_INFO_PERMISSION_0);
402012f4:	e2822a02 	add	r2, r2, #8192	; 0x2000
402012f8:	e5823048 	str	r3, [r2, #72]	; 0x48
	__raw_writel(UNLOCK_3, IVA2_READ_PERMISSION_0);
402012fc:	e5823050 	str	r3, [r2, #80]	; 0x50
	__raw_writel(UNLOCK_3, IVA2_WRITE_PERMISSION_0);
40201300:	e5823058 	str	r3, [r2, #88]	; 0x58

	__raw_writel(UNLOCK_1, SMS_RG_ATT0); /* SDRC region 0 public */
40201304:	e3a0331b 	mov	r3, #1811939328	; 0x6c000000
40201308:	e5831048 	str	r1, [r3, #72]	; 0x48
}
4020130c:	e12fff1e 	bx	lr
40201310:	68012000 	.word	0x68012000
40201314:	68010000 	.word	0x68010000

40201318 <try_unlock_memory>:
 * Routine: try_unlock_sram()
 * Description: If chip is GP type, unlock the SRAM for
 *  general use.
 ***********************************************************/
void try_unlock_memory(void)
{
40201318:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int mode;

	/* if GP device unlock device SRAM for general use */
	/* secure code breaks for Secure/Emulation device - HS/E/T*/
	mode = get_device_type();
4020131c:	ebfffee2 	bl	40200eac <get_device_type>
	if (mode == GP_DEVICE) {
40201320:	e3500003 	cmp	r0, #3
40201324:	149df004 	popne	{pc}		; (ldrne pc, [sp], #4)
		secure_unlock();
	}
	return;
}
40201328:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)

	/* if GP device unlock device SRAM for general use */
	/* secure code breaks for Secure/Emulation device - HS/E/T*/
	mode = get_device_type();
	if (mode == GP_DEVICE) {
		secure_unlock();
4020132c:	eaffffe0 	b	402012b4 <secure_unlock>

40201330 <misc_init_r>:
 * Description: Init ethernet (done here so udelay works)
 ********************************************************/
int misc_init_r (void)
{
	return(0);
}
40201330:	e3a00000 	mov	r0, #0
40201334:	e12fff1e 	bx	lr

40201338 <wait_for_command_complete>:
 ******************************************************/
void wait_for_command_complete(unsigned int wd_base)
{
	int pending = 1;
	do {
		pending = __raw_readl(wd_base + WWPS);
40201338:	e5903034 	ldr	r3, [r0, #52]	; 0x34
	} while (pending);
4020133c:	e3530000 	cmp	r3, #0
40201340:	1afffffc 	bne	40201338 <wait_for_command_complete>
}
40201344:	e12fff1e 	bx	lr

40201348 <watchdog_init>:
	/* There are 3 watch dogs WD1=Secure, WD2=MPU, WD3=IVA. WD1 is
	 * either taken care of by ROM (HS/EMU) or not accessible (GP).
	 * We need to take care of WD2-MPU or take a PRCM reset.  WD3
	 * should not be running and does not generate a PRCM reset.
	 */
	sr32(CM_FCLKEN_WKUP, 5, 1, 1);
40201348:	e3a02001 	mov	r2, #1
4020134c:	e59f0054 	ldr	r0, [pc, #84]	; 402013a8 <watchdog_init+0x60>
/****************************************
 * Routine: watchdog_init
 * Description: Shut down watch dogs
 *****************************************/
void watchdog_init(void)
{
40201350:	e92d4010 	push	{r4, lr}
	/* There are 3 watch dogs WD1=Secure, WD2=MPU, WD3=IVA. WD1 is
	 * either taken care of by ROM (HS/EMU) or not accessible (GP).
	 * We need to take care of WD2-MPU or take a PRCM reset.  WD3
	 * should not be running and does not generate a PRCM reset.
	 */
	sr32(CM_FCLKEN_WKUP, 5, 1, 1);
40201354:	e1a03002 	mov	r3, r2
40201358:	e3a01005 	mov	r1, #5
	sr32(CM_ICLKEN_WKUP, 5, 1, 1);
	wait_on_value(BIT5, 0x20, CM_IDLEST_WKUP, 5); /* some issue here */

	__raw_writel(WD_UNLOCK1, WD2_BASE + WSPR);
4020135c:	e59f4048 	ldr	r4, [pc, #72]	; 402013ac <watchdog_init+0x64>
	/* There are 3 watch dogs WD1=Secure, WD2=MPU, WD3=IVA. WD1 is
	 * either taken care of by ROM (HS/EMU) or not accessible (GP).
	 * We need to take care of WD2-MPU or take a PRCM reset.  WD3
	 * should not be running and does not generate a PRCM reset.
	 */
	sr32(CM_FCLKEN_WKUP, 5, 1, 1);
40201360:	ebffff07 	bl	40200f84 <sr32>
	sr32(CM_ICLKEN_WKUP, 5, 1, 1);
40201364:	e3a02001 	mov	r2, #1
40201368:	e1a03002 	mov	r3, r2
4020136c:	e59f003c 	ldr	r0, [pc, #60]	; 402013b0 <watchdog_init+0x68>
40201370:	e3a01005 	mov	r1, #5
40201374:	ebffff02 	bl	40200f84 <sr32>
	wait_on_value(BIT5, 0x20, CM_IDLEST_WKUP, 5); /* some issue here */
40201378:	e3a00020 	mov	r0, #32
4020137c:	e1a01000 	mov	r1, r0
40201380:	e59f202c 	ldr	r2, [pc, #44]	; 402013b4 <watchdog_init+0x6c>
40201384:	e3a03005 	mov	r3, #5
40201388:	ebffff05 	bl	40200fa4 <wait_on_value>

	__raw_writel(WD_UNLOCK1, WD2_BASE + WSPR);
4020138c:	e30a3aaa 	movw	r3, #43690	; 0xaaaa
	wait_for_command_complete(WD2_BASE);
40201390:	e1a00004 	mov	r0, r4
	 */
	sr32(CM_FCLKEN_WKUP, 5, 1, 1);
	sr32(CM_ICLKEN_WKUP, 5, 1, 1);
	wait_on_value(BIT5, 0x20, CM_IDLEST_WKUP, 5); /* some issue here */

	__raw_writel(WD_UNLOCK1, WD2_BASE + WSPR);
40201394:	e5843048 	str	r3, [r4, #72]	; 0x48
	wait_for_command_complete(WD2_BASE);
40201398:	ebffffe6 	bl	40201338 <wait_for_command_complete>
	__raw_writel(WD_UNLOCK2, WD2_BASE + WSPR);
4020139c:	e3053555 	movw	r3, #21845	; 0x5555
402013a0:	e5843048 	str	r3, [r4, #72]	; 0x48
}
402013a4:	e8bd8010 	pop	{r4, pc}
402013a8:	48004c00 	.word	0x48004c00
402013ac:	48314000 	.word	0x48314000
402013b0:	48004c10 	.word	0x48004c10
402013b4:	48004c20 	.word	0x48004c20

402013b8 <dram_init>:
 * Description: sets uboots idea of sdram size
 **********************************************/
int dram_init (void)
{
	return 0;
}
402013b8:	e3a00000 	mov	r0, #0
402013bc:	e12fff1e 	bx	lr

402013c0 <per_clocks_enable>:
 * Description: Enable the clks & power for perifs (GPT2, UART1,...)
 ******************************************************************/
void per_clocks_enable(void)
{
	/* Enable GP2 timer. */
	sr32(CM_CLKSEL_PER, 0, 1, 0x1); /* GPT2 = sys clk */
402013c0:	e3a02001 	mov	r2, #1
402013c4:	e59f0090 	ldr	r0, [pc, #144]	; 4020145c <per_clocks_enable+0x9c>
/*****************************************************************
 * Routine: peripheral_enable
 * Description: Enable the clks & power for perifs (GPT2, UART1,...)
 ******************************************************************/
void per_clocks_enable(void)
{
402013c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	/* Enable GP2 timer. */
	sr32(CM_CLKSEL_PER, 0, 1, 0x1); /* GPT2 = sys clk */
402013cc:	e1a03002 	mov	r3, r2
402013d0:	e3a01000 	mov	r1, #0
402013d4:	ebfffeea 	bl	40200f84 <sr32>
	sr32(CM_ICLKEN_PER, 3, 1, 0x1); /* ICKen GPT2 */
402013d8:	e3a02001 	mov	r2, #1
402013dc:	e1a03002 	mov	r3, r2
402013e0:	e59f0078 	ldr	r0, [pc, #120]	; 40201460 <per_clocks_enable+0xa0>
402013e4:	e3a01003 	mov	r1, #3
402013e8:	ebfffee5 	bl	40200f84 <sr32>
	sr32(CM_FCLKEN_PER, 3, 1, 0x1); /* FCKen GPT2 */
402013ec:	e3a02001 	mov	r2, #1
402013f0:	e1a03002 	mov	r3, r2
402013f4:	e59f0068 	ldr	r0, [pc, #104]	; 40201464 <per_clocks_enable+0xa4>
402013f8:	e3a01003 	mov	r1, #3
402013fc:	ebfffee0 	bl	40200f84 <sr32>

#ifdef CFG_NS16550
	/* Enable UART1 clocks */
	sr32(CM_FCLKEN1_CORE, 13, 1, 0x1);
40201400:	e3a02001 	mov	r2, #1
40201404:	e1a03002 	mov	r3, r2
40201408:	e59f0058 	ldr	r0, [pc, #88]	; 40201468 <per_clocks_enable+0xa8>
4020140c:	e3a0100d 	mov	r1, #13
40201410:	ebfffedb 	bl	40200f84 <sr32>
	sr32(CM_ICLKEN1_CORE, 13, 1, 0x1);
40201414:	e3a02001 	mov	r2, #1
40201418:	e1a03002 	mov	r3, r2
4020141c:	e59f0048 	ldr	r0, [pc, #72]	; 4020146c <per_clocks_enable+0xac>
40201420:	e3a0100d 	mov	r1, #13
40201424:	ebfffed6 	bl	40200f84 <sr32>
#endif

#ifdef CONFIG_MMC
	/* Enable MMC1 clocks */
	sr32(CM_FCLKEN1_CORE, 24, 1, 0x1);
40201428:	e3a02001 	mov	r2, #1
4020142c:	e1a03002 	mov	r3, r2
40201430:	e59f0030 	ldr	r0, [pc, #48]	; 40201468 <per_clocks_enable+0xa8>
40201434:	e3a01018 	mov	r1, #24
40201438:	ebfffed1 	bl	40200f84 <sr32>
	sr32(CM_ICLKEN1_CORE, 24, 1, 0x1);
4020143c:	e3a02001 	mov	r2, #1
40201440:	e59f0024 	ldr	r0, [pc, #36]	; 4020146c <per_clocks_enable+0xac>
40201444:	e3a01018 	mov	r1, #24
40201448:	e1a03002 	mov	r3, r2
4020144c:	ebfffecc 	bl	40200f84 <sr32>
#endif
	delay(1000);
40201450:	e3a00ffa 	mov	r0, #1000	; 0x3e8
}
40201454:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
#ifdef CONFIG_MMC
	/* Enable MMC1 clocks */
	sr32(CM_FCLKEN1_CORE, 24, 1, 0x1);
	sr32(CM_ICLKEN1_CORE, 24, 1, 0x1);
#endif
	delay(1000);
40201458:	eafffe8d 	b	40200e94 <delay>
4020145c:	48005040 	.word	0x48005040
40201460:	48005010 	.word	0x48005010
40201464:	48005000 	.word	0x48005000
40201468:	48004a00 	.word	0x48004a00
4020146c:	48004a10 	.word	0x48004a10

40201470 <set_muxconf_regs>:
 *              specific to the hardware. Many pins need
 *              to be moved from protect to primary mode.
 *********************************************************/
void set_muxconf_regs(void)
{
	MUX_DEFAULT();
40201470:	e59f3218 	ldr	r3, [pc, #536]	; 40201690 <set_muxconf_regs+0x220>
40201474:	e3a02c01 	mov	r2, #256	; 0x100
40201478:	e59fc214 	ldr	ip, [pc, #532]	; 40201694 <set_muxconf_regs+0x224>
4020147c:	e3a00000 	mov	r0, #0
 * Description: Setting up the configuration Mux registers
 *              specific to the hardware. Many pins need
 *              to be moved from protect to primary mode.
 *********************************************************/
void set_muxconf_regs(void)
{
40201480:	e92d4010 	push	{r4, lr}
	MUX_DEFAULT();
40201484:	e3a01018 	mov	r1, #24
40201488:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
4020148c:	e3a04f47 	mov	r4, #284	; 0x11c
40201490:	e1c323b2 	strh	r2, [r3, #50]	; 0x32
40201494:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
40201498:	e1c323b6 	strh	r2, [r3, #54]	; 0x36
4020149c:	e1c323b8 	strh	r2, [r3, #56]	; 0x38
402014a0:	e1c323ba 	strh	r2, [r3, #58]	; 0x3a
402014a4:	e1c323bc 	strh	r2, [r3, #60]	; 0x3c
402014a8:	e1c323be 	strh	r2, [r3, #62]	; 0x3e
402014ac:	e1c324b0 	strh	r2, [r3, #64]	; 0x40
402014b0:	e1c324b2 	strh	r2, [r3, #66]	; 0x42
402014b4:	e1c324b4 	strh	r2, [r3, #68]	; 0x44
402014b8:	e1c324b6 	strh	r2, [r3, #70]	; 0x46
402014bc:	e1c324b8 	strh	r2, [r3, #72]	; 0x48
402014c0:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
402014c4:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
402014c8:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
402014cc:	e1c325b0 	strh	r2, [r3, #80]	; 0x50
402014d0:	e1c325b2 	strh	r2, [r3, #82]	; 0x52
402014d4:	e1c325b4 	strh	r2, [r3, #84]	; 0x54
402014d8:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
402014dc:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
402014e0:	e1c325ba 	strh	r2, [r3, #90]	; 0x5a
402014e4:	e1c325bc 	strh	r2, [r3, #92]	; 0x5c
402014e8:	e1c325be 	strh	r2, [r3, #94]	; 0x5e
402014ec:	e1c326b0 	strh	r2, [r3, #96]	; 0x60
402014f0:	e1c326b2 	strh	r2, [r3, #98]	; 0x62
402014f4:	e1c326b4 	strh	r2, [r3, #100]	; 0x64
402014f8:	e1c326b6 	strh	r2, [r3, #102]	; 0x66
402014fc:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
40201500:	e1c326ba 	strh	r2, [r3, #106]	; 0x6a
40201504:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
40201508:	e1c326be 	strh	r2, [r3, #110]	; 0x6e
4020150c:	e1c327b0 	strh	r2, [r3, #112]	; 0x70
40201510:	e1c327b2 	strh	r2, [r3, #114]	; 0x72
40201514:	e1c327b4 	strh	r2, [r3, #116]	; 0x74
40201518:	e1c327b6 	strh	r2, [r3, #118]	; 0x76
4020151c:	e1c327b8 	strh	r2, [r3, #120]	; 0x78
40201520:	e1c307ba 	strh	r0, [r3, #122]	; 0x7a
40201524:	e1c307bc 	strh	r0, [r3, #124]	; 0x7c
40201528:	e1c307be 	strh	r0, [r3, #126]	; 0x7e
4020152c:	e1c308b0 	strh	r0, [r3, #128]	; 0x80
40201530:	e1c308b2 	strh	r0, [r3, #130]	; 0x82
40201534:	e1c308b4 	strh	r0, [r3, #132]	; 0x84
40201538:	e1c308b6 	strh	r0, [r3, #134]	; 0x86
4020153c:	e1c308b8 	strh	r0, [r3, #136]	; 0x88
40201540:	e1c308ba 	strh	r0, [r3, #138]	; 0x8a
40201544:	e1c308bc 	strh	r0, [r3, #140]	; 0x8c
40201548:	e1c328be 	strh	r2, [r3, #142]	; 0x8e
4020154c:	e1c329b0 	strh	r2, [r3, #144]	; 0x90
40201550:	e1c329b2 	strh	r2, [r3, #146]	; 0x92
40201554:	e1c329b4 	strh	r2, [r3, #148]	; 0x94
40201558:	e1c329b6 	strh	r2, [r3, #150]	; 0x96
4020155c:	e1c329b8 	strh	r2, [r3, #152]	; 0x98
40201560:	e1c329ba 	strh	r2, [r3, #154]	; 0x9a
40201564:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
40201568:	e1c329be 	strh	r2, [r3, #158]	; 0x9e
4020156c:	e1c32ab0 	strh	r2, [r3, #160]	; 0xa0
40201570:	e1c32ab2 	strh	r2, [r3, #162]	; 0xa2
40201574:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
40201578:	e1c32ab6 	strh	r2, [r3, #166]	; 0xa6
4020157c:	e1c32ab8 	strh	r2, [r3, #168]	; 0xa8
40201580:	e1c32aba 	strh	r2, [r3, #170]	; 0xaa
40201584:	e1c32abc 	strh	r2, [r3, #172]	; 0xac
40201588:	e1c31abe 	strh	r1, [r3, #174]	; 0xae
4020158c:	e1c31bb0 	strh	r1, [r3, #176]	; 0xb0
40201590:	e1c31bb2 	strh	r1, [r3, #178]	; 0xb2
40201594:	e1c31bb4 	strh	r1, [r3, #180]	; 0xb4
40201598:	e1c31bb6 	strh	r1, [r3, #182]	; 0xb6
4020159c:	e1c31bb8 	strh	r1, [r3, #184]	; 0xb8
402015a0:	e1c31bba 	strh	r1, [r3, #186]	; 0xba
402015a4:	e1c31bbc 	strh	r1, [r3, #188]	; 0xbc
402015a8:	e3a01004 	mov	r1, #4
402015ac:	e1c30bbe 	strh	r0, [r3, #190]	; 0xbe
402015b0:	e1c30cb0 	strh	r0, [r3, #192]	; 0xc0
402015b4:	e1c30cb2 	strh	r0, [r3, #194]	; 0xc2
402015b8:	e1c30cb4 	strh	r0, [r3, #196]	; 0xc4
402015bc:	e1c30cb6 	strh	r0, [r3, #198]	; 0xc6
402015c0:	e1c31cb8 	strh	r1, [r3, #200]	; 0xc8
402015c4:	e3a01f46 	mov	r1, #280	; 0x118
402015c8:	e1c32cba 	strh	r2, [r3, #202]	; 0xca
402015cc:	e1c31cbc 	strh	r1, [r3, #204]	; 0xcc
402015d0:	e1c31cbe 	strh	r1, [r3, #206]	; 0xce
402015d4:	e3a01f41 	mov	r1, #260	; 0x104
402015d8:	e1c34db0 	strh	r4, [r3, #208]	; 0xd0
402015dc:	e1c34db2 	strh	r4, [r3, #210]	; 0xd2
402015e0:	e3a03e11 	mov	r3, #272	; 0x110
402015e4:	e1cc10b0 	strh	r1, [ip]
402015e8:	e1cc10b2 	strh	r1, [ip, #2]
402015ec:	e1cc10b4 	strh	r1, [ip, #4]
402015f0:	e1cc10b6 	strh	r1, [ip, #6]
402015f4:	e1cc13b0 	strh	r1, [ip, #48]	; 0x30
402015f8:	e1cc07bc 	strh	r0, [ip, #124]	; 0x7c
402015fc:	e1cc07be 	strh	r0, [ip, #126]	; 0x7e
40201600:	e1cc38b0 	strh	r3, [ip, #128]	; 0x80
40201604:	e59f308c 	ldr	r3, [pc, #140]	; 40201698 <set_muxconf_regs+0x228>
40201608:	e1cc28b2 	strh	r2, [ip, #130]	; 0x82
4020160c:	e1cc19b0 	strh	r1, [ip, #144]	; 0x90
40201610:	e1c320b4 	strh	r2, [r3, #4]
40201614:	e1c310ba 	strh	r1, [r3, #10]
40201618:	e1c310bc 	strh	r1, [r3, #12]
4020161c:	e1c310be 	strh	r1, [r3, #14]
40201620:	e1c311b0 	strh	r1, [r3, #16]
40201624:	e1c311b2 	strh	r1, [r3, #18]
40201628:	e1c311b4 	strh	r1, [r3, #20]
4020162c:	e1c311b6 	strh	r1, [r3, #22]
40201630:	e1cc4eb2 	strh	r4, [ip, #226]	; 0xe2
40201634:	e1c321bc 	strh	r2, [r3, #28]
40201638:	e1c321be 	strh	r2, [r3, #30]
4020163c:	e1c322b0 	strh	r2, [r3, #32]
40201640:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
40201644:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
40201648:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
4020164c:	e1c312b8 	strh	r1, [r3, #40]	; 0x28
40201650:	e1c312ba 	strh	r1, [r3, #42]	; 0x2a
40201654:	e1c312bc 	strh	r1, [r3, #44]	; 0x2c
40201658:	e1c312be 	strh	r1, [r3, #46]	; 0x2e
4020165c:	e1c313b0 	strh	r1, [r3, #48]	; 0x30
40201660:	e1c314b0 	strh	r1, [r3, #64]	; 0x40
40201664:	e1c314b2 	strh	r1, [r3, #66]	; 0x42
40201668:	e1c314b4 	strh	r1, [r3, #68]	; 0x44
4020166c:	e1c314b6 	strh	r1, [r3, #70]	; 0x46
40201670:	e1c314b8 	strh	r1, [r3, #72]	; 0x48
40201674:	e1c314ba 	strh	r1, [r3, #74]	; 0x4a
40201678:	e3a01f42 	mov	r1, #264	; 0x108
4020167c:	e1cc19ba 	strh	r1, [ip, #154]	; 0x9a
40201680:	e1cc09bc 	strh	r0, [ip, #156]	; 0x9c
40201684:	e1cc29be 	strh	r2, [ip, #158]	; 0x9e
40201688:	e1cc0ab0 	strh	r0, [ip, #160]	; 0xa0
}
4020168c:	e8bd8010 	pop	{r4, pc}
40201690:	48002000 	.word	0x48002000
40201694:	48002100 	.word	0x48002100
40201698:	48002a00 	.word	0x48002a00

4020169c <board_hang>:
       return size;
}

/* optionally do something like blinking LED */
void board_hang (void)
{ while (0) {};}
4020169c:	e12fff1e 	bx	lr

402016a0 <mmc_boot>:
}


typedef int (mmc_boot_addr) (void);
int mmc_boot(unsigned char *buf)
{
402016a0:	e92d4030 	push	{r4, r5, lr}
402016a4:	e1a05000 	mov	r5, r0
       long size = 0;
#ifdef CFG_CMD_FAT
       block_dev_desc_t *dev_desc = NULL;
       unsigned char ret = 0;

       printf("Starting X-loader on MMC\n");
402016a8:	e59f0064 	ldr	r0, [pc, #100]	; 40201714 <mmc_boot+0x74>
402016ac:	eb0005b6 	bl	40202d8c <serial_printf>

       ret = mmc_init(1);
402016b0:	e3a00001 	mov	r0, #1
402016b4:	eb000483 	bl	402028c8 <mmc_init>
       if(ret == 0){
402016b8:	e6ef4070 	uxtb	r4, r0
402016bc:	e3540000 	cmp	r4, #0
               printf("\n MMC init failed\n");
402016c0:	059f0050 	ldreq	r0, [pc, #80]	; 40201718 <mmc_boot+0x78>
       unsigned char ret = 0;

       printf("Starting X-loader on MMC\n");

       ret = mmc_init(1);
       if(ret == 0){
402016c4:	0a00000f 	beq	40201708 <mmc_boot+0x68>
               printf("\n MMC init failed\n");
               return 0;
       }
       //kai-2010/09/10
       //printf("test-point1...\n");
       dev_desc = mmc_get_dev(0);
402016c8:	e3a00000 	mov	r0, #0
402016cc:	eb000275 	bl	402020a8 <mmc_get_dev>
       //printf("test-point2...\n");
       fat_register_device(dev_desc, 1);
402016d0:	e3a01001 	mov	r1, #1
402016d4:	eb00077e 	bl	402034d4 <fat_register_device>
       //printf("test-point3...\n");
       size = file_fat_read("u-boot.bin", buf, 0);
402016d8:	e59f003c 	ldr	r0, [pc, #60]	; 4020171c <mmc_boot+0x7c>
402016dc:	e1a01005 	mov	r1, r5
402016e0:	e3a02000 	mov	r2, #0
402016e4:	eb0009db 	bl	40203e58 <file_fat_read>
       if (size == -1) {
402016e8:	e3700001 	cmn	r0, #1
       //printf("test-point1...\n");
       dev_desc = mmc_get_dev(0);
       //printf("test-point2...\n");
       fat_register_device(dev_desc, 1);
       //printf("test-point3...\n");
       size = file_fat_read("u-boot.bin", buf, 0);
402016ec:	e1a04000 	mov	r4, r0
       if (size == -1) {
402016f0:	02804001 	addeq	r4, r0, #1
402016f4:	0a000004 	beq	4020170c <mmc_boot+0x6c>
               return 0;
       }
       //printf("test-point4...\n");
       printf("\n%ld Bytes Read from MMC\n", size);
402016f8:	e59f0020 	ldr	r0, [pc, #32]	; 40201720 <mmc_boot+0x80>
402016fc:	e1a01004 	mov	r1, r4
40201700:	eb0005a1 	bl	40202d8c <serial_printf>

       printf("Starting OS Bootloader from MMC...\n");
40201704:	e59f0018 	ldr	r0, [pc, #24]	; 40201724 <mmc_boot+0x84>
40201708:	eb00059f 	bl	40202d8c <serial_printf>
#endif
       return size;
}
4020170c:	e1a00004 	mov	r0, r4
40201710:	e8bd8030 	pop	{r4, r5, pc}
40201714:	40204a78 	.word	0x40204a78
40201718:	40204a92 	.word	0x40204a92
4020171c:	40204aa5 	.word	0x40204aa5
40201720:	40204ab0 	.word	0x40204ab0
40201724:	40204aca 	.word	0x40204aca

40201728 <nand_init>:
 *********************************************************/

int nand_init(void)
{
	/* global settings */
	__raw_writel(0x10, GPMC_SYSCONFIG);	/* smart idle */
40201728:	e3a0346e 	mov	r3, #1845493760	; 0x6e000000
4020172c:	e3a02010 	mov	r2, #16
 * Routine: nand+_init
 * Description: Set up nand for nand and jffs2 commands
 *********************************************************/

int nand_init(void)
{
40201730:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
         *  , NOR at CS1 and MPDB at CS3. And oneNAND boot, we map oneNAND at CS0.
	 *  We configure only GPMC CS0 with required values. Configiring other devices
	 *  at other CS in done in u-boot anyway. So we don't have to bother doing it here.
         */
	__raw_writel(0 , GPMC_CONFIG7 + GPMC_CONFIG_CS0);
	delay(1000);
40201734:	e3a00ffa 	mov	r0, #1000	; 0x3e8
 *********************************************************/

int nand_init(void)
{
	/* global settings */
	__raw_writel(0x10, GPMC_SYSCONFIG);	/* smart idle */
40201738:	e5832010 	str	r2, [r3, #16]
	__raw_writel(0x0, GPMC_IRQENABLE);	/* isr's sources masked */
4020173c:	e3a02000 	mov	r2, #0
40201740:	e583201c 	str	r2, [r3, #28]
	__raw_writel(0, GPMC_TIMEOUT_CONTROL);/* timeout disable */
40201744:	e5832040 	str	r2, [r3, #64]	; 0x40
	/* Set the GPMC Vals . For NAND boot on 3430SDP, NAND is mapped at CS0
         *  , NOR at CS1 and MPDB at CS3. And oneNAND boot, we map oneNAND at CS0.
	 *  We configure only GPMC CS0 with required values. Configiring other devices
	 *  at other CS in done in u-boot anyway. So we don't have to bother doing it here.
         */
	__raw_writel(0 , GPMC_CONFIG7 + GPMC_CONFIG_CS0);
40201748:	e5832078 	str	r2, [r3, #120]	; 0x78
	delay(1000);
4020174c:	ebfffdd0 	bl	40200e94 <delay>

	if ((get_mem_type() == GPMC_NAND) || (get_mem_type() == MMC_NAND)){
40201750:	ebfffddf 	bl	40200ed4 <get_mem_type>
40201754:	e3500001 	cmp	r0, #1
40201758:	0a000002 	beq	40201768 <nand_init+0x40>
4020175c:	ebfffddc 	bl	40200ed4 <get_mem_type>
40201760:	e3500004 	cmp	r0, #4
40201764:	1a000013 	bne	402017b8 <nand_init+0x90>
        	__raw_writel( M_NAND_GPMC_CONFIG1, GPMC_CONFIG1 + GPMC_CONFIG_CS0);
40201768:	e3a0346e 	mov	r3, #1845493760	; 0x6e000000
4020176c:	e3a02b06 	mov	r2, #6144	; 0x1800
40201770:	e5832060 	str	r2, [r3, #96]	; 0x60

        	/* Enable the GPMC Mapping */
        	__raw_writel(( ((OMAP34XX_GPMC_CS0_SIZE & 0xF)<<8) |
        		     ((NAND_BASE_ADR>>24) & 0x3F) |
        		     (1<<6) ),  (GPMC_CONFIG7 + GPMC_CONFIG_CS0));
        	delay(2000);
40201774:	e3a00e7d 	mov	r0, #2000	; 0x7d0
	__raw_writel(0 , GPMC_CONFIG7 + GPMC_CONFIG_CS0);
	delay(1000);

	if ((get_mem_type() == GPMC_NAND) || (get_mem_type() == MMC_NAND)){
        	__raw_writel( M_NAND_GPMC_CONFIG1, GPMC_CONFIG1 + GPMC_CONFIG_CS0);
        	__raw_writel( M_NAND_GPMC_CONFIG2, GPMC_CONFIG2 + GPMC_CONFIG_CS0);
40201778:	e59f20b8 	ldr	r2, [pc, #184]	; 40201838 <nand_init+0x110>
4020177c:	e5832064 	str	r2, [r3, #100]	; 0x64
        	__raw_writel( M_NAND_GPMC_CONFIG3, GPMC_CONFIG3 + GPMC_CONFIG_CS0);
40201780:	e5832068 	str	r2, [r3, #104]	; 0x68
        	__raw_writel( M_NAND_GPMC_CONFIG4, GPMC_CONFIG4 + GPMC_CONFIG_CS0);
40201784:	e59f20b0 	ldr	r2, [pc, #176]	; 4020183c <nand_init+0x114>
40201788:	e583206c 	str	r2, [r3, #108]	; 0x6c
        	__raw_writel( M_NAND_GPMC_CONFIG5, GPMC_CONFIG5 + GPMC_CONFIG_CS0);
4020178c:	e59f20ac 	ldr	r2, [pc, #172]	; 40201840 <nand_init+0x118>
40201790:	e5832070 	str	r2, [r3, #112]	; 0x70
        	__raw_writel( M_NAND_GPMC_CONFIG6, GPMC_CONFIG6 + GPMC_CONFIG_CS0);
40201794:	e59f20a8 	ldr	r2, [pc, #168]	; 40201844 <nand_init+0x11c>
40201798:	e5832074 	str	r2, [r3, #116]	; 0x74

        	/* Enable the GPMC Mapping */
        	__raw_writel(( ((OMAP34XX_GPMC_CS0_SIZE & 0xF)<<8) |
4020179c:	e3a02e87 	mov	r2, #2160	; 0x870
402017a0:	e5832078 	str	r2, [r3, #120]	; 0x78
        		     ((NAND_BASE_ADR>>24) & 0x3F) |
        		     (1<<6) ),  (GPMC_CONFIG7 + GPMC_CONFIG_CS0));
        	delay(2000);
402017a4:	ebfffdba 	bl	40200e94 <delay>

         	if (nand_chip()){
402017a8:	eb000b65 	bl	40204544 <nand_chip>
402017ac:	e3500000 	cmp	r0, #0
#ifdef CFG_PRINTF
        		printf("Unsupported Chip!\n");
402017b0:	159f0090 	ldrne	r0, [pc, #144]	; 40201848 <nand_init+0x120>
        	__raw_writel(( ((OMAP34XX_GPMC_CS0_SIZE & 0xF)<<8) |
        		     ((NAND_BASE_ADR>>24) & 0x3F) |
        		     (1<<6) ),  (GPMC_CONFIG7 + GPMC_CONFIG_CS0));
        	delay(2000);

         	if (nand_chip()){
402017b4:	1a00001a 	bne	40201824 <nand_init+0xfc>
        		return 1;
        	}

	}

	if ((get_mem_type() == GPMC_ONENAND) || (get_mem_type() == MMC_ONENAND)){
402017b8:	ebfffdc5 	bl	40200ed4 <get_mem_type>
402017bc:	e3500003 	cmp	r0, #3
402017c0:	0a000002 	beq	402017d0 <nand_init+0xa8>
402017c4:	ebfffdc2 	bl	40200ed4 <get_mem_type>
402017c8:	e3500005 	cmp	r0, #5
402017cc:	1a000017 	bne	40201830 <nand_init+0x108>
        	__raw_writel( ONENAND_GPMC_CONFIG1, GPMC_CONFIG1 + GPMC_CONFIG_CS0);
402017d0:	e3a0346e 	mov	r3, #1845493760	; 0x6e000000
402017d4:	e3a02c12 	mov	r2, #4608	; 0x1200
402017d8:	e5832060 	str	r2, [r3, #96]	; 0x60

        	/* Enable the GPMC Mapping */
        	__raw_writel(( ((OMAP34XX_GPMC_CS0_SIZE & 0xF)<<8) |
        		     ((ONENAND_BASE>>24) & 0x3F) |
        		     (1<<6) ),  (GPMC_CONFIG7 + GPMC_CONFIG_CS0));
        	delay(2000);
402017dc:	e3a00e7d 	mov	r0, #2000	; 0x7d0

	}

	if ((get_mem_type() == GPMC_ONENAND) || (get_mem_type() == MMC_ONENAND)){
        	__raw_writel( ONENAND_GPMC_CONFIG1, GPMC_CONFIG1 + GPMC_CONFIG_CS0);
        	__raw_writel( ONENAND_GPMC_CONFIG2, GPMC_CONFIG2 + GPMC_CONFIG_CS0);
402017e0:	e59f2064 	ldr	r2, [pc, #100]	; 4020184c <nand_init+0x124>
402017e4:	e5832064 	str	r2, [r3, #100]	; 0x64
        	__raw_writel( ONENAND_GPMC_CONFIG3, GPMC_CONFIG3 + GPMC_CONFIG_CS0);
402017e8:	e59f2060 	ldr	r2, [pc, #96]	; 40201850 <nand_init+0x128>
402017ec:	e5832068 	str	r2, [r3, #104]	; 0x68
        	__raw_writel( ONENAND_GPMC_CONFIG4, GPMC_CONFIG4 + GPMC_CONFIG_CS0);
402017f0:	e59f205c 	ldr	r2, [pc, #92]	; 40201854 <nand_init+0x12c>
402017f4:	e583206c 	str	r2, [r3, #108]	; 0x6c
        	__raw_writel( ONENAND_GPMC_CONFIG5, GPMC_CONFIG5 + GPMC_CONFIG_CS0);
402017f8:	e59f2058 	ldr	r2, [pc, #88]	; 40201858 <nand_init+0x130>
402017fc:	e5832070 	str	r2, [r3, #112]	; 0x70
        	__raw_writel( ONENAND_GPMC_CONFIG6, GPMC_CONFIG6 + GPMC_CONFIG_CS0);
40201800:	e59f2054 	ldr	r2, [pc, #84]	; 4020185c <nand_init+0x134>
40201804:	e5832074 	str	r2, [r3, #116]	; 0x74

        	/* Enable the GPMC Mapping */
        	__raw_writel(( ((OMAP34XX_GPMC_CS0_SIZE & 0xF)<<8) |
40201808:	e3a02e86 	mov	r2, #2144	; 0x860
4020180c:	e5832078 	str	r2, [r3, #120]	; 0x78
        		     ((ONENAND_BASE>>24) & 0x3F) |
        		     (1<<6) ),  (GPMC_CONFIG7 + GPMC_CONFIG_CS0));
        	delay(2000);
40201810:	ebfffd9f 	bl	40200e94 <delay>

        	if (onenand_chip()){
40201814:	eb000a84 	bl	4020422c <onenand_chip>
40201818:	e3500000 	cmp	r0, #0
4020181c:	0a000003 	beq	40201830 <nand_init+0x108>
#ifdef CFG_PRINTF
        		printf("OneNAND Unsupported !\n");
40201820:	e59f0038 	ldr	r0, [pc, #56]	; 40201860 <nand_init+0x138>
40201824:	eb000558 	bl	40202d8c <serial_printf>
40201828:	e3a00001 	mov	r0, #1
#endif
        		return 1;
4020182c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
40201830:	e3a00000 	mov	r0, #0
        	}
	}
	return 0;
}
40201834:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
40201838:	00141400 	.word	0x00141400
4020183c:	0f010f01 	.word	0x0f010f01
40201840:	010c1414 	.word	0x010c1414
40201844:	1f0f0a80 	.word	0x1f0f0a80
40201848:	40204aee 	.word	0x40204aee
4020184c:	000f0f01 	.word	0x000f0f01
40201850:	00030301 	.word	0x00030301
40201854:	0f040f04 	.word	0x0f040f04
40201858:	010f1010 	.word	0x010f1010
4020185c:	1f060000 	.word	0x1f060000
40201860:	40204b01 	.word	0x40204b01

40201864 <prcm_init>:
/******************************************************************************
 * prcm_init() - inits clocks for PRCM as defined in clocks.h
 *   -- called from SRAM, or Flash (using temp SRAM stack).
 *****************************************************************************/
void prcm_init(void)
{
40201864:	e92d46f1 	push	{r0, r4, r5, r6, r7, r9, sl, lr}
	u32 clk_index, sil_index;

	/* Gauge the input clock speed and find out the sys_clkin_sel
	 * value corresponding to the input clock.
	 */
	osc_clk = get_osc_clk_speed();
40201868:	ebfffe2e 	bl	40201128 <get_osc_clk_speed>
	get_sys_clkin_sel(osc_clk, &sys_clkin_sel);
4020186c:	e1a0100d 	mov	r1, sp
40201870:	ebfffe74 	bl	40201248 <get_sys_clkin_sel>

	sr32(PRM_CLKSEL, 0, 3, sys_clkin_sel); /* set input crystal speed */
40201874:	e59f07a8 	ldr	r0, [pc, #1960]	; 40202024 <prcm_init+0x7c0>
40201878:	e3a01000 	mov	r1, #0
4020187c:	e3a02003 	mov	r2, #3
40201880:	e59d3000 	ldr	r3, [sp]
40201884:	ebfffdbe 	bl	40200f84 <sr32>
	 * On OMAP3630, DDR data corruption has been observed on OFF mode
	 * exit if the sys clock was lower than 26M. As a work around,
	 * OMAP3630 is operated at 26M sys clock and this internal division
	 * is not performed.
	 */
	if((is_cpu_family() != CPU_OMAP36XX) && (sys_clkin_sel > 2)) {
40201888:	ebfffd9e 	bl	40200f08 <is_cpu_family>
4020188c:	e3500c36 	cmp	r0, #13824	; 0x3600
40201890:	0a00000a 	beq	402018c0 <prcm_init+0x5c>
40201894:	e59d3000 	ldr	r3, [sp]
40201898:	e3530002 	cmp	r3, #2
4020189c:	9a000007 	bls	402018c0 <prcm_init+0x5c>
		sr32(PRM_CLKSRC_CTRL, 6, 2, 2);/* input clock divider */
402018a0:	e3a02002 	mov	r2, #2
402018a4:	e59f077c 	ldr	r0, [pc, #1916]	; 40202028 <prcm_init+0x7c4>
402018a8:	e3a01006 	mov	r1, #6
402018ac:	e1a03002 	mov	r3, r2
402018b0:	ebfffdb3 	bl	40200f84 <sr32>
		clk_index = sys_clkin_sel/2;
402018b4:	e59d4000 	ldr	r4, [sp]
402018b8:	e1a040a4 	lsr	r4, r4, #1
	 * On OMAP3630, DDR data corruption has been observed on OFF mode
	 * exit if the sys clock was lower than 26M. As a work around,
	 * OMAP3630 is operated at 26M sys clock and this internal division
	 * is not performed.
	 */
	if((is_cpu_family() != CPU_OMAP36XX) && (sys_clkin_sel > 2)) {
402018bc:	ea000005 	b	402018d8 <prcm_init+0x74>
		sr32(PRM_CLKSRC_CTRL, 6, 2, 2);/* input clock divider */
		clk_index = sys_clkin_sel/2;
	} else {
		sr32(PRM_CLKSRC_CTRL, 6, 2, 1);/* input clock divider */
402018c0:	e59f0760 	ldr	r0, [pc, #1888]	; 40202028 <prcm_init+0x7c4>
402018c4:	e3a01006 	mov	r1, #6
402018c8:	e3a02002 	mov	r2, #2
402018cc:	e3a03001 	mov	r3, #1
402018d0:	ebfffdab 	bl	40200f84 <sr32>
		clk_index = sys_clkin_sel;
402018d4:	e59d4000 	ldr	r4, [sp]
	}

	if (is_cpu_family() == CPU_OMAP36XX) {
402018d8:	ebfffd8a 	bl	40200f08 <is_cpu_family>
402018dc:	e1a09204 	lsl	r9, r4, #4
402018e0:	e3500c36 	cmp	r0, #13824	; 0x3600
402018e4:	1a0000d3 	bne	40201c38 <prcm_init+0x3d4>
static void dpll3_init_36xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address of Core DPLL param table*/
	ptr = (dpll_param *)get_36x_core_dpll_param();
402018e8:	ebfffd65 	bl	40200e84 <get_36x_core_dpll_param>
	/* Moving it to the right sysclk and ES rev base */
	ptr += clk_index;

	/* CORE DPLL */
	/* Select relock bypass: CM_CLKEN_PLL[0:2] */
	sr32(CM_CLKEN_PLL, 0, 3, PLL_FAST_RELOCK_BYPASS);
402018ec:	e3a01000 	mov	r1, #0
402018f0:	e3a02003 	mov	r2, #3
402018f4:	e3a03006 	mov	r3, #6

	/* Getting the base address to MPU DPLL param table*/
	ptr = (dpll_param *)get_36x_mpu_dpll_param();

	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + (2*clk_index) + sil_index;
402018f8:	e1a07284 	lsl	r7, r4, #5

	/* Getting the base address of Core DPLL param table*/
	ptr = (dpll_param *)get_36x_core_dpll_param();

	/* Moving it to the right sysclk and ES rev base */
	ptr += clk_index;
402018fc:	e0809009 	add	r9, r0, r9
static void dpll3_init_36xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address of Core DPLL param table*/
	ptr = (dpll_param *)get_36x_core_dpll_param();
40201900:	e1a05000 	mov	r5, r0
	/* Moving it to the right sysclk and ES rev base */
	ptr += clk_index;

	/* CORE DPLL */
	/* Select relock bypass: CM_CLKEN_PLL[0:2] */
	sr32(CM_CLKEN_PLL, 0, 3, PLL_FAST_RELOCK_BYPASS);
40201904:	e59f0720 	ldr	r0, [pc, #1824]	; 4020202c <prcm_init+0x7c8>
40201908:	ebfffd9d 	bl	40200f84 <sr32>
	wait_on_value(BIT0, 0, CM_IDLEST_CKGEN, LDELAY);
4020190c:	e3a01000 	mov	r1, #0
40201910:	e59f2718 	ldr	r2, [pc, #1816]	; 40202030 <prcm_init+0x7cc>
40201914:	e3a00001 	mov	r0, #1
40201918:	e59f3714 	ldr	r3, [pc, #1812]	; 40202034 <prcm_init+0x7d0>
4020191c:	ebfffda0 	bl	40200fa4 <wait_on_value>

	/* CM_CLKSEL1_EMU[DIV_DPLL3] */
	sr32(CM_CLKSEL1_EMU, 16, 5, CORE_M3X2);
40201920:	e59f0710 	ldr	r0, [pc, #1808]	; 40202038 <prcm_init+0x7d4>
40201924:	e3a01010 	mov	r1, #16
40201928:	e3a02005 	mov	r2, #5
4020192c:	e3a03002 	mov	r3, #2
40201930:	ebfffd93 	bl	40200f84 <sr32>

	/* M2 (CORE_DPLL_CLKOUT_DIV): CM_CLKSEL1_PLL[27:31] */
	sr32(CM_CLKSEL1_PLL, 27, 5, ptr->m2);
40201934:	e59f0700 	ldr	r0, [pc, #1792]	; 4020203c <prcm_init+0x7d8>
40201938:	e3a0101b 	mov	r1, #27
4020193c:	e3a02005 	mov	r2, #5
40201940:	e599300c 	ldr	r3, [r9, #12]
40201944:	ebfffd8e 	bl	40200f84 <sr32>

	/* M (CORE_DPLL_MULT): CM_CLKSEL1_PLL[16:26] */
	sr32(CM_CLKSEL1_PLL, 16, 11, ptr->m);
40201948:	e7953204 	ldr	r3, [r5, r4, lsl #4]
4020194c:	e59f06e8 	ldr	r0, [pc, #1768]	; 4020203c <prcm_init+0x7d8>
40201950:	e3a01010 	mov	r1, #16
40201954:	e3a0200b 	mov	r2, #11
	struct dpll_per_36x_param *ptr;

	ptr = (struct dpll_per_36x_param *)get_36x_per_dpll_param();

	/* Moving it to the right sysclk base */
	ptr += clk_index;
40201958:	e3a05024 	mov	r5, #36	; 0x24

	/* M2 (CORE_DPLL_CLKOUT_DIV): CM_CLKSEL1_PLL[27:31] */
	sr32(CM_CLKSEL1_PLL, 27, 5, ptr->m2);

	/* M (CORE_DPLL_MULT): CM_CLKSEL1_PLL[16:26] */
	sr32(CM_CLKSEL1_PLL, 16, 11, ptr->m);
4020195c:	ebfffd88 	bl	40200f84 <sr32>

	/* N (CORE_DPLL_DIV): CM_CLKSEL1_PLL[8:14] */
	sr32(CM_CLKSEL1_PLL, 8, 7, ptr->n);
40201960:	e59f06d4 	ldr	r0, [pc, #1748]	; 4020203c <prcm_init+0x7d8>
40201964:	e3a01008 	mov	r1, #8
40201968:	e3a02007 	mov	r2, #7
4020196c:	e5993004 	ldr	r3, [r9, #4]
40201970:	ebfffd83 	bl	40200f84 <sr32>

	/* Source is the CM_96M_FCLK: CM_CLKSEL1_PLL[6] */
	sr32(CM_CLKSEL1_PLL, 6, 1, 0);
40201974:	e59f06c0 	ldr	r0, [pc, #1728]	; 4020203c <prcm_init+0x7d8>
40201978:	e3a01006 	mov	r1, #6
4020197c:	e3a02001 	mov	r2, #1
40201980:	e3a03000 	mov	r3, #0
40201984:	ebfffd7e 	bl	40200f84 <sr32>

	sr32(CM_CLKSEL_CORE, 8, 4, CORE_SSI_DIV);	/* ssi */
40201988:	e59f06b0 	ldr	r0, [pc, #1712]	; 40202040 <prcm_init+0x7dc>
4020198c:	e3a01008 	mov	r1, #8
40201990:	e3a02004 	mov	r2, #4
40201994:	e3a03003 	mov	r3, #3
40201998:	ebfffd79 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_CORE, 4, 2, CORE_FUSB_DIV);	/* fsusb */
4020199c:	e3a02002 	mov	r2, #2
402019a0:	e1a03002 	mov	r3, r2
402019a4:	e59f0694 	ldr	r0, [pc, #1684]	; 40202040 <prcm_init+0x7dc>
402019a8:	e3a01004 	mov	r1, #4
402019ac:	ebfffd74 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_CORE, 2, 2, CORE_L4_DIV);	/* l4 */
402019b0:	e3a01002 	mov	r1, #2
402019b4:	e1a02001 	mov	r2, r1
402019b8:	e1a03001 	mov	r3, r1
402019bc:	e59f067c 	ldr	r0, [pc, #1660]	; 40202040 <prcm_init+0x7dc>
402019c0:	ebfffd6f 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_CORE, 0, 2, CORE_L3_DIV);	/* l3 */
402019c4:	e3a02002 	mov	r2, #2
402019c8:	e1a03002 	mov	r3, r2
402019cc:	e59f066c 	ldr	r0, [pc, #1644]	; 40202040 <prcm_init+0x7dc>
402019d0:	e3a01000 	mov	r1, #0
402019d4:	ebfffd6a 	bl	40200f84 <sr32>

	sr32(CM_CLKSEL_GFX,  0, 3, GFX_DIV_36X);		/* gfx */
402019d8:	e59f0664 	ldr	r0, [pc, #1636]	; 40202044 <prcm_init+0x7e0>
402019dc:	e3a01000 	mov	r1, #0
402019e0:	e3a02003 	mov	r2, #3
402019e4:	e3a03005 	mov	r3, #5
402019e8:	ebfffd65 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_WKUP, 1, 2, WKUP_RSM);		/* reset mgr */
402019ec:	e3a02002 	mov	r2, #2
402019f0:	e1a03002 	mov	r3, r2
402019f4:	e59f064c 	ldr	r0, [pc, #1612]	; 40202048 <prcm_init+0x7e4>
402019f8:	e3a01001 	mov	r1, #1
402019fc:	ebfffd60 	bl	40200f84 <sr32>

	/* FREQSEL (CORE_DPLL_FREQSEL): CM_CLKEN_PLL[4:7] */
	sr32(CM_CLKEN_PLL,   4, 4, ptr->fsel);
40201a00:	e3a01004 	mov	r1, #4
40201a04:	e1a02001 	mov	r2, r1
40201a08:	e59f061c 	ldr	r0, [pc, #1564]	; 4020202c <prcm_init+0x7c8>
40201a0c:	e5993008 	ldr	r3, [r9, #8]
40201a10:	ebfffd5b 	bl	40200f84 <sr32>
	sr32(CM_CLKEN_PLL,   0, 3, PLL_LOCK);		/* lock mode */
40201a14:	e59f0610 	ldr	r0, [pc, #1552]	; 4020202c <prcm_init+0x7c8>
40201a18:	e3a01000 	mov	r1, #0
40201a1c:	e3a02003 	mov	r2, #3
40201a20:	e3a03007 	mov	r3, #7
40201a24:	ebfffd56 	bl	40200f84 <sr32>

	wait_on_value(BIT0, 1, CM_IDLEST_CKGEN, LDELAY);
40201a28:	e3a00001 	mov	r0, #1
40201a2c:	e1a01000 	mov	r1, r0
40201a30:	e59f25f8 	ldr	r2, [pc, #1528]	; 40202030 <prcm_init+0x7cc>
40201a34:	e59f35f8 	ldr	r3, [pc, #1528]	; 40202034 <prcm_init+0x7d0>
40201a38:	ebfffd59 	bl	40200fa4 <wait_on_value>

static void dpll4_init_36xx(u32 sil_index, u32 clk_index)
{
	struct dpll_per_36x_param *ptr;

	ptr = (struct dpll_per_36x_param *)get_36x_per_dpll_param();
40201a3c:	ebfffd12 	bl	40200e8c <get_36x_per_dpll_param>

	/* Moving it to the right sysclk base */
	ptr += clk_index;

	/* EN_PERIPH_DPLL: CM_CLKEN_PLL[16:18] */
	sr32(CM_CLKEN_PLL, 16, 3, PLL_STOP);
40201a40:	e3a01010 	mov	r1, #16
40201a44:	e3a02003 	mov	r2, #3
40201a48:	e3a03001 	mov	r3, #1
	struct dpll_per_36x_param *ptr;

	ptr = (struct dpll_per_36x_param *)get_36x_per_dpll_param();

	/* Moving it to the right sysclk base */
	ptr += clk_index;
40201a4c:	e0250495 	mla	r5, r5, r4, r0

	/* EN_PERIPH_DPLL: CM_CLKEN_PLL[16:18] */
	sr32(CM_CLKEN_PLL, 16, 3, PLL_STOP);
40201a50:	e59f05d4 	ldr	r0, [pc, #1492]	; 4020202c <prcm_init+0x7c8>
40201a54:	ebfffd4a 	bl	40200f84 <sr32>
	wait_on_value(BIT1, 0, CM_IDLEST_CKGEN, LDELAY);
40201a58:	e3a01000 	mov	r1, #0
40201a5c:	e59f25cc 	ldr	r2, [pc, #1484]	; 40202030 <prcm_init+0x7cc>
40201a60:	e3a00002 	mov	r0, #2
40201a64:	e59f35c8 	ldr	r3, [pc, #1480]	; 40202034 <prcm_init+0x7d0>
40201a68:	ebfffd4d 	bl	40200fa4 <wait_on_value>

	/* M6 (DIV_DPLL4): CM_CLKSEL1_EMU[24:29] */
	sr32(CM_CLKSEL1_EMU, 24, 6, ptr->m6);
40201a6c:	e59f05c4 	ldr	r0, [pc, #1476]	; 40202038 <prcm_init+0x7d4>
40201a70:	e595301c 	ldr	r3, [r5, #28]
40201a74:	e3a01018 	mov	r1, #24
40201a78:	e3a02006 	mov	r2, #6
40201a7c:	ebfffd40 	bl	40200f84 <sr32>

	/* M5 (CLKSEL_CAM): CM_CLKSEL1_EMU[0:5] */
	sr32(CM_CLKSEL_CAM, 0, 6, ptr->m5);
40201a80:	e5953018 	ldr	r3, [r5, #24]
40201a84:	e59f05c0 	ldr	r0, [pc, #1472]	; 4020204c <prcm_init+0x7e8>
40201a88:	e3a01000 	mov	r1, #0
40201a8c:	e3a02006 	mov	r2, #6
40201a90:	ebfffd3b 	bl	40200f84 <sr32>

	/* M4 (CLKSEL_DSS1): CM_CLKSEL_DSS[0:5] */
	sr32(CM_CLKSEL_DSS, 0, 6, ptr->m4);
40201a94:	e5953014 	ldr	r3, [r5, #20]
40201a98:	e59f05b0 	ldr	r0, [pc, #1456]	; 40202050 <prcm_init+0x7ec>
40201a9c:	e3a01000 	mov	r1, #0
40201aa0:	e3a02006 	mov	r2, #6
40201aa4:	ebfffd36 	bl	40200f84 <sr32>

	/* M3 (CLKSEL_DSS1): CM_CLKSEL_DSS[8:13] */
	sr32(CM_CLKSEL_DSS, 8, 6, ptr->m3);
40201aa8:	e5953010 	ldr	r3, [r5, #16]
40201aac:	e59f059c 	ldr	r0, [pc, #1436]	; 40202050 <prcm_init+0x7ec>
40201ab0:	e3a01008 	mov	r1, #8
40201ab4:	e3a02006 	mov	r2, #6
40201ab8:	ebfffd31 	bl	40200f84 <sr32>

	/* M2 (DIV_96M): CM_CLKSEL3_PLL[0:4] */
	sr32(CM_CLKSEL3_PLL, 0, 5, ptr->m2);
40201abc:	e595300c 	ldr	r3, [r5, #12]
40201ac0:	e59f058c 	ldr	r0, [pc, #1420]	; 40202054 <prcm_init+0x7f0>
40201ac4:	e3a01000 	mov	r1, #0
40201ac8:	e3a02005 	mov	r2, #5
40201acc:	ebfffd2c 	bl	40200f84 <sr32>

	/* M (PERIPH_DPLL_MULT): CM_CLKSEL2_PLL[8:19] */
	sr32(CM_CLKSEL2_PLL, 8, 12, ptr->m);
40201ad0:	e5953004 	ldr	r3, [r5, #4]
40201ad4:	e59f057c 	ldr	r0, [pc, #1404]	; 40202058 <prcm_init+0x7f4>
40201ad8:	e3a01008 	mov	r1, #8
40201adc:	e3a0200c 	mov	r2, #12
40201ae0:	ebfffd27 	bl	40200f84 <sr32>

	/* N (PERIPH_DPLL_DIV): CM_CLKSEL2_PLL[0:6] */
	sr32(CM_CLKSEL2_PLL, 0, 7, ptr->n);
40201ae4:	e5953008 	ldr	r3, [r5, #8]
40201ae8:	e59f0568 	ldr	r0, [pc, #1384]	; 40202058 <prcm_init+0x7f4>
40201aec:	e3a01000 	mov	r1, #0
40201af0:	e3a02007 	mov	r2, #7
40201af4:	ebfffd22 	bl	40200f84 <sr32>

	/* M2DIV (CLKSEL_96M): CM_CLKSEL_CORE[12:13] */
	sr32(CM_CLKSEL_CORE, 12, 2, ptr->m2div);
40201af8:	e5953020 	ldr	r3, [r5, #32]
40201afc:	e59f053c 	ldr	r0, [pc, #1340]	; 40202040 <prcm_init+0x7dc>
40201b00:	e3a0100c 	mov	r1, #12
40201b04:	e3a02002 	mov	r2, #2
40201b08:	ebfffd1d 	bl	40200f84 <sr32>

	/* LOCK MODE (EN_PERIPH_DPLL): CM_CLKEN_PLL[16:18] */
	sr32(CM_CLKEN_PLL, 16, 3, PLL_LOCK);
40201b0c:	e59f0518 	ldr	r0, [pc, #1304]	; 4020202c <prcm_init+0x7c8>
40201b10:	e3a01010 	mov	r1, #16
40201b14:	e3a02003 	mov	r2, #3
40201b18:	e3a03007 	mov	r3, #7
40201b1c:	ebfffd18 	bl	40200f84 <sr32>
	wait_on_value(BIT1, 2, CM_IDLEST_CKGEN, LDELAY);
40201b20:	e3a00002 	mov	r0, #2
40201b24:	e1a01000 	mov	r1, r0
40201b28:	e59f2500 	ldr	r2, [pc, #1280]	; 40202030 <prcm_init+0x7cc>
40201b2c:	e59f3500 	ldr	r3, [pc, #1280]	; 40202034 <prcm_init+0x7d0>
40201b30:	ebfffd1b 	bl	40200fa4 <wait_on_value>
static void mpu_init_36xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address to MPU DPLL param table*/
	ptr = (dpll_param *)get_36x_mpu_dpll_param();
40201b34:	ebfffcce 	bl	40200e74 <get_36x_mpu_dpll_param>
	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + (2*clk_index) + sil_index;

	/* MPU DPLL (unlocked already) */
	/* M2 (MPU_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_MPU[0:4] */
	sr32(CM_CLKSEL2_PLL_MPU, 0, 5, ptr->m2);
40201b38:	e3a01000 	mov	r1, #0
40201b3c:	e3a02005 	mov	r2, #5

	/* Getting the base address to MPU DPLL param table*/
	ptr = (dpll_param *)get_36x_mpu_dpll_param();

	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + (2*clk_index) + sil_index;
40201b40:	e0805007 	add	r5, r0, r7
static void mpu_init_36xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address to MPU DPLL param table*/
	ptr = (dpll_param *)get_36x_mpu_dpll_param();
40201b44:	e1a06000 	mov	r6, r0
	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + (2*clk_index) + sil_index;

	/* MPU DPLL (unlocked already) */
	/* M2 (MPU_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_MPU[0:4] */
	sr32(CM_CLKSEL2_PLL_MPU, 0, 5, ptr->m2);
40201b48:	e59f050c 	ldr	r0, [pc, #1292]	; 4020205c <prcm_init+0x7f8>
40201b4c:	e595300c 	ldr	r3, [r5, #12]
40201b50:	ebfffd0b 	bl	40200f84 <sr32>

	/* M (MPU_DPLL_MULT) : CM_CLKSEL2_PLL_MPU[8:18] */
	sr32(CM_CLKSEL1_PLL_MPU, 8, 11, ptr->m);
40201b54:	e59f0504 	ldr	r0, [pc, #1284]	; 40202060 <prcm_init+0x7fc>
40201b58:	e3a01008 	mov	r1, #8
40201b5c:	e3a0200b 	mov	r2, #11
40201b60:	e7963284 	ldr	r3, [r6, r4, lsl #5]
40201b64:	ebfffd06 	bl	40200f84 <sr32>

	/* N (MPU_DPLL_DIV) : CM_CLKSEL2_PLL_MPU[0:6] */
	sr32(CM_CLKSEL1_PLL_MPU, 0, 7, ptr->n);
40201b68:	e5953004 	ldr	r3, [r5, #4]
40201b6c:	e59f04ec 	ldr	r0, [pc, #1260]	; 40202060 <prcm_init+0x7fc>
40201b70:	e3a01000 	mov	r1, #0
40201b74:	e3a02007 	mov	r2, #7
40201b78:	ebfffd01 	bl	40200f84 <sr32>

	/* LOCK MODE (EN_MPU_DPLL) : CM_CLKEN_PLL_IVA2[0:2] */
	sr32(CM_CLKEN_PLL_MPU, 0, 3, PLL_LOCK);
40201b7c:	e59f04e0 	ldr	r0, [pc, #1248]	; 40202064 <prcm_init+0x800>
40201b80:	e3a01000 	mov	r1, #0
40201b84:	e3a02003 	mov	r2, #3
40201b88:	e3a03007 	mov	r3, #7
40201b8c:	ebfffcfc 	bl	40200f84 <sr32>
	wait_on_value(BIT0, 1, CM_IDLEST_PLL_MPU, LDELAY);
40201b90:	e3a00001 	mov	r0, #1
40201b94:	e1a01000 	mov	r1, r0
40201b98:	e59f24c8 	ldr	r2, [pc, #1224]	; 40202068 <prcm_init+0x804>
40201b9c:	e59f3490 	ldr	r3, [pc, #1168]	; 40202034 <prcm_init+0x7d0>
40201ba0:	ebfffcff 	bl	40200fa4 <wait_on_value>
static void iva_init_36xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address to IVA DPLL param table*/
	ptr = (dpll_param *)get_36x_iva_dpll_param();
40201ba4:	ebfffcb4 	bl	40200e7c <get_36x_iva_dpll_param>
	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + (2*clk_index) + sil_index;

	/* IVA DPLL */
	/* EN_IVA2_DPLL : CM_CLKEN_PLL_IVA2[0:2] */
	sr32(CM_CLKEN_PLL_IVA2, 0, 3, PLL_STOP);
40201ba8:	e3a01000 	mov	r1, #0
40201bac:	e3a02003 	mov	r2, #3
40201bb0:	e3a03001 	mov	r3, #1

	/* Getting the base address to IVA DPLL param table*/
	ptr = (dpll_param *)get_36x_iva_dpll_param();

	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + (2*clk_index) + sil_index;
40201bb4:	e0807007 	add	r7, r0, r7
static void iva_init_36xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address to IVA DPLL param table*/
	ptr = (dpll_param *)get_36x_iva_dpll_param();
40201bb8:	e1a05000 	mov	r5, r0
	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + (2*clk_index) + sil_index;

	/* IVA DPLL */
	/* EN_IVA2_DPLL : CM_CLKEN_PLL_IVA2[0:2] */
	sr32(CM_CLKEN_PLL_IVA2, 0, 3, PLL_STOP);
40201bbc:	e59f04a8 	ldr	r0, [pc, #1192]	; 4020206c <prcm_init+0x808>
40201bc0:	ebfffcef 	bl	40200f84 <sr32>
	wait_on_value(BIT0, 0, CM_IDLEST_PLL_IVA2, LDELAY);
40201bc4:	e3a01000 	mov	r1, #0
40201bc8:	e59f24a0 	ldr	r2, [pc, #1184]	; 40202070 <prcm_init+0x80c>
40201bcc:	e3a00001 	mov	r0, #1
40201bd0:	e59f345c 	ldr	r3, [pc, #1116]	; 40202034 <prcm_init+0x7d0>
40201bd4:	ebfffcf2 	bl	40200fa4 <wait_on_value>

	/* M2 (IVA2_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_IVA2[0:4] */
	sr32(CM_CLKSEL2_PLL_IVA2, 0, 5, ptr->m2);
40201bd8:	e59f0494 	ldr	r0, [pc, #1172]	; 40202074 <prcm_init+0x810>
40201bdc:	e3a01000 	mov	r1, #0
40201be0:	e3a02005 	mov	r2, #5
40201be4:	e597300c 	ldr	r3, [r7, #12]
40201be8:	ebfffce5 	bl	40200f84 <sr32>

	/* M (IVA2_DPLL_MULT) : CM_CLKSEL1_PLL_IVA2[8:18] */
	sr32(CM_CLKSEL1_PLL_IVA2, 8, 11, ptr->m);
40201bec:	e59f0484 	ldr	r0, [pc, #1156]	; 40202078 <prcm_init+0x814>
40201bf0:	e3a01008 	mov	r1, #8
40201bf4:	e3a0200b 	mov	r2, #11
40201bf8:	e7953284 	ldr	r3, [r5, r4, lsl #5]
40201bfc:	ebfffce0 	bl	40200f84 <sr32>

	/* N (IVA2_DPLL_DIV) : CM_CLKSEL1_PLL_IVA2[0:6] */
	sr32(CM_CLKSEL1_PLL_IVA2, 0, 7, ptr->n);
40201c00:	e59f0470 	ldr	r0, [pc, #1136]	; 40202078 <prcm_init+0x814>
40201c04:	e3a01000 	mov	r1, #0
40201c08:	e3a02007 	mov	r2, #7
40201c0c:	e5973004 	ldr	r3, [r7, #4]
40201c10:	ebfffcdb 	bl	40200f84 <sr32>

	/* LOCK MODE (EN_IVA2_DPLL) : CM_CLKEN_PLL_IVA2[0:2] */
	sr32(CM_CLKEN_PLL_IVA2, 0, 3, PLL_LOCK);
40201c14:	e59f0450 	ldr	r0, [pc, #1104]	; 4020206c <prcm_init+0x808>
40201c18:	e3a01000 	mov	r1, #0
40201c1c:	e3a02003 	mov	r2, #3
40201c20:	e3a03007 	mov	r3, #7
40201c24:	ebfffcd6 	bl	40200f84 <sr32>

	wait_on_value(BIT0, 1, CM_IDLEST_PLL_IVA2, LDELAY);
40201c28:	e3a00001 	mov	r0, #1
40201c2c:	e1a01000 	mov	r1, r0
40201c30:	e59f2438 	ldr	r2, [pc, #1080]	; 40202070 <prcm_init+0x80c>
40201c34:	ea0000eb 	b	40201fe8 <prcm_init+0x784>
		dpll3_init_36xx(0, clk_index);
		dpll4_init_36xx(0, clk_index);
		mpu_init_36xx(0, clk_index);
		iva_init_36xx(0, clk_index);
	} else {
		sil_index = get_cpu_rev() - 1;
40201c38:	ebfffcad 	bl	40200ef4 <get_cpu_rev>
		 * and sil_index will get the values for that SysClk for the
		 * appropriate silicon rev.
		 */

		/* Unlock MPU DPLL (slows things down, and needed later) */
		sr32(CM_CLKEN_PLL_MPU, 0, 3, PLL_LOW_POWER_BYPASS);
40201c3c:	e3a01000 	mov	r1, #0
40201c40:	e3a02003 	mov	r2, #3
40201c44:	e3a03005 	mov	r3, #5

	/* Getting the base address of Core DPLL param table*/
	ptr = (dpll_param *)get_core_dpll_param();

	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + 2*clk_index + sil_index;
40201c48:	e1a05084 	lsl	r5, r4, #1
40201c4c:	e2455001 	sub	r5, r5, #1
		dpll3_init_36xx(0, clk_index);
		dpll4_init_36xx(0, clk_index);
		mpu_init_36xx(0, clk_index);
		iva_init_36xx(0, clk_index);
	} else {
		sil_index = get_cpu_rev() - 1;
40201c50:	e1a06000 	mov	r6, r0
		 * and sil_index will get the values for that SysClk for the
		 * appropriate silicon rev.
		 */

		/* Unlock MPU DPLL (slows things down, and needed later) */
		sr32(CM_CLKEN_PLL_MPU, 0, 3, PLL_LOW_POWER_BYPASS);
40201c54:	e59f0408 	ldr	r0, [pc, #1032]	; 40202064 <prcm_init+0x800>
40201c58:	ebfffcc9 	bl	40200f84 <sr32>
		wait_on_value(BIT0, 0, CM_IDLEST_PLL_MPU, LDELAY);
40201c5c:	e3a01000 	mov	r1, #0
40201c60:	e59f2400 	ldr	r2, [pc, #1024]	; 40202068 <prcm_init+0x804>
40201c64:	e3a00001 	mov	r0, #1
40201c68:	e59f33c4 	ldr	r3, [pc, #964]	; 40202034 <prcm_init+0x7d0>

	/* Getting the base address of Core DPLL param table*/
	ptr = (dpll_param *)get_core_dpll_param();

	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + 2*clk_index + sil_index;
40201c6c:	e0855006 	add	r5, r5, r6
		 * appropriate silicon rev.
		 */

		/* Unlock MPU DPLL (slows things down, and needed later) */
		sr32(CM_CLKEN_PLL_MPU, 0, 3, PLL_LOW_POWER_BYPASS);
		wait_on_value(BIT0, 0, CM_IDLEST_PLL_MPU, LDELAY);
40201c70:	ebfffccb 	bl	40200fa4 <wait_on_value>
static void dpll3_init_34xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address of Core DPLL param table*/
	ptr = (dpll_param *)get_core_dpll_param();
40201c74:	ebfffc12 	bl	40200cc4 <get_core_dpll_param>

	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + 2*clk_index + sil_index;
40201c78:	e1a0a205 	lsl	sl, r5, #4

	/* CORE DPLL */
	/* Select relock bypass: CM_CLKEN_PLL[0:2] */
	sr32(CM_CLKEN_PLL, 0, 3, PLL_FAST_RELOCK_BYPASS);
40201c7c:	e3a01000 	mov	r1, #0
40201c80:	e3a02003 	mov	r2, #3
40201c84:	e3a03006 	mov	r3, #6

	/* Getting the base address of Core DPLL param table*/
	ptr = (dpll_param *)get_core_dpll_param();

	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + 2*clk_index + sil_index;
40201c88:	e080600a 	add	r6, r0, sl
static void dpll3_init_34xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address of Core DPLL param table*/
	ptr = (dpll_param *)get_core_dpll_param();
40201c8c:	e1a07000 	mov	r7, r0
	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + 2*clk_index + sil_index;

	/* CORE DPLL */
	/* Select relock bypass: CM_CLKEN_PLL[0:2] */
	sr32(CM_CLKEN_PLL, 0, 3, PLL_FAST_RELOCK_BYPASS);
40201c90:	e59f0394 	ldr	r0, [pc, #916]	; 4020202c <prcm_init+0x7c8>
40201c94:	ebfffcba 	bl	40200f84 <sr32>
	wait_on_value(BIT0, 0, CM_IDLEST_CKGEN, LDELAY);
40201c98:	e3a01000 	mov	r1, #0
40201c9c:	e59f238c 	ldr	r2, [pc, #908]	; 40202030 <prcm_init+0x7cc>
40201ca0:	e3a00001 	mov	r0, #1
40201ca4:	e59f3388 	ldr	r3, [pc, #904]	; 40202034 <prcm_init+0x7d0>
40201ca8:	ebfffcbd 	bl	40200fa4 <wait_on_value>

	/* CM_CLKSEL1_EMU[DIV_DPLL3] */
	sr32(CM_CLKSEL1_EMU, 16, 5, CORE_M3X2);
40201cac:	e59f0384 	ldr	r0, [pc, #900]	; 40202038 <prcm_init+0x7d4>
40201cb0:	e3a01010 	mov	r1, #16
40201cb4:	e3a02005 	mov	r2, #5
40201cb8:	e3a03002 	mov	r3, #2
40201cbc:	ebfffcb0 	bl	40200f84 <sr32>

	/* M2 (CORE_DPLL_CLKOUT_DIV): CM_CLKSEL1_PLL[27:31] */
	sr32(CM_CLKSEL1_PLL, 27, 5, ptr->m2);
40201cc0:	e596300c 	ldr	r3, [r6, #12]
40201cc4:	e59f0370 	ldr	r0, [pc, #880]	; 4020203c <prcm_init+0x7d8>
40201cc8:	e3a0101b 	mov	r1, #27
40201ccc:	e3a02005 	mov	r2, #5
40201cd0:	ebfffcab 	bl	40200f84 <sr32>

	/* M (CORE_DPLL_MULT): CM_CLKSEL1_PLL[16:26] */
	sr32(CM_CLKSEL1_PLL, 16, 11, ptr->m);
40201cd4:	e7973205 	ldr	r3, [r7, r5, lsl #4]
40201cd8:	e59f035c 	ldr	r0, [pc, #860]	; 4020203c <prcm_init+0x7d8>
40201cdc:	e3a01010 	mov	r1, #16
40201ce0:	e3a0200b 	mov	r2, #11
40201ce4:	ebfffca6 	bl	40200f84 <sr32>

	/* N (CORE_DPLL_DIV): CM_CLKSEL1_PLL[8:14] */
	sr32(CM_CLKSEL1_PLL, 8, 7, ptr->n);
40201ce8:	e5963004 	ldr	r3, [r6, #4]
40201cec:	e59f0348 	ldr	r0, [pc, #840]	; 4020203c <prcm_init+0x7d8>
40201cf0:	e3a01008 	mov	r1, #8
40201cf4:	e3a02007 	mov	r2, #7
40201cf8:	ebfffca1 	bl	40200f84 <sr32>

	/* Source is the CM_96M_FCLK: CM_CLKSEL1_PLL[6] */
	sr32(CM_CLKSEL1_PLL, 6, 1, 0);
40201cfc:	e59f0338 	ldr	r0, [pc, #824]	; 4020203c <prcm_init+0x7d8>
40201d00:	e3a01006 	mov	r1, #6
40201d04:	e3a02001 	mov	r2, #1
40201d08:	e3a03000 	mov	r3, #0
40201d0c:	ebfffc9c 	bl	40200f84 <sr32>

	sr32(CM_CLKSEL_CORE, 8, 4, CORE_SSI_DIV);	/* ssi */
40201d10:	e59f0328 	ldr	r0, [pc, #808]	; 40202040 <prcm_init+0x7dc>
40201d14:	e3a01008 	mov	r1, #8
40201d18:	e3a02004 	mov	r2, #4
40201d1c:	e3a03003 	mov	r3, #3
40201d20:	ebfffc97 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_CORE, 4, 2, CORE_FUSB_DIV);	/* fsusb */
40201d24:	e3a02002 	mov	r2, #2
40201d28:	e1a03002 	mov	r3, r2
40201d2c:	e59f030c 	ldr	r0, [pc, #780]	; 40202040 <prcm_init+0x7dc>
40201d30:	e3a01004 	mov	r1, #4
40201d34:	ebfffc92 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_CORE, 2, 2, CORE_L4_DIV);	/* l4 */
40201d38:	e3a01002 	mov	r1, #2
40201d3c:	e1a02001 	mov	r2, r1
40201d40:	e1a03001 	mov	r3, r1
40201d44:	e59f02f4 	ldr	r0, [pc, #756]	; 40202040 <prcm_init+0x7dc>
40201d48:	ebfffc8d 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_CORE, 0, 2, CORE_L3_DIV);	/* l3 */
40201d4c:	e3a02002 	mov	r2, #2
40201d50:	e1a03002 	mov	r3, r2
40201d54:	e59f02e4 	ldr	r0, [pc, #740]	; 40202040 <prcm_init+0x7dc>
40201d58:	e3a01000 	mov	r1, #0
40201d5c:	ebfffc88 	bl	40200f84 <sr32>

	sr32(CM_CLKSEL_GFX,  0, 3, GFX_DIV_34X);	/* gfx */
40201d60:	e3a02003 	mov	r2, #3
40201d64:	e1a03002 	mov	r3, r2
40201d68:	e59f02d4 	ldr	r0, [pc, #724]	; 40202044 <prcm_init+0x7e0>
40201d6c:	e3a01000 	mov	r1, #0
40201d70:	ebfffc83 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_WKUP, 1, 2, WKUP_RSM);		/* reset mgr */
40201d74:	e3a02002 	mov	r2, #2
40201d78:	e1a03002 	mov	r3, r2
40201d7c:	e59f02c4 	ldr	r0, [pc, #708]	; 40202048 <prcm_init+0x7e4>
40201d80:	e3a01001 	mov	r1, #1
40201d84:	ebfffc7e 	bl	40200f84 <sr32>

	/* FREQSEL (CORE_DPLL_FREQSEL): CM_CLKEN_PLL[4:7] */
	sr32(CM_CLKEN_PLL,   4, 4, ptr->fsel);
40201d88:	e3a01004 	mov	r1, #4
40201d8c:	e1a02001 	mov	r2, r1
40201d90:	e5963008 	ldr	r3, [r6, #8]
40201d94:	e59f0290 	ldr	r0, [pc, #656]	; 4020202c <prcm_init+0x7c8>
40201d98:	ebfffc79 	bl	40200f84 <sr32>
	sr32(CM_CLKEN_PLL,   0, 3, PLL_LOCK);		/* lock mode */
40201d9c:	e59f0288 	ldr	r0, [pc, #648]	; 4020202c <prcm_init+0x7c8>
40201da0:	e3a01000 	mov	r1, #0
40201da4:	e3a02003 	mov	r2, #3
40201da8:	e3a03007 	mov	r3, #7
40201dac:	ebfffc74 	bl	40200f84 <sr32>

	wait_on_value(BIT0, 1, CM_IDLEST_CKGEN, LDELAY);
40201db0:	e3a00001 	mov	r0, #1
40201db4:	e1a01000 	mov	r1, r0
40201db8:	e59f2270 	ldr	r2, [pc, #624]	; 40202030 <prcm_init+0x7cc>
40201dbc:	e59f3270 	ldr	r3, [pc, #624]	; 40202034 <prcm_init+0x7d0>
40201dc0:	ebfffc77 	bl	40200fa4 <wait_on_value>

static void dpll4_init_34xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	ptr = (dpll_param *)get_per_dpll_param();
40201dc4:	ebfffbd4 	bl	40200d1c <get_per_dpll_param>

	/* Moving it to the right sysclk base */
	ptr = ptr + clk_index;

	/* EN_PERIPH_DPLL: CM_CLKEN_PLL[16:18] */
	sr32(CM_CLKEN_PLL, 16, 3, PLL_STOP);
40201dc8:	e3a01010 	mov	r1, #16
40201dcc:	e3a02003 	mov	r2, #3
40201dd0:	e3a03001 	mov	r3, #1
	dpll_param *ptr;

	ptr = (dpll_param *)get_per_dpll_param();

	/* Moving it to the right sysclk base */
	ptr = ptr + clk_index;
40201dd4:	e0806009 	add	r6, r0, r9

static void dpll4_init_34xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	ptr = (dpll_param *)get_per_dpll_param();
40201dd8:	e1a07000 	mov	r7, r0

	/* Moving it to the right sysclk base */
	ptr = ptr + clk_index;

	/* EN_PERIPH_DPLL: CM_CLKEN_PLL[16:18] */
	sr32(CM_CLKEN_PLL, 16, 3, PLL_STOP);
40201ddc:	e59f0248 	ldr	r0, [pc, #584]	; 4020202c <prcm_init+0x7c8>
40201de0:	ebfffc67 	bl	40200f84 <sr32>
	wait_on_value(BIT1, 0, CM_IDLEST_CKGEN, LDELAY);
40201de4:	e3a01000 	mov	r1, #0
40201de8:	e59f2240 	ldr	r2, [pc, #576]	; 40202030 <prcm_init+0x7cc>
40201dec:	e3a00002 	mov	r0, #2
40201df0:	e59f323c 	ldr	r3, [pc, #572]	; 40202034 <prcm_init+0x7d0>
40201df4:	ebfffc6a 	bl	40200fa4 <wait_on_value>

	sr32(CM_CLKSEL1_EMU, 24, 5, PER_M6X2);		/* set M6 */
40201df8:	e59f0238 	ldr	r0, [pc, #568]	; 40202038 <prcm_init+0x7d4>
40201dfc:	e3a01018 	mov	r1, #24
40201e00:	e3a02005 	mov	r2, #5
40201e04:	e3a03003 	mov	r3, #3
40201e08:	ebfffc5d 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_CAM, 0, 5, PER_M5X2);		/* set M5 */
40201e0c:	e59f0238 	ldr	r0, [pc, #568]	; 4020204c <prcm_init+0x7e8>
40201e10:	e3a01000 	mov	r1, #0
40201e14:	e3a02005 	mov	r2, #5
40201e18:	e3a03004 	mov	r3, #4
40201e1c:	ebfffc58 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_DSS, 0, 5, PER_M4X2);		/* set M4 */
40201e20:	e59f0228 	ldr	r0, [pc, #552]	; 40202050 <prcm_init+0x7ec>
40201e24:	e3a01000 	mov	r1, #0
40201e28:	e3a02005 	mov	r2, #5
40201e2c:	e3a03009 	mov	r3, #9
40201e30:	ebfffc53 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_DSS, 8, 5, PER_M3X2);		/* set M3 */
40201e34:	e59f0214 	ldr	r0, [pc, #532]	; 40202050 <prcm_init+0x7ec>
40201e38:	e3a01008 	mov	r1, #8
40201e3c:	e3a02005 	mov	r2, #5
40201e40:	e3a03010 	mov	r3, #16
40201e44:	ebfffc4e 	bl	40200f84 <sr32>

	/* M2 (DIV_96M): CM_CLKSEL3_PLL[0:4] */
	sr32(CM_CLKSEL3_PLL, 0, 5, ptr->m2);
40201e48:	e596300c 	ldr	r3, [r6, #12]
40201e4c:	e59f0200 	ldr	r0, [pc, #512]	; 40202054 <prcm_init+0x7f0>
40201e50:	e3a01000 	mov	r1, #0
40201e54:	e3a02005 	mov	r2, #5
40201e58:	ebfffc49 	bl	40200f84 <sr32>

	/* M (PERIPH_DPLL_MULT): CM_CLKSEL2_PLL[8:18] */
	sr32(CM_CLKSEL2_PLL, 8, 11, ptr->m);
40201e5c:	e7973204 	ldr	r3, [r7, r4, lsl #4]
40201e60:	e59f01f0 	ldr	r0, [pc, #496]	; 40202058 <prcm_init+0x7f4>
40201e64:	e3a01008 	mov	r1, #8
40201e68:	e3a0200b 	mov	r2, #11
40201e6c:	ebfffc44 	bl	40200f84 <sr32>

	/* N (PERIPH_DPLL_DIV): CM_CLKSEL2_PLL[0:6] */
	sr32(CM_CLKSEL2_PLL, 0, 7, ptr->n);
40201e70:	e5963004 	ldr	r3, [r6, #4]
40201e74:	e59f01dc 	ldr	r0, [pc, #476]	; 40202058 <prcm_init+0x7f4>
40201e78:	e3a01000 	mov	r1, #0
40201e7c:	e3a02007 	mov	r2, #7
40201e80:	ebfffc3f 	bl	40200f84 <sr32>

	/* FREQSEL (PERIPH_DPLL_FREQSEL): CM_CLKEN_PLL[20:23] */
	sr32(CM_CLKEN_PLL, 20, 4, ptr->fsel);
40201e84:	e5963008 	ldr	r3, [r6, #8]
40201e88:	e59f019c 	ldr	r0, [pc, #412]	; 4020202c <prcm_init+0x7c8>
40201e8c:	e3a01014 	mov	r1, #20
40201e90:	e3a02004 	mov	r2, #4
40201e94:	ebfffc3a 	bl	40200f84 <sr32>

	/* LOCK MODE (EN_PERIPH_DPLL) : CM_CLKEN_PLL[16:18] */
	sr32(CM_CLKEN_PLL, 16, 3, PLL_LOCK);
40201e98:	e59f018c 	ldr	r0, [pc, #396]	; 4020202c <prcm_init+0x7c8>
40201e9c:	e3a01010 	mov	r1, #16
40201ea0:	e3a02003 	mov	r2, #3
40201ea4:	e3a03007 	mov	r3, #7
40201ea8:	ebfffc35 	bl	40200f84 <sr32>
	wait_on_value(BIT1, 2, CM_IDLEST_CKGEN, LDELAY);
40201eac:	e3a00002 	mov	r0, #2
40201eb0:	e1a01000 	mov	r1, r0
40201eb4:	e59f2174 	ldr	r2, [pc, #372]	; 40202030 <prcm_init+0x7cc>
40201eb8:	e59f3174 	ldr	r3, [pc, #372]	; 40202034 <prcm_init+0x7d0>
40201ebc:	ebfffc38 	bl	40200fa4 <wait_on_value>
static void iva_init_34xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address to IVA DPLL param table*/
	ptr = (dpll_param *)get_iva_dpll_param();
40201ec0:	ebfffb55 	bl	40200c1c <get_iva_dpll_param>
	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + 2*clk_index + sil_index;

	/* IVA DPLL */
	/* EN_IVA2_DPLL : CM_CLKEN_PLL_IVA2[0:2] */
	sr32(CM_CLKEN_PLL_IVA2, 0, 3, PLL_STOP);
40201ec4:	e3a01000 	mov	r1, #0
40201ec8:	e3a02003 	mov	r2, #3
40201ecc:	e3a03001 	mov	r3, #1

	/* Getting the base address to IVA DPLL param table*/
	ptr = (dpll_param *)get_iva_dpll_param();

	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + 2*clk_index + sil_index;
40201ed0:	e080400a 	add	r4, r0, sl
static void iva_init_34xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address to IVA DPLL param table*/
	ptr = (dpll_param *)get_iva_dpll_param();
40201ed4:	e1a06000 	mov	r6, r0
	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + 2*clk_index + sil_index;

	/* IVA DPLL */
	/* EN_IVA2_DPLL : CM_CLKEN_PLL_IVA2[0:2] */
	sr32(CM_CLKEN_PLL_IVA2, 0, 3, PLL_STOP);
40201ed8:	e59f018c 	ldr	r0, [pc, #396]	; 4020206c <prcm_init+0x808>
40201edc:	ebfffc28 	bl	40200f84 <sr32>
	wait_on_value(BIT0, 0, CM_IDLEST_PLL_IVA2, LDELAY);
40201ee0:	e3a01000 	mov	r1, #0
40201ee4:	e59f2184 	ldr	r2, [pc, #388]	; 40202070 <prcm_init+0x80c>
40201ee8:	e3a00001 	mov	r0, #1
40201eec:	e59f3140 	ldr	r3, [pc, #320]	; 40202034 <prcm_init+0x7d0>
40201ef0:	ebfffc2b 	bl	40200fa4 <wait_on_value>

	/* M2 (IVA2_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_IVA2[0:4] */
	sr32(CM_CLKSEL2_PLL_IVA2, 0, 5, ptr->m2);
40201ef4:	e594300c 	ldr	r3, [r4, #12]
40201ef8:	e59f0174 	ldr	r0, [pc, #372]	; 40202074 <prcm_init+0x810>
40201efc:	e3a01000 	mov	r1, #0
40201f00:	e3a02005 	mov	r2, #5
40201f04:	ebfffc1e 	bl	40200f84 <sr32>

	/* M (IVA2_DPLL_MULT) : CM_CLKSEL1_PLL_IVA2[8:18] */
	sr32(CM_CLKSEL1_PLL_IVA2, 8, 11, ptr->m);
40201f08:	e59f0168 	ldr	r0, [pc, #360]	; 40202078 <prcm_init+0x814>
40201f0c:	e3a01008 	mov	r1, #8
40201f10:	e3a0200b 	mov	r2, #11
40201f14:	e7963205 	ldr	r3, [r6, r5, lsl #4]
40201f18:	ebfffc19 	bl	40200f84 <sr32>

	/* N (IVA2_DPLL_DIV) : CM_CLKSEL1_PLL_IVA2[0:6] */
	sr32(CM_CLKSEL1_PLL_IVA2, 0, 7, ptr->n);
40201f1c:	e5943004 	ldr	r3, [r4, #4]
40201f20:	e59f0150 	ldr	r0, [pc, #336]	; 40202078 <prcm_init+0x814>
40201f24:	e3a01000 	mov	r1, #0
40201f28:	e3a02007 	mov	r2, #7
40201f2c:	ebfffc14 	bl	40200f84 <sr32>

	/* FREQSEL (IVA2_DPLL_FREQSEL) : CM_CLKEN_PLL_IVA2[4:7] */
	sr32(CM_CLKEN_PLL_IVA2, 4, 4, ptr->fsel);
40201f30:	e3a01004 	mov	r1, #4
40201f34:	e1a02001 	mov	r2, r1
40201f38:	e5943008 	ldr	r3, [r4, #8]
40201f3c:	e59f0128 	ldr	r0, [pc, #296]	; 4020206c <prcm_init+0x808>
40201f40:	ebfffc0f 	bl	40200f84 <sr32>

	/* LOCK MODE (EN_IVA2_DPLL) : CM_CLKEN_PLL_IVA2[0:2] */
	sr32(CM_CLKEN_PLL_IVA2, 0, 3, PLL_LOCK);
40201f44:	e59f0120 	ldr	r0, [pc, #288]	; 4020206c <prcm_init+0x808>
40201f48:	e3a01000 	mov	r1, #0
40201f4c:	e3a02003 	mov	r2, #3
40201f50:	e3a03007 	mov	r3, #7
40201f54:	ebfffc0a 	bl	40200f84 <sr32>

	wait_on_value(BIT0, 1, CM_IDLEST_PLL_IVA2, LDELAY);
40201f58:	e3a00001 	mov	r0, #1
40201f5c:	e1a01000 	mov	r1, r0
40201f60:	e59f2108 	ldr	r2, [pc, #264]	; 40202070 <prcm_init+0x80c>
40201f64:	e59f30c8 	ldr	r3, [pc, #200]	; 40202034 <prcm_init+0x7d0>
40201f68:	ebfffc0d 	bl	40200fa4 <wait_on_value>
static void mpu_init_34xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address to MPU DPLL param table*/
	ptr = (dpll_param *)get_mpu_dpll_param();
40201f6c:	ebfffb00 	bl	40200b74 <get_mpu_dpll_param>
	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + 2*clk_index + sil_index;

	/* MPU DPLL (unlocked already) */
	/* M2 (MPU_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_MPU[0:4] */
	sr32(CM_CLKSEL2_PLL_MPU, 0, 5, ptr->m2);
40201f70:	e3a01000 	mov	r1, #0
40201f74:	e3a02005 	mov	r2, #5

	/* Getting the base address to MPU DPLL param table*/
	ptr = (dpll_param *)get_mpu_dpll_param();

	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + 2*clk_index + sil_index;
40201f78:	e080a00a 	add	sl, r0, sl
static void mpu_init_34xx(u32 sil_index, u32 clk_index)
{
	dpll_param *ptr;

	/* Getting the base address to MPU DPLL param table*/
	ptr = (dpll_param *)get_mpu_dpll_param();
40201f7c:	e1a04000 	mov	r4, r0
	/* Moving it to the right sysclk and ES rev base */
	ptr = ptr + 2*clk_index + sil_index;

	/* MPU DPLL (unlocked already) */
	/* M2 (MPU_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_MPU[0:4] */
	sr32(CM_CLKSEL2_PLL_MPU, 0, 5, ptr->m2);
40201f80:	e59f00d4 	ldr	r0, [pc, #212]	; 4020205c <prcm_init+0x7f8>
40201f84:	e59a300c 	ldr	r3, [sl, #12]
40201f88:	ebfffbfd 	bl	40200f84 <sr32>

	/* M (MPU_DPLL_MULT) : CM_CLKSEL2_PLL_MPU[8:18] */
	sr32(CM_CLKSEL1_PLL_MPU, 8, 11, ptr->m);
40201f8c:	e59f00cc 	ldr	r0, [pc, #204]	; 40202060 <prcm_init+0x7fc>
40201f90:	e3a01008 	mov	r1, #8
40201f94:	e3a0200b 	mov	r2, #11
40201f98:	e7943205 	ldr	r3, [r4, r5, lsl #4]
40201f9c:	ebfffbf8 	bl	40200f84 <sr32>

	/* N (MPU_DPLL_DIV) : CM_CLKSEL2_PLL_MPU[0:6] */
	sr32(CM_CLKSEL1_PLL_MPU, 0, 7, ptr->n);
40201fa0:	e59f00b8 	ldr	r0, [pc, #184]	; 40202060 <prcm_init+0x7fc>
40201fa4:	e3a01000 	mov	r1, #0
40201fa8:	e3a02007 	mov	r2, #7
40201fac:	e59a3004 	ldr	r3, [sl, #4]
40201fb0:	ebfffbf3 	bl	40200f84 <sr32>

	/* FREQSEL (MPU_DPLL_FREQSEL) : CM_CLKEN_PLL_MPU[4:7] */
	sr32(CM_CLKEN_PLL_MPU, 4, 4, ptr->fsel);
40201fb4:	e3a01004 	mov	r1, #4
40201fb8:	e1a02001 	mov	r2, r1
40201fbc:	e59f00a0 	ldr	r0, [pc, #160]	; 40202064 <prcm_init+0x800>
40201fc0:	e59a3008 	ldr	r3, [sl, #8]
40201fc4:	ebfffbee 	bl	40200f84 <sr32>
		dpll4_init_34xx(sil_index, clk_index);
		iva_init_34xx(sil_index, clk_index);
		mpu_init_34xx(sil_index, clk_index);

		/* Lock MPU DPLL to set frequency */
		sr32(CM_CLKEN_PLL_MPU, 0, 3, PLL_LOCK);
40201fc8:	e59f0094 	ldr	r0, [pc, #148]	; 40202064 <prcm_init+0x800>
40201fcc:	e3a01000 	mov	r1, #0
40201fd0:	e3a02003 	mov	r2, #3
40201fd4:	e3a03007 	mov	r3, #7
40201fd8:	ebfffbe9 	bl	40200f84 <sr32>
		wait_on_value(BIT0, 1, CM_IDLEST_PLL_MPU, LDELAY);
40201fdc:	e59f2084 	ldr	r2, [pc, #132]	; 40202068 <prcm_init+0x804>
40201fe0:	e3a00001 	mov	r0, #1
40201fe4:	e1a01000 	mov	r1, r0
40201fe8:	e59f3044 	ldr	r3, [pc, #68]	; 40202034 <prcm_init+0x7d0>
40201fec:	ebfffbec 	bl	40200fa4 <wait_on_value>
	}

	/* Set up GPTimers to sys_clk source only */
 	sr32(CM_CLKSEL_PER, 0, 8, 0xff);
40201ff0:	e59f0084 	ldr	r0, [pc, #132]	; 4020207c <prcm_init+0x818>
40201ff4:	e3a01000 	mov	r1, #0
40201ff8:	e3a02008 	mov	r2, #8
40201ffc:	e3a030ff 	mov	r3, #255	; 0xff
40202000:	ebfffbdf 	bl	40200f84 <sr32>
	sr32(CM_CLKSEL_WKUP, 0, 1, 1);
40202004:	e3a02001 	mov	r2, #1
40202008:	e59f0038 	ldr	r0, [pc, #56]	; 40202048 <prcm_init+0x7e4>
4020200c:	e3a01000 	mov	r1, #0
40202010:	e1a03002 	mov	r3, r2
40202014:	ebfffbda 	bl	40200f84 <sr32>

	delay(5000);
40202018:	e3010388 	movw	r0, #5000	; 0x1388
4020201c:	ebfffb9c 	bl	40200e94 <delay>
}
40202020:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
40202024:	48306d40 	.word	0x48306d40
40202028:	48307270 	.word	0x48307270
4020202c:	48004d00 	.word	0x48004d00
40202030:	48004d20 	.word	0x48004d20
40202034:	00b71b00 	.word	0x00b71b00
40202038:	48005140 	.word	0x48005140
4020203c:	48004d40 	.word	0x48004d40
40202040:	48004a40 	.word	0x48004a40
40202044:	48004b40 	.word	0x48004b40
40202048:	48004c40 	.word	0x48004c40
4020204c:	48004f40 	.word	0x48004f40
40202050:	48004e40 	.word	0x48004e40
40202054:	48004d48 	.word	0x48004d48
40202058:	48004d44 	.word	0x48004d44
4020205c:	48004944 	.word	0x48004944
40202060:	48004940 	.word	0x48004940
40202064:	48004904 	.word	0x48004904
40202068:	48004924 	.word	0x48004924
4020206c:	48004004 	.word	0x48004004
40202070:	48004024 	.word	0x48004024
40202074:	48004044 	.word	0x48004044
40202078:	48004040 	.word	0x48004040
4020207c:	48005040 	.word	0x48005040

40202080 <s_init>:
 * Description: Does early system init of muxing and clocks.
 * - Called at time when only stack is available.
 **********************************************************/

void s_init(void)
{
40202080:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	watchdog_init();
40202084:	ebfffcaf 	bl	40201348 <watchdog_init>
	/* setup the scalability control register for
	 * 3430 to work in 3410 mode
	 */
	__raw_writel(0x5ABF,CONTROL_SCALABLE_OMAP_OCP);
#endif
	try_unlock_memory();
40202088:	ebfffca2 	bl	40201318 <try_unlock_memory>
	set_muxconf_regs();
4020208c:	ebfffcf7 	bl	40201470 <set_muxconf_regs>
	delay(100);
40202090:	e3a00064 	mov	r0, #100	; 0x64
40202094:	ebfffb7e 	bl	40200e94 <delay>
	prcm_init();
40202098:	ebfffdf1 	bl	40201864 <prcm_init>
	per_clocks_enable();
4020209c:	ebfffcc7 	bl	402013c0 <per_clocks_enable>
	config_3430sdram_ddr();
}
402020a0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	try_unlock_memory();
	set_muxconf_regs();
	delay(100);
	prcm_init();
	per_clocks_enable();
	config_3430sdram_ddr();
402020a4:	eafffbdb 	b	40201018 <config_3430sdram_ddr>

402020a8 <mmc_get_dev>:
static block_dev_desc_t mmc_blk_dev;

block_dev_desc_t *mmc_get_dev(int dev)
{
	return ((block_dev_desc_t *) &mmc_blk_dev);
}
402020a8:	e51f0000 	ldr	r0, [pc, #0]	; 402020b0 <mmc_get_dev+0x8>
402020ac:	e12fff1e 	bx	lr
402020b0:	40204f70 	.word	0x40204f70

402020b4 <mmc_board_init>:
unsigned char mmc_board_init(void)
{
#if defined (CONFIG_OMAP34XX) && !defined (CONFIG_AM3517EVM)
	unsigned int value = 0;

	value = CONTROL_PBIAS_LITE;
402020b4:	e59f3020 	ldr	r3, [pc, #32]	; 402020dc <mmc_board_init+0x28>

	value = CONTROL_DEV_CONF0;
	CONTROL_DEV_CONF0 = value | (1 << 24);
#endif
	return 1;
}
402020b8:	e3a00001 	mov	r0, #1
unsigned char mmc_board_init(void)
{
#if defined (CONFIG_OMAP34XX) && !defined (CONFIG_AM3517EVM)
	unsigned int value = 0;

	value = CONTROL_PBIAS_LITE;
402020bc:	e5932520 	ldr	r2, [r3, #1312]	; 0x520
	CONTROL_PBIAS_LITE = value | (1 << 2) | (1 << 1) | (1 << 9);
402020c0:	e3822f81 	orr	r2, r2, #516	; 0x204
402020c4:	e3822002 	orr	r2, r2, #2
402020c8:	e5832520 	str	r2, [r3, #1312]	; 0x520

	value = CONTROL_DEV_CONF0;
402020cc:	e5932274 	ldr	r2, [r3, #628]	; 0x274
	CONTROL_DEV_CONF0 = value | (1 << 24);
402020d0:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
402020d4:	e5832274 	str	r2, [r3, #628]	; 0x274
#endif
	return 1;
}
402020d8:	e12fff1e 	bx	lr
402020dc:	48002000 	.word	0x48002000

402020e0 <mmc_init_stream>:

void mmc_init_stream(void)
{
	volatile unsigned int mmc_stat;

	OMAP_HSMMC_CON |= INIT_INITSTREAM;
402020e0:	e59f3070 	ldr	r3, [pc, #112]	; 40202158 <mmc_init_stream+0x78>
#endif
	return 1;
}

void mmc_init_stream(void)
{
402020e4:	e24dd004 	sub	sp, sp, #4
	volatile unsigned int mmc_stat;

	OMAP_HSMMC_CON |= INIT_INITSTREAM;
402020e8:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
402020ec:	e3822002 	orr	r2, r2, #2
402020f0:	e583202c 	str	r2, [r3, #44]	; 0x2c

	OMAP_HSMMC_CMD = MMC_CMD0;
402020f4:	e3a02000 	mov	r2, #0
402020f8:	e583210c 	str	r2, [r3, #268]	; 0x10c
	do {
		mmc_stat = OMAP_HSMMC_STAT;
402020fc:	e59f3054 	ldr	r3, [pc, #84]	; 40202158 <mmc_init_stream+0x78>
40202100:	e5932130 	ldr	r2, [r3, #304]	; 0x130
40202104:	e58d2000 	str	r2, [sp]
	} while (!(mmc_stat & CC_MASK));
40202108:	e59d2000 	ldr	r2, [sp]
4020210c:	e3120001 	tst	r2, #1
40202110:	0afffff9 	beq	402020fc <mmc_init_stream+0x1c>

	OMAP_HSMMC_STAT = CC_MASK;
40202114:	e3a02001 	mov	r2, #1
40202118:	e5832130 	str	r2, [r3, #304]	; 0x130

	OMAP_HSMMC_CMD = MMC_CMD0;
4020211c:	e3a02000 	mov	r2, #0
40202120:	e583210c 	str	r2, [r3, #268]	; 0x10c
	do {
		mmc_stat = OMAP_HSMMC_STAT;
40202124:	e59f302c 	ldr	r3, [pc, #44]	; 40202158 <mmc_init_stream+0x78>
40202128:	e5932130 	ldr	r2, [r3, #304]	; 0x130
4020212c:	e58d2000 	str	r2, [sp]
	} while (!(mmc_stat & CC_MASK));
40202130:	e59d2000 	ldr	r2, [sp]
40202134:	e3120001 	tst	r2, #1
40202138:	0afffff9 	beq	40202124 <mmc_init_stream+0x44>

	OMAP_HSMMC_STAT = OMAP_HSMMC_STAT;
4020213c:	e5932130 	ldr	r2, [r3, #304]	; 0x130
40202140:	e5832130 	str	r2, [r3, #304]	; 0x130
	OMAP_HSMMC_CON &= ~INIT_INITSTREAM;
40202144:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
40202148:	e3c22002 	bic	r2, r2, #2
4020214c:	e583202c 	str	r2, [r3, #44]	; 0x2c
}
40202150:	e28dd004 	add	sp, sp, #4
40202154:	e12fff1e 	bx	lr
40202158:	4809c000 	.word	0x4809c000

4020215c <mmc_clock_config>:

unsigned char mmc_clock_config(unsigned int iclk, unsigned short clk_div)
{
	unsigned int val;

	mmc_reg_out(OMAP_HSMMC_SYSCTL, (ICE_MASK | DTO_MASK | CEN_MASK),
4020215c:	e59f2084 	ldr	r2, [pc, #132]	; 402021e8 <mmc_clock_config+0x8c>
		    (ICE_STOP | DTO_15THDTO | CEN_DISABLE));

	switch (iclk) {
40202160:	e3500001 	cmp	r0, #1
	OMAP_HSMMC_STAT = OMAP_HSMMC_STAT;
	OMAP_HSMMC_CON &= ~INIT_INITSTREAM;
}

unsigned char mmc_clock_config(unsigned int iclk, unsigned short clk_div)
{
40202164:	e6ff1071 	uxth	r1, r1
	unsigned int val;

	mmc_reg_out(OMAP_HSMMC_SYSCTL, (ICE_MASK | DTO_MASK | CEN_MASK),
40202168:	e592312c 	ldr	r3, [r2, #300]	; 0x12c
4020216c:	e3c3380f 	bic	r3, r3, #983040	; 0xf0000
40202170:	e3c33005 	bic	r3, r3, #5
40202174:	e383380e 	orr	r3, r3, #917504	; 0xe0000
40202178:	e582312c 	str	r3, [r2, #300]	; 0x12c
		    (ICE_STOP | DTO_15THDTO | CEN_DISABLE));

	switch (iclk) {
4020217c:	0a000005 	beq	40202198 <mmc_clock_config+0x3c>
40202180:	33a01f96 	movcc	r1, #600	; 0x258
40202184:	3a000004 	bcc	4020219c <mmc_clock_config+0x40>
40202188:	e3500002 	cmp	r0, #2
4020218c:	13a00000 	movne	r0, #0
40202190:	112fff1e 	bxne	lr
40202194:	ea000000 	b	4020219c <mmc_clock_config+0x40>
40202198:	e3a010f0 	mov	r1, #240	; 0xf0
		val = clk_div;
		break;
	default:
		return 0;
	}
	mmc_reg_out(OMAP_HSMMC_SYSCTL,
4020219c:	e59f2044 	ldr	r2, [pc, #68]	; 402021e8 <mmc_clock_config+0x8c>
402021a0:	e1a01301 	lsl	r1, r1, #6
402021a4:	e1a01801 	lsl	r1, r1, #16
402021a8:	e592312c 	ldr	r3, [r2, #300]	; 0x12c
402021ac:	e1a01821 	lsr	r1, r1, #16
402021b0:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
402021b4:	e3c330c1 	bic	r3, r3, #193	; 0xc1
402021b8:	e3833001 	orr	r3, r3, #1
402021bc:	e1831001 	orr	r1, r3, r1
402021c0:	e582112c 	str	r1, [r2, #300]	; 0x12c
		    ICE_MASK | CLKD_MASK, (val << CLKD_OFFSET) | ICE_OSCILLATE);

	while ((OMAP_HSMMC_SYSCTL & ICS_MASK) == ICS_NOTREADY);
402021c4:	e59f301c 	ldr	r3, [pc, #28]	; 402021e8 <mmc_clock_config+0x8c>
402021c8:	e593212c 	ldr	r2, [r3, #300]	; 0x12c
402021cc:	e3120002 	tst	r2, #2
402021d0:	0afffffb 	beq	402021c4 <mmc_clock_config+0x68>


	OMAP_HSMMC_SYSCTL |= CEN_ENABLE;
402021d4:	e593212c 	ldr	r2, [r3, #300]	; 0x12c
402021d8:	e3a00001 	mov	r0, #1
402021dc:	e3822004 	orr	r2, r2, #4
402021e0:	e583212c 	str	r2, [r3, #300]	; 0x12c
	return 1;
}
402021e4:	e12fff1e 	bx	lr
402021e8:	4809c000 	.word	0x4809c000

402021ec <mmc_init_setup>:

unsigned char mmc_init_setup(void)
{
402021ec:	e92d4010 	push	{r4, lr}
	unsigned int reg_val;

	mmc_board_init();
402021f0:	ebffffaf 	bl	402020b4 <mmc_board_init>

	OMAP_HSMMC_SYSCONFIG |= MMC_SOFTRESET;
402021f4:	e59f307c 	ldr	r3, [pc, #124]	; 40202278 <mmc_init_setup+0x8c>
402021f8:	e5932010 	ldr	r2, [r3, #16]
402021fc:	e3822002 	orr	r2, r2, #2
40202200:	e5832010 	str	r2, [r3, #16]
	while ((OMAP_HSMMC_SYSSTATUS & RESETDONE) == 0) ;
40202204:	e59f306c 	ldr	r3, [pc, #108]	; 40202278 <mmc_init_setup+0x8c>
40202208:	e5932014 	ldr	r2, [r3, #20]
4020220c:	e3120001 	tst	r2, #1
40202210:	0afffffb 	beq	40202204 <mmc_init_setup+0x18>

	OMAP_HSMMC_SYSCTL |= SOFTRESETALL;
40202214:	e593212c 	ldr	r2, [r3, #300]	; 0x12c
40202218:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
4020221c:	e583212c 	str	r2, [r3, #300]	; 0x12c
	while ((OMAP_HSMMC_SYSCTL & SOFTRESETALL) != 0x0) ;
40202220:	e59f4050 	ldr	r4, [pc, #80]	; 40202278 <mmc_init_setup+0x8c>
40202224:	e594012c 	ldr	r0, [r4, #300]	; 0x12c
40202228:	e2100401 	ands	r0, r0, #16777216	; 0x1000000
4020222c:	1afffffb 	bne	40202220 <mmc_init_setup+0x34>

	OMAP_HSMMC_HCTL = DTW_1_BITMODE | SDBP_PWROFF | SDVS_3V0;
40202230:	e3a03b03 	mov	r3, #3072	; 0xc00
40202234:	e5843128 	str	r3, [r4, #296]	; 0x128
	OMAP_HSMMC_CAPA |= VS30_3V0SUP | VS18_1V8SUP;
40202238:	e5943140 	ldr	r3, [r4, #320]	; 0x140

	OMAP_HSMMC_CON = CTPL_MMC_SD | reg_val | WPP_ACTIVEHIGH |
	    CDP_ACTIVEHIGH | MIT_CTO | DW8_1_4BITMODE | MODE_FUNC |
	    STR_BLOCK | HR_NOHOSTRESP | INIT_NOINIT | NOOPENDRAIN;

	mmc_clock_config(CLK_INITSEQ, 0);
4020223c:	e1a01000 	mov	r1, r0

	OMAP_HSMMC_SYSCTL |= SOFTRESETALL;
	while ((OMAP_HSMMC_SYSCTL & SOFTRESETALL) != 0x0) ;

	OMAP_HSMMC_HCTL = DTW_1_BITMODE | SDBP_PWROFF | SDVS_3V0;
	OMAP_HSMMC_CAPA |= VS30_3V0SUP | VS18_1V8SUP;
40202240:	e3833406 	orr	r3, r3, #100663296	; 0x6000000
40202244:	e5843140 	str	r3, [r4, #320]	; 0x140

	reg_val = OMAP_HSMMC_CON & RESERVED_MASK;
40202248:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
4020224c:	e2033c06 	and	r3, r3, #1536	; 0x600

	OMAP_HSMMC_CON = CTPL_MMC_SD | reg_val | WPP_ACTIVEHIGH |
40202250:	e584302c 	str	r3, [r4, #44]	; 0x2c
	    CDP_ACTIVEHIGH | MIT_CTO | DW8_1_4BITMODE | MODE_FUNC |
	    STR_BLOCK | HR_NOHOSTRESP | INIT_NOINIT | NOOPENDRAIN;

	mmc_clock_config(CLK_INITSEQ, 0);
40202254:	ebffffc0 	bl	4020215c <mmc_clock_config>
	OMAP_HSMMC_HCTL |= SDBP_PWRON;
40202258:	e5943128 	ldr	r3, [r4, #296]	; 0x128
4020225c:	e3833c01 	orr	r3, r3, #256	; 0x100
40202260:	e5843128 	str	r3, [r4, #296]	; 0x128

	OMAP_HSMMC_IE = 0x307f0033;
40202264:	e59f3010 	ldr	r3, [pc, #16]	; 4020227c <mmc_init_setup+0x90>
40202268:	e5843134 	str	r3, [r4, #308]	; 0x134

	mmc_init_stream();
4020226c:	ebffff9b 	bl	402020e0 <mmc_init_stream>
	return 1;
}
40202270:	e3a00001 	mov	r0, #1
40202274:	e8bd8010 	pop	{r4, pc}
40202278:	4809c000 	.word	0x4809c000
4020227c:	307f0033 	.word	0x307f0033

40202280 <mmc_send_cmd>:
unsigned char mmc_send_cmd(unsigned int cmd, unsigned int arg,
			   unsigned int *response)
{
	unsigned int mmc_stat;

	while ((OMAP_HSMMC_PSTATE & DATI_MASK) == DATI_CMDDIS);
40202280:	e59f3084 	ldr	r3, [pc, #132]	; 4020230c <mmc_send_cmd+0x8c>
40202284:	e593c124 	ldr	ip, [r3, #292]	; 0x124
40202288:	e31c0002 	tst	ip, #2
4020228c:	1afffffb 	bne	40202280 <mmc_send_cmd>


	OMAP_HSMMC_BLK = BLEN_512BYTESLEN | NBLK_STPCNT;
40202290:	e3a0cc02 	mov	ip, #512	; 0x200
40202294:	e583c104 	str	ip, [r3, #260]	; 0x104
	OMAP_HSMMC_STAT = 0xFFFFFFFF;
40202298:	e3e0c000 	mvn	ip, #0
4020229c:	e583c130 	str	ip, [r3, #304]	; 0x130
	OMAP_HSMMC_ARG = arg;
402022a0:	e5831108 	str	r1, [r3, #264]	; 0x108
	OMAP_HSMMC_CMD = cmd | CMD_TYPE_NORMAL | CICE_NOCHECK |
402022a4:	e583010c 	str	r0, [r3, #268]	; 0x10c
	    CCCE_NOCHECK | MSBS_SGLEBLK | ACEN_DISABLE | BCE_DISABLE |
	    DE_DISABLE;

	while (1) {
		do {
			mmc_stat = OMAP_HSMMC_STAT;
402022a8:	e59f305c 	ldr	r3, [pc, #92]	; 4020230c <mmc_send_cmd+0x8c>
402022ac:	e5931130 	ldr	r1, [r3, #304]	; 0x130
		} while (mmc_stat == 0);
402022b0:	e3510000 	cmp	r1, #0
402022b4:	0afffffb 	beq	402022a8 <mmc_send_cmd+0x28>

		if ((mmc_stat & ERRI_MASK) != 0)
402022b8:	e3110902 	tst	r1, #32768	; 0x8000
402022bc:	0a000001 	beq	402022c8 <mmc_send_cmd+0x48>
			return (unsigned char)mmc_stat;
402022c0:	e6ef0071 	uxtb	r0, r1
402022c4:	e12fff1e 	bx	lr


		if (mmc_stat & CC_MASK) {
402022c8:	e3110001 	tst	r1, #1
402022cc:	0afffff5 	beq	402022a8 <mmc_send_cmd+0x28>
			OMAP_HSMMC_STAT = CC_MASK;
			response[0] = OMAP_HSMMC_RSP10;
			if ((cmd & RSP_TYPE_MASK) == RSP_TYPE_LGHT136) {
402022d0:	e2000803 	and	r0, r0, #196608	; 0x30000
		if ((mmc_stat & ERRI_MASK) != 0)
			return (unsigned char)mmc_stat;


		if (mmc_stat & CC_MASK) {
			OMAP_HSMMC_STAT = CC_MASK;
402022d4:	e3a01001 	mov	r1, #1
402022d8:	e5831130 	str	r1, [r3, #304]	; 0x130
			response[0] = OMAP_HSMMC_RSP10;
			if ((cmd & RSP_TYPE_MASK) == RSP_TYPE_LGHT136) {
402022dc:	e3500801 	cmp	r0, #65536	; 0x10000
			return (unsigned char)mmc_stat;


		if (mmc_stat & CC_MASK) {
			OMAP_HSMMC_STAT = CC_MASK;
			response[0] = OMAP_HSMMC_RSP10;
402022e0:	e593c110 	ldr	ip, [r3, #272]	; 0x110
			if ((cmd & RSP_TYPE_MASK) == RSP_TYPE_LGHT136) {
402022e4:	11a00001 	movne	r0, r1
			return (unsigned char)mmc_stat;


		if (mmc_stat & CC_MASK) {
			OMAP_HSMMC_STAT = CC_MASK;
			response[0] = OMAP_HSMMC_RSP10;
402022e8:	e582c000 	str	ip, [r2]
			if ((cmd & RSP_TYPE_MASK) == RSP_TYPE_LGHT136) {
				response[1] = OMAP_HSMMC_RSP32;
402022ec:	05930114 	ldreq	r0, [r3, #276]	; 0x114
402022f0:	05820004 	streq	r0, [r2, #4]
				response[2] = OMAP_HSMMC_RSP54;
402022f4:	05930118 	ldreq	r0, [r3, #280]	; 0x118
402022f8:	05820008 	streq	r0, [r2, #8]
				response[3] = OMAP_HSMMC_RSP76;
402022fc:	01a00001 	moveq	r0, r1
40202300:	0593311c 	ldreq	r3, [r3, #284]	; 0x11c
40202304:	0582300c 	streq	r3, [r2, #12]
			}
			break;
		}
	}
	return 1;
}
40202308:	e12fff1e 	bx	lr
4020230c:	4809c000 	.word	0x4809c000

40202310 <mmc_read_data>:
	/*
	 * Start Polled Read
	 */
	while (1) {
		do {
			mmc_stat = OMAP_HSMMC_STAT;
40202310:	e59f107c 	ldr	r1, [pc, #124]	; 40202394 <mmc_read_data+0x84>
40202314:	e5913130 	ldr	r3, [r1, #304]	; 0x130
		} while (mmc_stat == 0);
40202318:	e3530000 	cmp	r3, #0
4020231c:	0afffffb 	beq	40202310 <mmc_read_data>

		if ((mmc_stat & ERRI_MASK) != 0)
40202320:	e2132902 	ands	r2, r3, #32768	; 0x8000
40202324:	0a000001 	beq	40202330 <mmc_read_data+0x20>
			return (unsigned char)mmc_stat;
40202328:	e6ef0073 	uxtb	r0, r3
4020232c:	e12fff1e 	bx	lr

		if (mmc_stat & BRR_MASK) {
40202330:	e3130020 	tst	r3, #32
40202334:	0a000009 	beq	40202360 <mmc_read_data+0x50>
			unsigned int k;

			OMAP_HSMMC_STAT |= BRR_MASK;
40202338:	e591c130 	ldr	ip, [r1, #304]	; 0x130
4020233c:	e38cc020 	orr	ip, ip, #32
40202340:	e581c130 	str	ip, [r1, #304]	; 0x130
			for (k = 0; k < MMCSD_SECTOR_SIZE / 4; k++) {
				*output_buf = OMAP_HSMMC_DATA;
40202344:	e59f1048 	ldr	r1, [pc, #72]	; 40202394 <mmc_read_data+0x84>
40202348:	e5911120 	ldr	r1, [r1, #288]	; 0x120
4020234c:	e7801002 	str	r1, [r0, r2]
40202350:	e2822004 	add	r2, r2, #4

		if (mmc_stat & BRR_MASK) {
			unsigned int k;

			OMAP_HSMMC_STAT |= BRR_MASK;
			for (k = 0; k < MMCSD_SECTOR_SIZE / 4; k++) {
40202354:	e3520c02 	cmp	r2, #512	; 0x200
40202358:	1afffff9 	bne	40202344 <mmc_read_data+0x34>
4020235c:	e2800c02 	add	r0, r0, #512	; 0x200
				output_buf++;
				read_count += 4;
			}
		}

		if (mmc_stat & BWR_MASK)
40202360:	e3130010 	tst	r3, #16
			OMAP_HSMMC_STAT |= BWR_MASK;
40202364:	159f2028 	ldrne	r2, [pc, #40]	; 40202394 <mmc_read_data+0x84>
40202368:	15921130 	ldrne	r1, [r2, #304]	; 0x130
4020236c:	13811010 	orrne	r1, r1, #16
40202370:	15821130 	strne	r1, [r2, #304]	; 0x130

		if (mmc_stat & TC_MASK) {
40202374:	e3130002 	tst	r3, #2
40202378:	0affffe4 	beq	40202310 <mmc_read_data>
			OMAP_HSMMC_STAT |= TC_MASK;
4020237c:	e59f3010 	ldr	r3, [pc, #16]	; 40202394 <mmc_read_data+0x84>
40202380:	e3a00001 	mov	r0, #1
40202384:	e5932130 	ldr	r2, [r3, #304]	; 0x130
40202388:	e3822002 	orr	r2, r2, #2
4020238c:	e5832130 	str	r2, [r3, #304]	; 0x130
			break;
		}
	}
	return 1;
}
40202390:	e12fff1e 	bx	lr
40202394:	4809c000 	.word	0x4809c000

40202398 <mmc_detect_card>:

unsigned char mmc_detect_card(mmc_card_data *mmc_card_cur)
{
40202398:	e92d44ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, sl, lr}
4020239c:	e1a04000 	mov	r4, r0
	unsigned int ocr_value, ocr_recvd, ret_cmd41, hcs_val;
	unsigned int resp[4];
	unsigned short retry_cnt = 2000;

	/* Set to Initialization Clock */
	err = mmc_clock_config(CLK_400KHZ, 0);
402023a0:	e3a01000 	mov	r1, #0
402023a4:	e3a00001 	mov	r0, #1
402023a8:	ebffff6b 	bl	4020215c <mmc_clock_config>
	if (err != 1)
402023ac:	e3500001 	cmp	r0, #1
402023b0:	1a000078 	bne	40202598 <mmc_detect_card+0x200>

	mmc_card_cur->RCA = MMC_RELATIVE_CARD_ADDRESS;
	argument = 0x00000000;

	ocr_value = (0x1FF << 15);
	err = mmc_send_cmd(MMC_CMD0, argument, resp);
402023b4:	e3a00000 	mov	r0, #0
	/* Set to Initialization Clock */
	err = mmc_clock_config(CLK_400KHZ, 0);
	if (err != 1)
		return err;

	mmc_card_cur->RCA = MMC_RELATIVE_CARD_ADDRESS;
402023b8:	e3013234 	movw	r3, #4660	; 0x1234
	argument = 0x00000000;

	ocr_value = (0x1FF << 15);
	err = mmc_send_cmd(MMC_CMD0, argument, resp);
402023bc:	e1a01000 	mov	r1, r0
	/* Set to Initialization Clock */
	err = mmc_clock_config(CLK_400KHZ, 0);
	if (err != 1)
		return err;

	mmc_card_cur->RCA = MMC_RELATIVE_CARD_ADDRESS;
402023c0:	e5843010 	str	r3, [r4, #16]
	argument = 0x00000000;

	ocr_value = (0x1FF << 15);
	err = mmc_send_cmd(MMC_CMD0, argument, resp);
402023c4:	e1a0200d 	mov	r2, sp
402023c8:	e1a0600d 	mov	r6, sp
402023cc:	ebffffab 	bl	40202280 <mmc_send_cmd>
	if (err != 1)
402023d0:	e3500001 	cmp	r0, #1
402023d4:	1a00006f 	bne	40202598 <mmc_detect_card+0x200>
		return err;

	argument = SD_CMD8_CHECK_PATTERN | SD_CMD8_2_7_3_6_V_RANGE;
	err = mmc_send_cmd(MMC_SDCMD8, argument, resp);
402023d8:	e30011aa 	movw	r1, #426	; 0x1aa
402023dc:	e1a0200d 	mov	r2, sp
402023e0:	e59f01b8 	ldr	r0, [pc, #440]	; 402025a0 <mmc_detect_card+0x208>
402023e4:	ebffffa5 	bl	40202280 <mmc_send_cmd>
	hcs_val = (err == 1) ?
	    MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR :
	    MMC_OCR_REG_HOST_CAPACITY_SUPPORT_BYTE;

	argument = 0x0000 << 16;
	err = mmc_send_cmd(MMC_CMD55, argument, resp);
402023e8:	e3a01000 	mov	r1, #0
402023ec:	e1a0200d 	mov	r2, sp
	if (err != 1)
		return err;

	argument = SD_CMD8_CHECK_PATTERN | SD_CMD8_2_7_3_6_V_RANGE;
	err = mmc_send_cmd(MMC_SDCMD8, argument, resp);
	hcs_val = (err == 1) ?
402023f0:	e3500001 	cmp	r0, #1
	    MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR :
	    MMC_OCR_REG_HOST_CAPACITY_SUPPORT_BYTE;

	argument = 0x0000 << 16;
	err = mmc_send_cmd(MMC_CMD55, argument, resp);
402023f4:	e59f01a8 	ldr	r0, [pc, #424]	; 402025a4 <mmc_detect_card+0x20c>
	if (err != 1)
		return err;

	argument = SD_CMD8_CHECK_PATTERN | SD_CMD8_2_7_3_6_V_RANGE;
	err = mmc_send_cmd(MMC_SDCMD8, argument, resp);
	hcs_val = (err == 1) ?
402023f8:	03a05101 	moveq	r5, #1073741824	; 0x40000000
402023fc:	13a05000 	movne	r5, #0
	    MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR :
	    MMC_OCR_REG_HOST_CAPACITY_SUPPORT_BYTE;

	argument = 0x0000 << 16;
	err = mmc_send_cmd(MMC_CMD55, argument, resp);
40202400:	ebffff9e 	bl	40202280 <mmc_send_cmd>
	if (err == 1) {
40202404:	e3500001 	cmp	r0, #1
		mmc_card_cur->card_type = SD_CARD;
		ocr_value |= hcs_val;
40202408:	038558ff 	orreq	r5, r5, #16711680	; 0xff0000
	    MMC_OCR_REG_HOST_CAPACITY_SUPPORT_BYTE;

	argument = 0x0000 << 16;
	err = mmc_send_cmd(MMC_CMD55, argument, resp);
	if (err == 1) {
		mmc_card_cur->card_type = SD_CARD;
4020240c:	05840000 	streq	r0, [r4]
		ocr_value |= hcs_val;
40202410:	03855902 	orreq	r5, r5, #32768	; 0x8000
40202414:	059f718c 	ldreq	r7, [pc, #396]	; 402025a8 <mmc_detect_card+0x210>
40202418:	0a00000a 	beq	40202448 <mmc_detect_card+0xb0>
		ret_cmd41 = MMC_ACMD41;
	} else {
		mmc_card_cur->card_type = MMC_CARD;
4020241c:	e3a03000 	mov	r3, #0
40202420:	e5843000 	str	r3, [r4]
		ocr_value |= MMC_OCR_REG_ACCESS_MODE_SECTOR;
		ret_cmd41 = MMC_CMD1;
		OMAP_HSMMC_CON &= ~OD;
40202424:	e59f3180 	ldr	r3, [pc, #384]	; 402025ac <mmc_detect_card+0x214>
		OMAP_HSMMC_CON |= OPENDRAIN;
40202428:	e59f7180 	ldr	r7, [pc, #384]	; 402025b0 <mmc_detect_card+0x218>
4020242c:	e59f5180 	ldr	r5, [pc, #384]	; 402025b4 <mmc_detect_card+0x21c>
		ret_cmd41 = MMC_ACMD41;
	} else {
		mmc_card_cur->card_type = MMC_CARD;
		ocr_value |= MMC_OCR_REG_ACCESS_MODE_SECTOR;
		ret_cmd41 = MMC_CMD1;
		OMAP_HSMMC_CON &= ~OD;
40202430:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
40202434:	e3c22001 	bic	r2, r2, #1
40202438:	e583202c 	str	r2, [r3, #44]	; 0x2c
		OMAP_HSMMC_CON |= OPENDRAIN;
4020243c:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
40202440:	e3822001 	orr	r2, r2, #1
40202444:	e583202c 	str	r2, [r3, #44]	; 0x2c
	}

	argument = ocr_value;
	err = mmc_send_cmd(ret_cmd41, argument, resp);
40202448:	e1a00007 	mov	r0, r7
4020244c:	e1a01005 	mov	r1, r5
40202450:	e1a0200d 	mov	r2, sp
40202454:	e1a0a00d 	mov	sl, sp
40202458:	ebffff88 	bl	40202280 <mmc_send_cmd>
	if (err != 1)
4020245c:	e3500001 	cmp	r0, #1
		return err;

	ocr_recvd = ((mmc_resp_r3 *) resp)->ocr;
40202460:	059d3000 	ldreq	r3, [sp]
40202464:	03a06e7d 	moveq	r6, #2000	; 0x7d0
		OMAP_HSMMC_CON |= OPENDRAIN;
	}

	argument = ocr_value;
	err = mmc_send_cmd(ret_cmd41, argument, resp);
	if (err != 1)
40202468:	1a00004a 	bne	40202598 <mmc_detect_card+0x200>
4020246c:	ea00000f 	b	402024b0 <mmc_detect_card+0x118>

	ocr_recvd = ((mmc_resp_r3 *) resp)->ocr;

	while (!(ocr_recvd & (0x1 << 31)) && (retry_cnt > 0)) {
		retry_cnt--;
		if (mmc_card_cur->card_type == SD_CARD) {
40202470:	e5943000 	ldr	r3, [r4]
40202474:	e3530001 	cmp	r3, #1
40202478:	1a000003 	bne	4020248c <mmc_detect_card+0xf4>
			argument = 0x0000 << 16;
			err = mmc_send_cmd(MMC_CMD55, argument, resp);
4020247c:	e59f0120 	ldr	r0, [pc, #288]	; 402025a4 <mmc_detect_card+0x20c>
40202480:	e3a01000 	mov	r1, #0
40202484:	e1a0200d 	mov	r2, sp
40202488:	ebffff7c 	bl	40202280 <mmc_send_cmd>
		}

		argument = ocr_value;
		err = mmc_send_cmd(ret_cmd41, argument, resp);
4020248c:	e1a00007 	mov	r0, r7
40202490:	e1a01005 	mov	r1, r5
40202494:	e1a0200d 	mov	r2, sp
40202498:	ebffff78 	bl	40202280 <mmc_send_cmd>
		if (err != 1)
4020249c:	e3500001 	cmp	r0, #1
402024a0:	1a00003c 	bne	40202598 <mmc_detect_card+0x200>
		return err;

	ocr_recvd = ((mmc_resp_r3 *) resp)->ocr;

	while (!(ocr_recvd & (0x1 << 31)) && (retry_cnt > 0)) {
		retry_cnt--;
402024a4:	e2466001 	sub	r6, r6, #1

		argument = ocr_value;
		err = mmc_send_cmd(ret_cmd41, argument, resp);
		if (err != 1)
			return err;
		ocr_recvd = ((mmc_resp_r3 *) resp)->ocr;
402024a8:	e59a3000 	ldr	r3, [sl]
		return err;

	ocr_recvd = ((mmc_resp_r3 *) resp)->ocr;

	while (!(ocr_recvd & (0x1 << 31)) && (retry_cnt > 0)) {
		retry_cnt--;
402024ac:	e6ff6076 	uxth	r6, r6
	if (err != 1)
		return err;

	ocr_recvd = ((mmc_resp_r3 *) resp)->ocr;

	while (!(ocr_recvd & (0x1 << 31)) && (retry_cnt > 0)) {
402024b0:	e1e02003 	mvn	r2, r3
402024b4:	e1a02fa2 	lsr	r2, r2, #31
402024b8:	e3560000 	cmp	r6, #0
402024bc:	03a02000 	moveq	r2, #0
402024c0:	e3520000 	cmp	r2, #0
402024c4:	1affffe9 	bne	40202470 <mmc_detect_card+0xd8>
		if (err != 1)
			return err;
		ocr_recvd = ((mmc_resp_r3 *) resp)->ocr;
	}

	if (!(ocr_recvd & (0x1 << 31)))
402024c8:	e3530000 	cmp	r3, #0
402024cc:	aa000030 	bge	40202594 <mmc_detect_card+0x1fc>
		return 0;

	if (mmc_card_cur->card_type == MMC_CARD) {
402024d0:	e5942000 	ldr	r2, [r4]
402024d4:	e3520000 	cmp	r2, #0
402024d8:	1a000005 	bne	402024f4 <mmc_detect_card+0x15c>
		if ((ocr_recvd & MMC_OCR_REG_ACCESS_MODE_MASK) ==
402024dc:	e2031206 	and	r1, r3, #1610612736	; 0x60000000
			mmc_card_cur->mode = SECTOR_MODE;
		} else {
			mmc_card_cur->mode = BYTE_MODE;
		}

		ocr_recvd &= ~MMC_OCR_REG_ACCESS_MODE_MASK;
402024e0:	e3c33206 	bic	r3, r3, #1610612736	; 0x60000000

	if (!(ocr_recvd & (0x1 << 31)))
		return 0;

	if (mmc_card_cur->card_type == MMC_CARD) {
		if ((ocr_recvd & MMC_OCR_REG_ACCESS_MODE_MASK) ==
402024e4:	e3510101 	cmp	r1, #1073741824	; 0x40000000
		    MMC_OCR_REG_ACCESS_MODE_SECTOR) {
			mmc_card_cur->mode = SECTOR_MODE;
402024e8:	02822001 	addeq	r2, r2, #1
		} else {
			mmc_card_cur->mode = BYTE_MODE;
402024ec:	e5842008 	str	r2, [r4, #8]
402024f0:	ea000003 	b	40202504 <mmc_detect_card+0x16c>
		}

		ocr_recvd &= ~MMC_OCR_REG_ACCESS_MODE_MASK;
	} else {
		if ((ocr_recvd & MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK)
402024f4:	e2132101 	ands	r2, r3, #1073741824	; 0x40000000
		    == MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR) {
			mmc_card_cur->mode = SECTOR_MODE;
		} else {
			mmc_card_cur->mode = BYTE_MODE;
		}
		ocr_recvd &= ~MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK;
402024f8:	e3c33101 	bic	r3, r3, #1073741824	; 0x40000000

		ocr_recvd &= ~MMC_OCR_REG_ACCESS_MODE_MASK;
	} else {
		if ((ocr_recvd & MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK)
		    == MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR) {
			mmc_card_cur->mode = SECTOR_MODE;
402024fc:	13a02001 	movne	r2, #1
		} else {
			mmc_card_cur->mode = BYTE_MODE;
40202500:	e5842008 	str	r2, [r4, #8]
		}
		ocr_recvd &= ~MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK;
	}

	ocr_recvd &= ~(0x1 << 31);
	if (!(ocr_recvd & ocr_value))
40202504:	e1150003 	tst	r5, r3
40202508:	0a000021 	beq	40202594 <mmc_detect_card+0x1fc>
		return 0;

	err = mmc_send_cmd(MMC_CMD2, argument, resp);
4020250c:	e59f00a4 	ldr	r0, [pc, #164]	; 402025b8 <mmc_detect_card+0x220>
40202510:	e1a01005 	mov	r1, r5
40202514:	e1a0200d 	mov	r2, sp
40202518:	e1a0600d 	mov	r6, sp
4020251c:	ebffff57 	bl	40202280 <mmc_send_cmd>
	if (err != 1)
40202520:	e3500001 	cmp	r0, #1
40202524:	1a00001b 	bne	40202598 <mmc_detect_card+0x200>
		return err;

	if (mmc_card_cur->card_type == MMC_CARD) {
40202528:	e5943000 	ldr	r3, [r4]
4020252c:	e3530000 	cmp	r3, #0
40202530:	1a000007 	bne	40202554 <mmc_detect_card+0x1bc>
		argument = mmc_card_cur->RCA << 16;
		err = mmc_send_cmd(MMC_CMD3, argument, resp);
40202534:	e5941010 	ldr	r1, [r4, #16]
40202538:	e1a0200d 	mov	r2, sp
4020253c:	e59f0078 	ldr	r0, [pc, #120]	; 402025bc <mmc_detect_card+0x224>
40202540:	e1a01801 	lsl	r1, r1, #16
40202544:	ebffff4d 	bl	40202280 <mmc_send_cmd>
		if (err != 1)
40202548:	e3500001 	cmp	r0, #1
4020254c:	1a000011 	bne	40202598 <mmc_detect_card+0x200>
40202550:	ea000007 	b	40202574 <mmc_detect_card+0x1dc>
			return err;
	} else {
		argument = 0x00000000;
		err = mmc_send_cmd(MMC_SDCMD3, argument, resp);
40202554:	e59f0060 	ldr	r0, [pc, #96]	; 402025bc <mmc_detect_card+0x224>
40202558:	e3a01000 	mov	r1, #0
4020255c:	e1a0200d 	mov	r2, sp
40202560:	ebffff46 	bl	40202280 <mmc_send_cmd>
		if (err != 1)
40202564:	e3500001 	cmp	r0, #1
40202568:	1a00000a 	bne	40202598 <mmc_detect_card+0x200>
			return err;

		mmc_card_cur->RCA = ((mmc_resp_r6 *) resp)->newpublishedrca;
4020256c:	e1dd30b2 	ldrh	r3, [sp, #2]
40202570:	e5843010 	str	r3, [r4, #16]
	}

	OMAP_HSMMC_CON &= ~OD;
40202574:	e59f3030 	ldr	r3, [pc, #48]	; 402025ac <mmc_detect_card+0x214>
	OMAP_HSMMC_CON |= NOOPENDRAIN;
40202578:	e3a00001 	mov	r0, #1
			return err;

		mmc_card_cur->RCA = ((mmc_resp_r6 *) resp)->newpublishedrca;
	}

	OMAP_HSMMC_CON &= ~OD;
4020257c:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
40202580:	e3c22001 	bic	r2, r2, #1
40202584:	e583202c 	str	r2, [r3, #44]	; 0x2c
	OMAP_HSMMC_CON |= NOOPENDRAIN;
40202588:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
4020258c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	return 1;
40202590:	ea000000 	b	40202598 <mmc_detect_card+0x200>
40202594:	e3a00000 	mov	r0, #0
}
40202598:	e28dd010 	add	sp, sp, #16
4020259c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
402025a0:	081a0000 	.word	0x081a0000
402025a4:	371a0000 	.word	0x371a0000
402025a8:	29020000 	.word	0x29020000
402025ac:	4809c000 	.word	0x4809c000
402025b0:	01020000 	.word	0x01020000
402025b4:	40ff8000 	.word	0x40ff8000
402025b8:	02090000 	.word	0x02090000
402025bc:	031a0000 	.word	0x031a0000

402025c0 <mmc_read_cardsize>:

unsigned char mmc_read_cardsize(mmc_card_data *mmc_dev_data,
				mmc_csd_reg_t *cur_csd)
{
402025c0:	e92d4010 	push	{r4, lr}
	mmc_extended_csd_reg_t ext_csd;
	unsigned int size, count, blk_len, blk_no, card_size, argument;
	unsigned char err;
	unsigned int resp[4];

	if (mmc_dev_data->mode == SECTOR_MODE) {
402025c4:	e5903008 	ldr	r3, [r0, #8]
	return 1;
}

unsigned char mmc_read_cardsize(mmc_card_data *mmc_dev_data,
				mmc_csd_reg_t *cur_csd)
{
402025c8:	e24dde21 	sub	sp, sp, #528	; 0x210
402025cc:	e1a04000 	mov	r4, r0
	mmc_extended_csd_reg_t ext_csd;
	unsigned int size, count, blk_len, blk_no, card_size, argument;
	unsigned char err;
	unsigned int resp[4];

	if (mmc_dev_data->mode == SECTOR_MODE) {
402025d0:	e3530001 	cmp	r3, #1
402025d4:	1a000018 	bne	4020263c <mmc_read_cardsize+0x7c>
		if (mmc_dev_data->card_type == SD_CARD) {
402025d8:	e5903000 	ldr	r3, [r0]
402025dc:	e3530001 	cmp	r3, #1
402025e0:	1a000005 	bne	402025fc <mmc_read_cardsize+0x3c>
			    (((mmc_sd2_csd_reg_t *) cur_csd)->
			     c_size_lsb & MMC_SD2_CSD_C_SIZE_LSB_MASK) |
			    ((((mmc_sd2_csd_reg_t *) cur_csd)->
			      c_size_msb & MMC_SD2_CSD_C_SIZE_MSB_MASK)
			     << MMC_SD2_CSD_C_SIZE_MSB_OFFSET);
			mmc_dev_data->size = card_size * 1024;
402025e4:	e5d10008 	ldrb	r0, [r1, #8]
402025e8:	e1d130b6 	ldrh	r3, [r1, #6]
402025ec:	e200003f 	and	r0, r0, #63	; 0x3f
402025f0:	e1830800 	orr	r0, r3, r0, lsl #16
402025f4:	e1a00500 	lsl	r0, r0, #10
402025f8:	ea000024 	b	40202690 <mmc_read_cardsize+0xd0>
			if (mmc_dev_data->size == 0)
				return 0;
		} else {
			argument = 0x00000000;
			err = mmc_send_cmd(MMC_CMD8, argument, resp);
402025fc:	e59f00a0 	ldr	r0, [pc, #160]	; 402026a4 <mmc_read_cardsize+0xe4>
40202600:	e3a01000 	mov	r1, #0
40202604:	e28d2c02 	add	r2, sp, #512	; 0x200
40202608:	ebffff1c 	bl	40202280 <mmc_send_cmd>
			if (err != 1)
4020260c:	e3500001 	cmp	r0, #1
40202610:	1a000021 	bne	4020269c <mmc_read_cardsize+0xdc>
				return err;
			err = mmc_read_data((unsigned int *)&ext_csd);
40202614:	e1a0000d 	mov	r0, sp
40202618:	ebffff3c 	bl	40202310 <mmc_read_data>
			if (err != 1)
4020261c:	e3500001 	cmp	r0, #1
40202620:	1a00001d 	bne	4020269c <mmc_read_cardsize+0xdc>
				return err;
			mmc_dev_data->size = ext_csd.sectorcount;
40202624:	e59d30d4 	ldr	r3, [sp, #212]	; 0xd4

			if (mmc_dev_data->size == 0)
40202628:	e3530000 	cmp	r3, #0
			if (err != 1)
				return err;
			err = mmc_read_data((unsigned int *)&ext_csd);
			if (err != 1)
				return err;
			mmc_dev_data->size = ext_csd.sectorcount;
4020262c:	e584300c 	str	r3, [r4, #12]

			if (mmc_dev_data->size == 0)
				mmc_dev_data->size = 8388608;
40202630:	02833502 	addeq	r3, r3, #8388608	; 0x800000
40202634:	0584300c 	streq	r3, [r4, #12]
40202638:	ea000017 	b	4020269c <mmc_read_cardsize+0xdc>
		}
	} else {
		if (cur_csd->c_size_mult >= 8)
			return 0;

		if (cur_csd->read_bl_len >= 12)
4020263c:	e5d1300a 	ldrb	r3, [r1, #10]

			if (mmc_dev_data->size == 0)
				mmc_dev_data->size = 8388608;
		}
	} else {
		if (cur_csd->c_size_mult >= 8)
40202640:	e5910004 	ldr	r0, [r1, #4]
			return 0;

		if (cur_csd->read_bl_len >= 12)
40202644:	e203300f 	and	r3, r3, #15
40202648:	e353000b 	cmp	r3, #11

			if (mmc_dev_data->size == 0)
				mmc_dev_data->size = 8388608;
		}
	} else {
		if (cur_csd->c_size_mult >= 8)
4020264c:	e7e207d0 	ubfx	r0, r0, #15, #3
			return 0;

		if (cur_csd->read_bl_len >= 12)
40202650:	c3a00000 	movgt	r0, #0
40202654:	ca000010 	bgt	4020269c <mmc_read_cardsize+0xdc>

		blk_no = (card_size + 1) * count;
		blk_len = 1 << cur_csd->read_bl_len;
		size = blk_no * blk_len;

		mmc_dev_data->size = size / MMCSD_SECTOR_SIZE;
40202658:	e3a02001 	mov	r2, #1
4020265c:	e2800002 	add	r0, r0, #2
40202660:	e1a00012 	lsl	r0, r2, r0
40202664:	e1a02312 	lsl	r2, r2, r3
40202668:	e1d130b8 	ldrh	r3, [r1, #8]
4020266c:	e0020092 	mul	r2, r2, r0
40202670:	e5d10007 	ldrb	r0, [r1, #7]
40202674:	e1a03b03 	lsl	r3, r3, #22
40202678:	e1a03b23 	lsr	r3, r3, #22
4020267c:	e1a00320 	lsr	r0, r0, #6
40202680:	e1800103 	orr	r0, r0, r3, lsl #2
40202684:	e2800001 	add	r0, r0, #1
40202688:	e0000290 	mul	r0, r0, r2
4020268c:	e1a004a0 	lsr	r0, r0, #9
40202690:	e584000c 	str	r0, [r4, #12]
40202694:	e2500000 	subs	r0, r0, #0
40202698:	13a00001 	movne	r0, #1
		if (mmc_dev_data->size == 0)
			return 0;
	}
	return 1;
}
4020269c:	e28dde21 	add	sp, sp, #528	; 0x210
402026a0:	e8bd8010 	pop	{r4, pc}
402026a4:	083a0010 	.word	0x083a0010

402026a8 <omap_mmc_read_sect>:

unsigned char omap_mmc_read_sect(unsigned int start_sec, unsigned int num_bytes,
				 mmc_card_data *mmc_c,
				 unsigned int *output_buf)
{
402026a8:	e92d40ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
	unsigned char err;
	unsigned int argument;
	unsigned int resp[4];
	unsigned int num_sec_val =
	    (num_bytes + (MMCSD_SECTOR_SIZE - 1)) / MMCSD_SECTOR_SIZE;
402026ac:	e2811f7f 	add	r1, r1, #508	; 0x1fc
402026b0:	e2811003 	add	r1, r1, #3
}

unsigned char omap_mmc_read_sect(unsigned int start_sec, unsigned int num_bytes,
				 mmc_card_data *mmc_c,
				 unsigned int *output_buf)
{
402026b4:	e1a06003 	mov	r6, r3
	unsigned int resp[4];
	unsigned int num_sec_val =
	    (num_bytes + (MMCSD_SECTOR_SIZE - 1)) / MMCSD_SECTOR_SIZE;
	unsigned int sec_inc_val;

	if (num_sec_val == 0)
402026b8:	e1b054a1 	lsrs	r5, r1, #9
		err = mmc_read_data(output_buf);
		if (err != 1)
			return err;

		output_buf += (MMCSD_SECTOR_SIZE / 4);
		argument += sec_inc_val;
402026bc:	03a00001 	moveq	r0, #1
	unsigned int resp[4];
	unsigned int num_sec_val =
	    (num_bytes + (MMCSD_SECTOR_SIZE - 1)) / MMCSD_SECTOR_SIZE;
	unsigned int sec_inc_val;

	if (num_sec_val == 0)
402026c0:	0a000012 	beq	40202710 <omap_mmc_read_sect+0x68>
		return 1;

	if (mmc_c->mode == SECTOR_MODE) {
402026c4:	e5927008 	ldr	r7, [r2, #8]
402026c8:	e3570001 	cmp	r7, #1
		argument = start_sec;
		sec_inc_val = 1;
	} else {
		argument = start_sec * MMCSD_SECTOR_SIZE;
402026cc:	11a04480 	lslne	r4, r0, #9
	unsigned int sec_inc_val;

	if (num_sec_val == 0)
		return 1;

	if (mmc_c->mode == SECTOR_MODE) {
402026d0:	01a04000 	moveq	r4, r0
		argument = start_sec;
		sec_inc_val = 1;
	} else {
		argument = start_sec * MMCSD_SECTOR_SIZE;
402026d4:	13a07c02 	movne	r7, #512	; 0x200
		sec_inc_val = MMCSD_SECTOR_SIZE;
	}

	while (num_sec_val) {
		err = mmc_send_cmd(MMC_CMD17, argument, resp);
402026d8:	e59f0038 	ldr	r0, [pc, #56]	; 40202718 <omap_mmc_read_sect+0x70>
402026dc:	e1a01004 	mov	r1, r4
402026e0:	e1a0200d 	mov	r2, sp
402026e4:	ebfffee5 	bl	40202280 <mmc_send_cmd>
		if (err != 1)
402026e8:	e3500001 	cmp	r0, #1
402026ec:	1a000007 	bne	40202710 <omap_mmc_read_sect+0x68>
			return err;


		err = mmc_read_data(output_buf);
402026f0:	e1a00006 	mov	r0, r6
402026f4:	ebffff05 	bl	40202310 <mmc_read_data>
		if (err != 1)
402026f8:	e3500001 	cmp	r0, #1
402026fc:	1a000003 	bne	40202710 <omap_mmc_read_sect+0x68>
	} else {
		argument = start_sec * MMCSD_SECTOR_SIZE;
		sec_inc_val = MMCSD_SECTOR_SIZE;
	}

	while (num_sec_val) {
40202700:	e2555001 	subs	r5, r5, #1

		err = mmc_read_data(output_buf);
		if (err != 1)
			return err;

		output_buf += (MMCSD_SECTOR_SIZE / 4);
40202704:	12866c02 	addne	r6, r6, #512	; 0x200
		argument += sec_inc_val;
40202708:	10844007 	addne	r4, r4, r7
4020270c:	1afffff1 	bne	402026d8 <omap_mmc_read_sect+0x30>
		num_sec_val--;
	}
	return 1;
}
40202710:	e28dd010 	add	sp, sp, #16
40202714:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
40202718:	113a0010 	.word	0x113a0010

4020271c <configure_mmc>:

unsigned char configure_mmc(mmc_card_data *mmc_card_cur)
{
4020271c:	e92d4030 	push	{r4, r5, lr}
40202720:	e24dd020 	sub	sp, sp, #32
40202724:	e1a04000 	mov	r4, r0
	unsigned int max_dtr;
	int dsor;
	volatile mmc_csd_reg_t Card_CSD;
	unsigned char trans_speed;

	mmc_init_setup();
40202728:	ebfffeaf 	bl	402021ec <mmc_init_setup>
4020272c:	e3a05002 	mov	r5, #2

	do {
		ret_val = mmc_detect_card(mmc_card_cur);
40202730:	e1a00004 	mov	r0, r4
40202734:	ebffff17 	bl	40202398 <mmc_detect_card>
		retries--;
	} while ((retries > 0) && (ret_val != 1));
40202738:	e2555001 	subs	r5, r5, #1
4020273c:	03a03000 	moveq	r3, #0
40202740:	13a03001 	movne	r3, #1
40202744:	e3500001 	cmp	r0, #1
40202748:	03a03000 	moveq	r3, #0
4020274c:	12033001 	andne	r3, r3, #1
40202750:	e3530000 	cmp	r3, #0
40202754:	1afffff5 	bne	40202730 <configure_mmc+0x14>

	argument = mmc_card_cur->RCA << 16;
	ret_val = mmc_send_cmd(MMC_CMD9, argument, resp);
40202758:	e5941010 	ldr	r1, [r4, #16]
4020275c:	e28d2010 	add	r2, sp, #16
40202760:	e59f0114 	ldr	r0, [pc, #276]	; 4020287c <configure_mmc+0x160>
40202764:	e1a01801 	lsl	r1, r1, #16
40202768:	ebfffec4 	bl	40202280 <mmc_send_cmd>
	//printf("              ");
	if (ret_val != 1)
4020276c:	e3500001 	cmp	r0, #1
40202770:	1a00003f 	bne	40202874 <configure_mmc+0x158>
		return ret_val;

	((unsigned int *)&Card_CSD)[3] = resp[3];
40202774:	e59d301c 	ldr	r3, [sp, #28]
	if (mmc_card_cur->card_type == MMC_CARD)
		mmc_card_cur->version = Card_CSD.spec_vers;

	trans_speed = Card_CSD.tran_speed;

	ret_val = mmc_send_cmd(MMC_CMD4, MMC_DSR_DEFAULT << 16, resp);
40202778:	e3a00301 	mov	r0, #67108864	; 0x4000000
4020277c:	e59f10fc 	ldr	r1, [pc, #252]	; 40202880 <configure_mmc+0x164>
40202780:	e28d2010 	add	r2, sp, #16
	ret_val = mmc_send_cmd(MMC_CMD9, argument, resp);
	//printf("              ");
	if (ret_val != 1)
		return ret_val;

	((unsigned int *)&Card_CSD)[3] = resp[3];
40202784:	e58d300c 	str	r3, [sp, #12]
	((unsigned int *)&Card_CSD)[2] = resp[2];
40202788:	e59d3018 	ldr	r3, [sp, #24]
4020278c:	e58d3008 	str	r3, [sp, #8]
	((unsigned int *)&Card_CSD)[1] = resp[1];
40202790:	e59d3014 	ldr	r3, [sp, #20]
40202794:	e58d3004 	str	r3, [sp, #4]
	((unsigned int *)&Card_CSD)[0] = resp[0];
40202798:	e59d3010 	ldr	r3, [sp, #16]
4020279c:	e58d3000 	str	r3, [sp]

	if (mmc_card_cur->card_type == MMC_CARD)
402027a0:	e5943000 	ldr	r3, [r4]
402027a4:	e3530000 	cmp	r3, #0
		mmc_card_cur->version = Card_CSD.spec_vers;
402027a8:	059d300c 	ldreq	r3, [sp, #12]

	trans_speed = Card_CSD.tran_speed;
402027ac:	e5dd500c 	ldrb	r5, [sp, #12]
	((unsigned int *)&Card_CSD)[2] = resp[2];
	((unsigned int *)&Card_CSD)[1] = resp[1];
	((unsigned int *)&Card_CSD)[0] = resp[0];

	if (mmc_card_cur->card_type == MMC_CARD)
		mmc_card_cur->version = Card_CSD.spec_vers;
402027b0:	07e33d53 	ubfxeq	r3, r3, #26, #4
402027b4:	05843004 	streq	r3, [r4, #4]

	trans_speed = Card_CSD.tran_speed;

	ret_val = mmc_send_cmd(MMC_CMD4, MMC_DSR_DEFAULT << 16, resp);
402027b8:	ebfffeb0 	bl	40202280 <mmc_send_cmd>
	//printf("              \n");
	if (ret_val != 1)
402027bc:	e3500001 	cmp	r0, #1
402027c0:	1a00002b 	bne	40202874 <configure_mmc+0x158>
		return ret_val;

	trans_unit = trans_speed & MMC_CSD_TRAN_SPEED_UNIT_MASK;
402027c4:	e2053007 	and	r3, r5, #7
	trans_fact = trans_speed & MMC_CSD_TRAN_SPEED_FACTOR_MASK;

	if (trans_unit > MMC_CSD_TRAN_SPEED_UNIT_100MHZ)
402027c8:	e3530003 	cmp	r3, #3
402027cc:	8a000027 	bhi	40202870 <configure_mmc+0x154>
	//printf("              \n");
	if (ret_val != 1)
		return ret_val;

	trans_unit = trans_speed & MMC_CSD_TRAN_SPEED_UNIT_MASK;
	trans_fact = trans_speed & MMC_CSD_TRAN_SPEED_FACTOR_MASK;
402027d0:	e2055078 	and	r5, r5, #120	; 0x78

	if (trans_unit > MMC_CSD_TRAN_SPEED_UNIT_100MHZ)
		return 0;

	if ((trans_fact < MMC_CSD_TRAN_SPEED_FACTOR_1_0) ||
402027d4:	e2452008 	sub	r2, r5, #8
402027d8:	e3520070 	cmp	r2, #112	; 0x70
402027dc:	8a000023 	bhi	40202870 <configure_mmc+0x154>

	trans_unit >>= 0;
	trans_fact >>= 3;

	max_dtr = tran_exp[trans_unit] * tran_mant[trans_fact];
	dsor = OMAP_MMC_MASTER_CLOCK / max_dtr;
402027e0:	e59f109c 	ldr	r1, [pc, #156]	; 40202884 <configure_mmc+0x168>
402027e4:	e59f009c 	ldr	r0, [pc, #156]	; 40202888 <configure_mmc+0x16c>
402027e8:	e0813103 	add	r3, r1, r3, lsl #2
402027ec:	e7d121a5 	ldrb	r2, [r1, r5, lsr #3]
402027f0:	e5931010 	ldr	r1, [r3, #16]
402027f4:	e0010291 	mul	r1, r1, r2
402027f8:	eb00004e 	bl	40202938 <__udivsi3>

	if (dsor == 4)
402027fc:	e3500004 	cmp	r0, #4

	trans_unit >>= 0;
	trans_fact >>= 3;

	max_dtr = tran_exp[trans_unit] * tran_mant[trans_fact];
	dsor = OMAP_MMC_MASTER_CLOCK / max_dtr;
40202800:	e1a01000 	mov	r1, r0

	if (dsor == 4)
40202804:	02801001 	addeq	r1, r0, #1
40202808:	0a000001 	beq	40202814 <configure_mmc+0xf8>
		dsor = 5;
	if (dsor == 3)
4020280c:	e3510003 	cmp	r1, #3
40202810:	03a01004 	moveq	r1, #4
		dsor = 4;

	ret_val = mmc_clock_config(CLK_MISC, dsor);
40202814:	e3a00002 	mov	r0, #2
40202818:	e6ff1071 	uxth	r1, r1
4020281c:	ebfffe4e 	bl	4020215c <mmc_clock_config>
	if (ret_val != 1)
40202820:	e3500001 	cmp	r0, #1
40202824:	1a000012 	bne	40202874 <configure_mmc+0x158>
		return ret_val;

	argument = mmc_card_cur->RCA << 16;
	ret_val = mmc_send_cmd(MMC_CMD7_SELECT, argument, resp);
40202828:	e5941010 	ldr	r1, [r4, #16]
4020282c:	e28d5010 	add	r5, sp, #16
40202830:	e59f0054 	ldr	r0, [pc, #84]	; 4020288c <configure_mmc+0x170>
40202834:	e1a02005 	mov	r2, r5
40202838:	e1a01801 	lsl	r1, r1, #16
4020283c:	ebfffe8f 	bl	40202280 <mmc_send_cmd>
	if (ret_val != 1)
40202840:	e3500001 	cmp	r0, #1
40202844:	1a00000a 	bne	40202874 <configure_mmc+0x158>
		return ret_val;

	/* Configure the block length to 512 bytes */
	argument = MMCSD_SECTOR_SIZE;
	ret_val = mmc_send_cmd(MMC_CMD16, argument, resp);
40202848:	e59f0040 	ldr	r0, [pc, #64]	; 40202890 <configure_mmc+0x174>
4020284c:	e3a01c02 	mov	r1, #512	; 0x200
40202850:	e1a02005 	mov	r2, r5
40202854:	ebfffe89 	bl	40202280 <mmc_send_cmd>
	if (ret_val != 1)
40202858:	e3500001 	cmp	r0, #1
4020285c:	1a000004 	bne	40202874 <configure_mmc+0x158>
		return ret_val;

	/* get the card size in sectors */
	ret_val = mmc_read_cardsize(mmc_card_cur, (mmc_csd_reg_t *)&Card_CSD);
40202860:	e1a00004 	mov	r0, r4
40202864:	e1a0100d 	mov	r1, sp
40202868:	ebffff54 	bl	402025c0 <mmc_read_cardsize>
4020286c:	ea000000 	b	40202874 <configure_mmc+0x158>
40202870:	e3a00000 	mov	r0, #0
	if (ret_val != 1)
		return ret_val;

	return 1;
}
40202874:	e28dd020 	add	sp, sp, #32
40202878:	e8bd8030 	pop	{r4, r5, pc}
4020287c:	09090000 	.word	0x09090000
40202880:	04040000 	.word	0x04040000
40202884:	40204930 	.word	0x40204930
40202888:	05b8d800 	.word	0x05b8d800
4020288c:	071b0000 	.word	0x071b0000
40202890:	101a0000 	.word	0x101a0000

40202894 <mmc_bread>:

unsigned long mmc_bread(int dev_num, ulong blknr, ulong blkcnt, ulong *dst)
{
40202894:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	unsigned long ret;
	ret = omap_mmc_read_sect(blknr, (blkcnt * MMCSD_SECTOR_SIZE),
40202898:	e1a00001 	mov	r0, r1
4020289c:	e1a01482 	lsl	r1, r2, #9
402028a0:	e59f2004 	ldr	r2, [pc, #4]	; 402028ac <mmc_bread+0x18>
402028a4:	ebffff7f 	bl	402026a8 <omap_mmc_read_sect>
			&cur_card_data, (unsigned int *)dst);
	return ret;
}
402028a8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
402028ac:	40204fd4 	.word	0x40204fd4

402028b0 <mmc_read>:
{
	/*
	 * NOT Implemented
	 */
	return 0;
}
402028b0:	e3a00000 	mov	r0, #0
402028b4:	e12fff1e 	bx	lr

402028b8 <mmc_write>:
{
	/*
	 * NOT Implemented
	 */
	return 0;
}
402028b8:	e3a00000 	mov	r0, #0
402028bc:	e12fff1e 	bx	lr

402028c0 <mmc2info>:
{
	/*
	 * NOT Implemented
	 */
	return 0;
}
402028c0:	e3a00000 	mov	r0, #0
402028c4:	e12fff1e 	bx	lr

402028c8 <mmc_init>:
			&cur_card_data, (unsigned int *)dst);
	return ret;
}

int mmc_init(int verbose)
{
402028c8:	e92d4010 	push	{r4, lr}
	unsigned char ret = 0;

	ret = configure_mmc(&cur_card_data);
402028cc:	e59f405c 	ldr	r4, [pc, #92]	; 40202930 <mmc_init+0x68>
402028d0:	e2840064 	add	r0, r4, #100	; 0x64
402028d4:	ebffff90 	bl	4020271c <configure_mmc>
	if (ret == 0)
402028d8:	e3500000 	cmp	r0, #0
402028dc:	08bd8010 	popeq	{r4, pc}
		return 0;

	mmc_blk_dev.if_type = IF_TYPE_MMC;
402028e0:	e3a03006 	mov	r3, #6
402028e4:	e5843000 	str	r3, [r4]
	mmc_blk_dev.part_type = PART_TYPE_DOS;
402028e8:	e3a03002 	mov	r3, #2
402028ec:	e5c43008 	strb	r3, [r4, #8]
	mmc_blk_dev.dev = 0;
402028f0:	e3a03000 	mov	r3, #0
402028f4:	e5843004 	str	r3, [r4, #4]
	mmc_blk_dev.lun = 0;
402028f8:	e5c4300a 	strb	r3, [r4, #10]
	mmc_blk_dev.blksz = MMCSD_SECTOR_SIZE;
	mmc_blk_dev.lba = 0x10000;
	mmc_blk_dev.removable = 0;
	mmc_blk_dev.block_read = mmc_bread;

	fat_register_device(&mmc_blk_dev, 1);
402028fc:	e1a00004 	mov	r0, r4

	mmc_blk_dev.if_type = IF_TYPE_MMC;
	mmc_blk_dev.part_type = PART_TYPE_DOS;
	mmc_blk_dev.dev = 0;
	mmc_blk_dev.lun = 0;
	mmc_blk_dev.type = 0;
40202900:	e5c4300b 	strb	r3, [r4, #11]
	mmc_blk_dev.blksz = MMCSD_SECTOR_SIZE;
	mmc_blk_dev.lba = 0x10000;
	mmc_blk_dev.removable = 0;
	mmc_blk_dev.block_read = mmc_bread;

	fat_register_device(&mmc_blk_dev, 1);
40202904:	e3a01001 	mov	r1, #1
	mmc_blk_dev.type = 0;

	/* FIXME fill in the correct size (is set to 32MByte) */
	mmc_blk_dev.blksz = MMCSD_SECTOR_SIZE;
	mmc_blk_dev.lba = 0x10000;
	mmc_blk_dev.removable = 0;
40202908:	e5c4300c 	strb	r3, [r4, #12]
	mmc_blk_dev.dev = 0;
	mmc_blk_dev.lun = 0;
	mmc_blk_dev.type = 0;

	/* FIXME fill in the correct size (is set to 32MByte) */
	mmc_blk_dev.blksz = MMCSD_SECTOR_SIZE;
4020290c:	e3a02c02 	mov	r2, #512	; 0x200
	mmc_blk_dev.lba = 0x10000;
	mmc_blk_dev.removable = 0;
	mmc_blk_dev.block_read = mmc_bread;
40202910:	e59f301c 	ldr	r3, [pc, #28]	; 40202934 <mmc_init+0x6c>
	mmc_blk_dev.dev = 0;
	mmc_blk_dev.lun = 0;
	mmc_blk_dev.type = 0;

	/* FIXME fill in the correct size (is set to 32MByte) */
	mmc_blk_dev.blksz = MMCSD_SECTOR_SIZE;
40202914:	e5842014 	str	r2, [r4, #20]
	mmc_blk_dev.lba = 0x10000;
40202918:	e2822cfe 	add	r2, r2, #65024	; 0xfe00
4020291c:	e5842010 	str	r2, [r4, #16]
	mmc_blk_dev.removable = 0;
	mmc_blk_dev.block_read = mmc_bread;
40202920:	e5843060 	str	r3, [r4, #96]	; 0x60

	fat_register_device(&mmc_blk_dev, 1);
40202924:	eb0002ea 	bl	402034d4 <fat_register_device>
40202928:	e3a00001 	mov	r0, #1

	return 1;
}
4020292c:	e8bd8010 	pop	{r4, pc}
40202930:	40204f70 	.word	0x40204f70
40202934:	40202894 	.word	0x40202894

40202938 <__udivsi3>:
	.text
	.globl	 __udivsi3
	.type  __udivsi3       ,function
	.align	0
 __udivsi3      :
	cmp	divisor, #0
40202938:	e3510000 	cmp	r1, #0
	beq	Ldiv0
4020293c:	0a00001f 	beq	402029c0 <Ldiv0>
	mov	curbit, #1
40202940:	e3a03001 	mov	r3, #1
	mov	result, #0
40202944:	e3a02000 	mov	r2, #0
	cmp	dividend, divisor
40202948:	e1500001 	cmp	r0, r1
	bcc	Lgot_result
4020294c:	3a000019 	bcc	402029b8 <Lgot_result>

40202950 <Loop1>:
Loop1:
	@ Unless the divisor is very big, shift it up in multiples of
	@ four bits, since this is the amount of unwinding in the main
	@ division loop.  Continue shifting until the divisor is
	@ larger than the dividend.
	cmp	divisor, #0x10000000
40202950:	e3510201 	cmp	r1, #268435456	; 0x10000000
	cmpcc	divisor, dividend
40202954:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #4
40202958:	31a01201 	lslcc	r1, r1, #4
	movcc	curbit, curbit, lsl #4
4020295c:	31a03203 	lslcc	r3, r3, #4
	bcc	Loop1
40202960:	3afffffa 	bcc	40202950 <Loop1>

40202964 <Lbignum>:
Lbignum:
	@ For very big divisors, we must shift it a bit at a time, or
	@ we will be in danger of overflowing.
	cmp	divisor, #0x80000000
40202964:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
	cmpcc	divisor, dividend
40202968:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #1
4020296c:	31a01081 	lslcc	r1, r1, #1
	movcc	curbit, curbit, lsl #1
40202970:	31a03083 	lslcc	r3, r3, #1
	bcc	Lbignum
40202974:	3afffffa 	bcc	40202964 <Lbignum>

40202978 <Loop3>:
Loop3:
	@ Test for possible subtractions, and note which bits
	@ are done in the result.  On the final pass, this may subtract
	@ too much from the dividend, but the result will be ok, since the
	@ "bit" will have been shifted out at the bottom.
	cmp	dividend, divisor
40202978:	e1500001 	cmp	r0, r1
	subcs	dividend, dividend, divisor
4020297c:	20400001 	subcs	r0, r0, r1
	orrcs	result, result, curbit
40202980:	21822003 	orrcs	r2, r2, r3
	cmp	dividend, divisor, lsr #1
40202984:	e15000a1 	cmp	r0, r1, lsr #1
	subcs	dividend, dividend, divisor, lsr #1
40202988:	204000a1 	subcs	r0, r0, r1, lsr #1
	orrcs	result, result, curbit, lsr #1
4020298c:	218220a3 	orrcs	r2, r2, r3, lsr #1
	cmp	dividend, divisor, lsr #2
40202990:	e1500121 	cmp	r0, r1, lsr #2
	subcs	dividend, dividend, divisor, lsr #2
40202994:	20400121 	subcs	r0, r0, r1, lsr #2
	orrcs	result, result, curbit, lsr #2
40202998:	21822123 	orrcs	r2, r2, r3, lsr #2
	cmp	dividend, divisor, lsr #3
4020299c:	e15001a1 	cmp	r0, r1, lsr #3
	subcs	dividend, dividend, divisor, lsr #3
402029a0:	204001a1 	subcs	r0, r0, r1, lsr #3
	orrcs	result, result, curbit, lsr #3
402029a4:	218221a3 	orrcs	r2, r2, r3, lsr #3
	cmp	dividend, #0			@ Early termination?
402029a8:	e3500000 	cmp	r0, #0
	movnes	curbit, curbit, lsr #4		@ No, any more bits to do?
402029ac:	11b03223 	lsrsne	r3, r3, #4
	movne	divisor, divisor, lsr #4
402029b0:	11a01221 	lsrne	r1, r1, #4
	bne	Loop3
402029b4:	1affffef 	bne	40202978 <Loop3>

402029b8 <Lgot_result>:
Lgot_result:
	mov	r0, result
402029b8:	e1a00002 	mov	r0, r2
	mov 	pc, lr
402029bc:	e1a0f00e 	mov	pc, lr

402029c0 <Ldiv0>:
Ldiv0:
	str	lr, [sp, #-4]!
402029c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	bl	 __div0       (PLT)
402029c4:	eb0001ee 	bl	40203184 <__div0>
	mov	r0, #0			@ about as wrong as it could be
402029c8:	e3a00000 	mov	r0, #0
	ldmia	sp!, {pc}
402029cc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

402029d0 <hang>:

	/* should never come here */
}

void hang (void)
{
402029d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	/* call board specific hang function */
	board_hang();
402029d4:	ebfffb30 	bl	4020169c <board_hang>

	/* if board_hang() returns, hange here */
	printf("X-Loader hangs\n");
402029d8:	e59f0004 	ldr	r0, [pc, #4]	; 402029e4 <hang+0x14>
402029dc:	eb0000ea 	bl	40202d8c <serial_printf>
402029e0:	eafffffe 	b	402029e0 <hang+0x10>
402029e4:	40204b18 	.word	0x40204b18

402029e8 <start_armboot>:
  	//nand_init,		/* board specific nand init */
  	NULL,
};

void start_armboot (void)
{
402029e8:	e92d4030 	push	{r4, r5, lr}
402029ec:	e3a04000 	mov	r4, #0
  	init_fnc_t **init_fnc_ptr;
 	int i;
	uchar *buf;


   	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
402029f0:	ea000003 	b	40202a04 <start_armboot+0x1c>
		if ((*init_fnc_ptr)() != 0) {
402029f4:	e12fff33 	blx	r3
402029f8:	e2844004 	add	r4, r4, #4
402029fc:	e3500000 	cmp	r0, #0
40202a00:	1a000020 	bne	40202a88 <start_armboot+0xa0>
  	init_fnc_t **init_fnc_ptr;
 	int i;
	uchar *buf;


   	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
40202a04:	e59f3090 	ldr	r3, [pc, #144]	; 40202a9c <start_armboot+0xb4>
40202a08:	e7933004 	ldr	r3, [r3, r4]
40202a0c:	e3530000 	cmp	r3, #0
40202a10:	1afffff7 	bne	402029f4 <start_armboot+0xc>
	printf("buf = 0x%x\n",*(buf + 1) );
	printf("buf = 0x%x\n",*(buf + 2) );
	printf("buf = 0x%x\n",*(buf + 3)  );*/


	misc_init_r();
40202a14:	ebfffa45 	bl	40201330 <misc_init_r>
	buf =  (uchar*) CFG_LOADADDR;

	if ((get_mem_type() == MMC_ONENAND) || (get_mem_type() == MMC_NAND)){
40202a18:	ebfff92d 	bl	40200ed4 <get_mem_type>
40202a1c:	e3500005 	cmp	r0, #5
40202a20:	0a000003 	beq	40202a34 <start_armboot+0x4c>
40202a24:	ebfff92a 	bl	40200ed4 <get_mem_type>
40202a28:	e3500004 	cmp	r0, #4
40202a2c:	159f406c 	ldrne	r4, [pc, #108]	; 40202aa0 <start_armboot+0xb8>
40202a30:	1a000005 	bne	40202a4c <start_armboot+0x64>
		// kai-2010/0910
		printf("mmc boot...\n");
40202a34:	e59f0068 	ldr	r0, [pc, #104]	; 40202aa4 <start_armboot+0xbc>
40202a38:	eb0000d3 	bl	40202d8c <serial_printf>
		buf += mmc_boot(buf);
40202a3c:	e59f005c 	ldr	r0, [pc, #92]	; 40202aa0 <start_armboot+0xb8>
40202a40:	ebfffb16 	bl	402016a0 <mmc_boot>
40202a44:	e2804102 	add	r4, r0, #-2147483648	; 0x80000000
40202a48:	e2844902 	add	r4, r4, #32768	; 0x8000
	}

	if (get_mem_type() == GPMC_ONENAND){
40202a4c:	ebfff920 	bl	40200ed4 <get_mem_type>
40202a50:	e3500003 	cmp	r0, #3
40202a54:	1a000008 	bne	40202a7c <start_armboot+0x94>
40202a58:	e3a05004 	mov	r5, #4
		for (i = ONENAND_START_BLOCK; i < ONENAND_END_BLOCK; i++){
			if (!onenand_read_block(buf, i))
40202a5c:	e1a00004 	mov	r0, r4
40202a60:	e1a01005 	mov	r1, r5
40202a64:	eb0005b3 	bl	40204138 <onenand_read_block>
		printf("mmc boot...\n");
		buf += mmc_boot(buf);
	}

	if (get_mem_type() == GPMC_ONENAND){
		for (i = ONENAND_START_BLOCK; i < ONENAND_END_BLOCK; i++){
40202a68:	e2855001 	add	r5, r5, #1
			if (!onenand_read_block(buf, i))
40202a6c:	e3500000 	cmp	r0, #0
				buf += ONENAND_BLOCK_SIZE;
40202a70:	02844802 	addeq	r4, r4, #131072	; 0x20000
		printf("mmc boot...\n");
		buf += mmc_boot(buf);
	}

	if (get_mem_type() == GPMC_ONENAND){
		for (i = ONENAND_START_BLOCK; i < ONENAND_END_BLOCK; i++){
40202a74:	e3550012 	cmp	r5, #18
40202a78:	1afffff7 	bne	40202a5c <start_armboot+0x74>
		//}
	//}
	


	if (buf == (uchar *)CFG_LOADADDR)
40202a7c:	e59f501c 	ldr	r5, [pc, #28]	; 40202aa0 <start_armboot+0xb8>
40202a80:	e1540005 	cmp	r4, r5
40202a84:	1a000000 	bne	40202a8c <start_armboot+0xa4>
		hang();
40202a88:	ebffffd0 	bl	402029d0 <hang>

	/* go run U-Boot and never return */
  	printf("Starting OS Bootloader...\n");
40202a8c:	e59f0014 	ldr	r0, [pc, #20]	; 40202aa8 <start_armboot+0xc0>
40202a90:	eb0000bd 	bl	40202d8c <serial_printf>
 	((init_fnc_t *)CFG_LOADADDR)();
40202a94:	e12fff35 	blx	r5

	/* should never come here */
}
40202a98:	e8bd8030 	pop	{r4, r5, pc}
40202a9c:	40204f50 	.word	0x40204f50
40202aa0:	80008000 	.word	0x80008000
40202aa4:	40204b28 	.word	0x40204b28
40202aa8:	40204b35 	.word	0x40204b35

40202aac <print_info>:
extern int misc_init_r (void);
extern u32 get_mem_type(void);

#ifdef CFG_PRINTF
int print_info(void)
{
40202aac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	printf("\n\nTexas Instruments X-Loader 1.46 ("
40202ab0:	e59f0020 	ldr	r0, [pc, #32]	; 40202ad8 <print_info+0x2c>
40202ab4:	eb0000b4 	bl	40202d8c <serial_printf>
			__DATE__ " - " __TIME__ ")\n");
	printf("Apexx Technology\n");
40202ab8:	e59f001c 	ldr	r0, [pc, #28]	; 40202adc <print_info+0x30>
40202abc:	eb0000b2 	bl	40202d8c <serial_printf>
	//kai-2010/09/10
	u32   mem_type = get_sysboot_value();
40202ac0:	ebfff8fe 	bl	40200ec0 <get_sysboot_value>
40202ac4:	e1a01000 	mov	r1, r0
	printf("Apexx_sysboot : 0x%x\n",mem_type);
40202ac8:	e59f0010 	ldr	r0, [pc, #16]	; 40202ae0 <print_info+0x34>
40202acc:	eb0000ae 	bl	40202d8c <serial_printf>

	return 0;
}
40202ad0:	e3a00000 	mov	r0, #0
40202ad4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
40202ad8:	40204b50 	.word	0x40204b50
40202adc:	40204b8c 	.word	0x40204b8c
40202ae0:	40204b9e 	.word	0x40204b9e

40202ae4 <strnlen>:
 
/* we use this so that we can do without the ctype library */
#define is_digit(c)	((c) >= '0' && (c) <= '9')

size_t strnlen(const char * s, size_t count)
{
40202ae4:	e3a03000 	mov	r3, #0
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
40202ae8:	e1510003 	cmp	r1, r3
40202aec:	e0832000 	add	r2, r3, r0
40202af0:	0a000003 	beq	40202b04 <strnlen+0x20>
40202af4:	e7d0c003 	ldrb	ip, [r0, r3]
40202af8:	e2833001 	add	r3, r3, #1
40202afc:	e35c0000 	cmp	ip, #0
40202b00:	1afffff8 	bne	40202ae8 <strnlen+0x4>
		/* nothing */;
	return sc - s;
}
40202b04:	e0600002 	rsb	r0, r0, r2
40202b08:	e12fff1e 	bx	lr

40202b0c <skip_atoi>:

static int skip_atoi(const char **s)
{
40202b0c:	e3a03000 	mov	r3, #0
	int i=0;

	while (is_digit(**s))
40202b10:	ea000003 	b	40202b24 <skip_atoi+0x18>
		i = i*10 + *((*s)++) - '0';
40202b14:	e3a0c00a 	mov	ip, #10
40202b18:	e2811001 	add	r1, r1, #1
40202b1c:	e023239c 	mla	r3, ip, r3, r2
40202b20:	e5801000 	str	r1, [r0]

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
40202b24:	e5901000 	ldr	r1, [r0]
40202b28:	e5d12000 	ldrb	r2, [r1]
40202b2c:	e2422030 	sub	r2, r2, #48	; 0x30
40202b30:	e6efc072 	uxtb	ip, r2
40202b34:	e35c0009 	cmp	ip, #9
40202b38:	9afffff5 	bls	40202b14 <skip_atoi+0x8>
		i = i*10 + *((*s)++) - '0';
	return i;
}
40202b3c:	e1a00003 	mov	r0, r3
40202b40:	e12fff1e 	bx	lr

40202b44 <number>:
n = ((unsigned long) n) / (unsigned) base; \
__res; })

static char * number(char * str, long num, int base, int size, int precision
	,int type)
{
40202b44:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
40202b48:	e24dd054 	sub	sp, sp, #84	; 0x54
40202b4c:	e1a06002 	mov	r6, r2
40202b50:	e1a0a003 	mov	sl, r3
40202b54:	e59d7078 	ldr	r7, [sp, #120]	; 0x78
40202b58:	e1a04000 	mov	r4, r0
	char c,sign,tmp[66];
	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
	int i;

	if (type & LARGE)
40202b5c:	e59f3220 	ldr	r3, [pc, #544]	; 40202d84 <number+0x240>
n = ((unsigned long) n) / (unsigned) base; \
__res; })

static char * number(char * str, long num, int base, int size, int precision
	,int type)
{
40202b60:	e1a05001 	mov	r5, r1
	char c,sign,tmp[66];
	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
	int i;

	if (type & LARGE)
40202b64:	e59f221c 	ldr	r2, [pc, #540]	; 40202d88 <number+0x244>
40202b68:	e3170040 	tst	r7, #64	; 0x40
40202b6c:	01a02003 	moveq	r2, r3
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	if (type & LEFT)
40202b70:	e3170010 	tst	r7, #16
		type &= ~ZEROPAD;
	if (base < 2 || base > 36)
40202b74:	e2463002 	sub	r3, r6, #2
	int i;

	if (type & LARGE)
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	if (type & LEFT)
		type &= ~ZEROPAD;
40202b78:	13c77001 	bicne	r7, r7, #1
	if (base < 2 || base > 36)
40202b7c:	e3530022 	cmp	r3, #34	; 0x22
40202b80:	83a00000 	movhi	r0, #0
40202b84:	8a00007c 	bhi	40202d7c <number+0x238>
		return 0;
	c = (type & ZEROPAD) ? '0' : ' ';
40202b88:	e3170001 	tst	r7, #1
40202b8c:	13a03030 	movne	r3, #48	; 0x30
40202b90:	03a03020 	moveq	r3, #32
	sign = 0;
	if (type & SIGN) {
40202b94:	e3170002 	tst	r7, #2
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	if (type & LEFT)
		type &= ~ZEROPAD;
	if (base < 2 || base > 36)
		return 0;
	c = (type & ZEROPAD) ? '0' : ' ';
40202b98:	e58d300c 	str	r3, [sp, #12]
	sign = 0;
	if (type & SIGN) {
40202b9c:	0a00000c 	beq	40202bd4 <number+0x90>
		if (num < 0) {
40202ba0:	e3510000 	cmp	r1, #0
			sign = '-';
			num = -num;
40202ba4:	b2615000 	rsblt	r5, r1, #0
			size--;
40202ba8:	b24aa001 	sublt	sl, sl, #1
40202bac:	b3a0b02d 	movlt	fp, #45	; 0x2d
40202bb0:	ba000008 	blt	40202bd8 <number+0x94>
		} else if (type & PLUS) {
40202bb4:	e3170004 	tst	r7, #4
			sign = '+';
			size--;
40202bb8:	124aa001 	subne	sl, sl, #1
40202bbc:	13a0b02b 	movne	fp, #43	; 0x2b
	if (type & SIGN) {
		if (num < 0) {
			sign = '-';
			num = -num;
			size--;
		} else if (type & PLUS) {
40202bc0:	1a000004 	bne	40202bd8 <number+0x94>
			sign = '+';
			size--;
		} else if (type & SPACE) {
40202bc4:	e3170008 	tst	r7, #8
			sign = ' ';
			size--;
40202bc8:	124aa001 	subne	sl, sl, #1
40202bcc:	13a0b020 	movne	fp, #32
			num = -num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
			size--;
		} else if (type & SPACE) {
40202bd0:	1a000000 	bne	40202bd8 <number+0x94>
			sign = ' ';
			size--;
40202bd4:	e3a0b000 	mov	fp, #0
		}
	}
	if (type & SPECIAL) {
40202bd8:	e217c020 	ands	ip, r7, #32
40202bdc:	0a000004 	beq	40202bf4 <number+0xb0>
		if (base == 16)
40202be0:	e3560010 	cmp	r6, #16
			size -= 2;
40202be4:	024aa002 	subeq	sl, sl, #2
			sign = ' ';
			size--;
		}
	}
	if (type & SPECIAL) {
		if (base == 16)
40202be8:	0a000001 	beq	40202bf4 <number+0xb0>
			size -= 2;
		else if (base == 8)
40202bec:	e3560008 	cmp	r6, #8
			size--;
40202bf0:	024aa001 	subeq	sl, sl, #1
	}
	i = 0;
	if (num == 0)
40202bf4:	e3550000 	cmp	r5, #0
		tmp[i++]='0';
40202bf8:	03a03030 	moveq	r3, #48	; 0x30
40202bfc:	03a09001 	moveq	r9, #1
40202c00:	05cd3010 	strbeq	r3, [sp, #16]
			size -= 2;
		else if (base == 8)
			size--;
	}
	i = 0;
	if (num == 0)
40202c04:	0a000013 	beq	40202c58 <number+0x114>
		tmp[i++]='0';
40202c08:	e3a09000 	mov	r9, #0
	else while (num != 0)
		tmp[i++] = digits[do_div(num,base)];
40202c0c:	e1a00005 	mov	r0, r5
40202c10:	e1a01006 	mov	r1, r6
40202c14:	e58d2004 	str	r2, [sp, #4]
40202c18:	e58dc000 	str	ip, [sp]
40202c1c:	e58d5008 	str	r5, [sp, #8]
40202c20:	ebffff44 	bl	40202938 <__udivsi3>
40202c24:	e59d3008 	ldr	r3, [sp, #8]
40202c28:	e1a01006 	mov	r1, r6
40202c2c:	e1a05000 	mov	r5, r0
40202c30:	e1a00003 	mov	r0, r3
40202c34:	eb000153 	bl	40203188 <__umodsi3>
40202c38:	e59d2004 	ldr	r2, [sp, #4]
40202c3c:	e28d3010 	add	r3, sp, #16
			size--;
	}
	i = 0;
	if (num == 0)
		tmp[i++]='0';
	else while (num != 0)
40202c40:	e3550000 	cmp	r5, #0
		tmp[i++] = digits[do_div(num,base)];
40202c44:	e7d21000 	ldrb	r1, [r2, r0]
40202c48:	e7c31009 	strb	r1, [r3, r9]
40202c4c:	e2899001 	add	r9, r9, #1
			size--;
	}
	i = 0;
	if (num == 0)
		tmp[i++]='0';
	else while (num != 0)
40202c50:	e59dc000 	ldr	ip, [sp]
40202c54:	1affffec 	bne	40202c0c <number+0xc8>
40202c58:	e59d1074 	ldr	r1, [sp, #116]	; 0x74
40202c5c:	e1590001 	cmp	r9, r1
40202c60:	a1a01009 	movge	r1, r9
40202c64:	b1a01001 	movlt	r1, r1
		tmp[i++] = digits[do_div(num,base)];
	if (i > precision)
		precision = i;
	size -= precision;
	if (!(type&(ZEROPAD+LEFT)))
40202c68:	e3170011 	tst	r7, #17
		tmp[i++]='0';
	else while (num != 0)
		tmp[i++] = digits[do_div(num,base)];
	if (i > precision)
		precision = i;
	size -= precision;
40202c6c:	e061a00a 	rsb	sl, r1, sl
	if (!(type&(ZEROPAD+LEFT)))
40202c70:	01a03004 	moveq	r3, r4
40202c74:	0a000002 	beq	40202c84 <number+0x140>
40202c78:	ea000007 	b	40202c9c <number+0x158>
		while(size-->0)
			*str++ = ' ';
40202c7c:	e3a00020 	mov	r0, #32
40202c80:	e5430001 	strb	r0, [r3, #-1]
		tmp[i++] = digits[do_div(num,base)];
	if (i > precision)
		precision = i;
	size -= precision;
	if (!(type&(ZEROPAD+LEFT)))
		while(size-->0)
40202c84:	e24aa001 	sub	sl, sl, #1
			*str++ = ' ';
40202c88:	e1a04003 	mov	r4, r3
int __res; \
__res = ((unsigned long) n) % (unsigned) base; \
n = ((unsigned long) n) / (unsigned) base; \
__res; })

static char * number(char * str, long num, int base, int size, int precision
40202c8c:	e28a0001 	add	r0, sl, #1
		tmp[i++] = digits[do_div(num,base)];
	if (i > precision)
		precision = i;
	size -= precision;
	if (!(type&(ZEROPAD+LEFT)))
		while(size-->0)
40202c90:	e2833001 	add	r3, r3, #1
40202c94:	e3500000 	cmp	r0, #0
40202c98:	cafffff7 	bgt	40202c7c <number+0x138>
			*str++ = ' ';
	if (sign)
40202c9c:	e35b0000 	cmp	fp, #0
		*str++ = sign;
40202ca0:	14c4b001 	strbne	fp, [r4], #1
	if (type & SPECIAL) {
40202ca4:	e35c0000 	cmp	ip, #0
40202ca8:	0a00000b 	beq	40202cdc <number+0x198>
		if (base==8)
40202cac:	e3560008 	cmp	r6, #8
			*str++ = '0';
40202cb0:	03a03030 	moveq	r3, #48	; 0x30
40202cb4:	04c43001 	strbeq	r3, [r4], #1
		while(size-->0)
			*str++ = ' ';
	if (sign)
		*str++ = sign;
	if (type & SPECIAL) {
		if (base==8)
40202cb8:	0a000007 	beq	40202cdc <number+0x198>
			*str++ = '0';
		else if (base==16) {
40202cbc:	e3560010 	cmp	r6, #16
40202cc0:	1a000005 	bne	40202cdc <number+0x198>
			*str++ = '0';
40202cc4:	e1a03004 	mov	r3, r4
40202cc8:	e3a00030 	mov	r0, #48	; 0x30
40202ccc:	e4c30001 	strb	r0, [r3], #1
			*str++ = digits[33];
40202cd0:	e5d22021 	ldrb	r2, [r2, #33]	; 0x21
40202cd4:	e5c42001 	strb	r2, [r4, #1]
40202cd8:	e2834001 	add	r4, r3, #1
		}
	}
	if (!(type & LEFT))
40202cdc:	e3170010 	tst	r7, #16
40202ce0:	01a03004 	moveq	r3, r4
40202ce4:	0a000002 	beq	40202cf4 <number+0x1b0>
40202ce8:	ea00000b 	b	40202d1c <number+0x1d8>
		while (size-- > 0)
			*str++ = c;
40202cec:	e59d200c 	ldr	r2, [sp, #12]
40202cf0:	e5432001 	strb	r2, [r3, #-1]
			*str++ = '0';
			*str++ = digits[33];
		}
	}
	if (!(type & LEFT))
		while (size-- > 0)
40202cf4:	e24aa001 	sub	sl, sl, #1
			*str++ = c;
40202cf8:	e1a04003 	mov	r4, r3
int __res; \
__res = ((unsigned long) n) % (unsigned) base; \
n = ((unsigned long) n) / (unsigned) base; \
__res; })

static char * number(char * str, long num, int base, int size, int precision
40202cfc:	e28a2001 	add	r2, sl, #1
			*str++ = '0';
			*str++ = digits[33];
		}
	}
	if (!(type & LEFT))
		while (size-- > 0)
40202d00:	e2833001 	add	r3, r3, #1
40202d04:	e3520000 	cmp	r2, #0
40202d08:	cafffff7 	bgt	40202cec <number+0x1a8>
40202d0c:	ea000002 	b	40202d1c <number+0x1d8>
			*str++ = c;
	while (i < precision--)
		*str++ = '0';
40202d10:	e2411001 	sub	r1, r1, #1
40202d14:	e3a03030 	mov	r3, #48	; 0x30
40202d18:	e5443001 	strb	r3, [r4, #-1]
		}
	}
	if (!(type & LEFT))
		while (size-- > 0)
			*str++ = c;
	while (i < precision--)
40202d1c:	e1590001 	cmp	r9, r1
		*str++ = '0';
40202d20:	e1a02004 	mov	r2, r4
40202d24:	e2844001 	add	r4, r4, #1
		}
	}
	if (!(type & LEFT))
		while (size-- > 0)
			*str++ = c;
	while (i < precision--)
40202d28:	bafffff8 	blt	40202d10 <number+0x1cc>
40202d2c:	e28d3054 	add	r3, sp, #84	; 0x54
40202d30:	e0831009 	add	r1, r3, r9
40202d34:	e2411045 	sub	r1, r1, #69	; 0x45
40202d38:	ea000002 	b	40202d48 <number+0x204>
		*str++ = '0';
	while (i-- > 0)
		*str++ = tmp[i];
40202d3c:	e5d13001 	ldrb	r3, [r1, #1]
	if (!(type & LEFT))
		while (size-- > 0)
			*str++ = c;
	while (i < precision--)
		*str++ = '0';
	while (i-- > 0)
40202d40:	e2499001 	sub	r9, r9, #1
		*str++ = tmp[i];
40202d44:	e5423001 	strb	r3, [r2, #-1]
	if (!(type & LEFT))
		while (size-- > 0)
			*str++ = c;
	while (i < precision--)
		*str++ = '0';
	while (i-- > 0)
40202d48:	e3590000 	cmp	r9, #0
		*str++ = tmp[i];
40202d4c:	e1a03002 	mov	r3, r2
40202d50:	e2411001 	sub	r1, r1, #1
40202d54:	e2822001 	add	r2, r2, #1
	if (!(type & LEFT))
		while (size-- > 0)
			*str++ = c;
	while (i < precision--)
		*str++ = '0';
	while (i-- > 0)
40202d58:	cafffff7 	bgt	40202d3c <number+0x1f8>
40202d5c:	ea000002 	b	40202d6c <number+0x228>
		*str++ = tmp[i];
	while (size-- > 0)
		*str++ = ' ';
40202d60:	e24aa001 	sub	sl, sl, #1
40202d64:	e3a02020 	mov	r2, #32
40202d68:	e5432001 	strb	r2, [r3, #-1]
			*str++ = c;
	while (i < precision--)
		*str++ = '0';
	while (i-- > 0)
		*str++ = tmp[i];
	while (size-- > 0)
40202d6c:	e35a0000 	cmp	sl, #0
		*str++ = ' ';
40202d70:	e1a00003 	mov	r0, r3
40202d74:	e2833001 	add	r3, r3, #1
			*str++ = c;
	while (i < precision--)
		*str++ = '0';
	while (i-- > 0)
		*str++ = tmp[i];
	while (size-- > 0)
40202d78:	cafffff8 	bgt	40202d60 <number+0x21c>
		*str++ = ' ';
	return str;
}
40202d7c:	e28dd054 	add	sp, sp, #84	; 0x54
40202d80:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
40202d84:	40204bb4 	.word	0x40204bb4
40202d88:	40204bd9 	.word	0x40204bd9

40202d8c <serial_printf>:
	*str = '\0';
	return str-buf;
}

void serial_printf (const char *fmt, ...)
{
40202d8c:	e92d000f 	push	{r0, r1, r2, r3}
40202d90:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
40202d94:	e24dde11 	sub	sp, sp, #272	; 0x110
	va_list args;
	uint i;
	char printbuffer[CFG_PBSIZE];

	va_start (args, fmt);
40202d98:	e28d6f4b 	add	r6, sp, #300	; 0x12c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
40202d9c:	e28d7008 	add	r7, sp, #8
40202da0:	e59d3128 	ldr	r3, [sp, #296]	; 0x128
{
	va_list args;
	uint i;
	char printbuffer[CFG_PBSIZE];

	va_start (args, fmt);
40202da4:	e58d610c 	str	r6, [sp, #268]	; 0x10c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
40202da8:	e58d3108 	str	r3, [sp, #264]	; 0x108
40202dac:	ea0000e8 	b	40203154 <serial_printf+0x3c8>
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
		if (*fmt != '%') {
40202db0:	e3530025 	cmp	r3, #37	; 0x25
			*str++ = *fmt;
40202db4:	14c73001 	strbne	r3, [r7], #1
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
		if (*fmt != '%') {
40202db8:	03a0a000 	moveq	sl, #0
40202dbc:	1a0000e1 	bne	40203148 <serial_printf+0x3bc>
		}

		/* process flags */
		flags = 0;
		repeat:
			++fmt;		/* this also skips first '%' */
40202dc0:	e59d3108 	ldr	r3, [sp, #264]	; 0x108
40202dc4:	e2832001 	add	r2, r3, #1
40202dc8:	e58d2108 	str	r2, [sp, #264]	; 0x108
			switch (*fmt) {
40202dcc:	e5d33001 	ldrb	r3, [r3, #1]
40202dd0:	e353002b 	cmp	r3, #43	; 0x2b
40202dd4:	0a00000c 	beq	40202e0c <serial_printf+0x80>
40202dd8:	8a000004 	bhi	40202df0 <serial_printf+0x64>
40202ddc:	e3530020 	cmp	r3, #32
40202de0:	0a00000b 	beq	40202e14 <serial_printf+0x88>
40202de4:	e3530023 	cmp	r3, #35	; 0x23
40202de8:	1a00000f 	bne	40202e2c <serial_printf+0xa0>
40202dec:	ea00000a 	b	40202e1c <serial_printf+0x90>
40202df0:	e353002d 	cmp	r3, #45	; 0x2d
40202df4:	0a000002 	beq	40202e04 <serial_printf+0x78>
40202df8:	e3530030 	cmp	r3, #48	; 0x30
40202dfc:	1a00000a 	bne	40202e2c <serial_printf+0xa0>
40202e00:	ea000007 	b	40202e24 <serial_printf+0x98>
				case '-': flags |= LEFT; goto repeat;
40202e04:	e38aa010 	orr	sl, sl, #16
40202e08:	eaffffec 	b	40202dc0 <serial_printf+0x34>
				case '+': flags |= PLUS; goto repeat;
40202e0c:	e38aa004 	orr	sl, sl, #4
40202e10:	eaffffea 	b	40202dc0 <serial_printf+0x34>
				case ' ': flags |= SPACE; goto repeat;
40202e14:	e38aa008 	orr	sl, sl, #8
40202e18:	eaffffe8 	b	40202dc0 <serial_printf+0x34>
				case '#': flags |= SPECIAL; goto repeat;
40202e1c:	e38aa020 	orr	sl, sl, #32
40202e20:	eaffffe6 	b	40202dc0 <serial_printf+0x34>
				case '0': flags |= ZEROPAD; goto repeat;
40202e24:	e38aa001 	orr	sl, sl, #1
40202e28:	eaffffe4 	b	40202dc0 <serial_printf+0x34>
				}

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
40202e2c:	e2431030 	sub	r1, r3, #48	; 0x30
40202e30:	e6ef1071 	uxtb	r1, r1
40202e34:	e3510009 	cmp	r1, #9
40202e38:	8a000003 	bhi	40202e4c <serial_printf+0xc0>
			field_width = skip_atoi(&fmt);
40202e3c:	e28d0f42 	add	r0, sp, #264	; 0x108
40202e40:	ebffff31 	bl	40202b0c <skip_atoi>
40202e44:	e1a05000 	mov	r5, r0
40202e48:	ea00000a 	b	40202e78 <serial_printf+0xec>
		else if (*fmt == '*') {
40202e4c:	e353002a 	cmp	r3, #42	; 0x2a
40202e50:	13e05000 	mvnne	r5, #0
40202e54:	1a000007 	bne	40202e78 <serial_printf+0xec>
			++fmt;
40202e58:	e2822001 	add	r2, r2, #1
40202e5c:	e58d2108 	str	r2, [sp, #264]	; 0x108
			/* it's the next argument */
			field_width = va_arg(args, int);
40202e60:	e5965000 	ldr	r5, [r6]
40202e64:	e2863004 	add	r3, r6, #4
			if (field_width < 0) {
40202e68:	e3550000 	cmp	r5, #0
				field_width = -field_width;
				flags |= LEFT;
40202e6c:	e1a06003 	mov	r6, r3
		else if (*fmt == '*') {
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
			if (field_width < 0) {
				field_width = -field_width;
40202e70:	b2655000 	rsblt	r5, r5, #0
				flags |= LEFT;
40202e74:	b38aa010 	orrlt	sl, sl, #16
			}
		}

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
40202e78:	e59d3108 	ldr	r3, [sp, #264]	; 0x108
40202e7c:	e5d32000 	ldrb	r2, [r3]
40202e80:	e352002e 	cmp	r2, #46	; 0x2e
40202e84:	13e03000 	mvnne	r3, #0
40202e88:	1a000013 	bne	40202edc <serial_printf+0x150>
			++fmt;
40202e8c:	e2832001 	add	r2, r3, #1
40202e90:	e58d2108 	str	r2, [sp, #264]	; 0x108
			if (is_digit(*fmt))
40202e94:	e5d33001 	ldrb	r3, [r3, #1]
40202e98:	e2431030 	sub	r1, r3, #48	; 0x30
40202e9c:	e6ef1071 	uxtb	r1, r1
40202ea0:	e3510009 	cmp	r1, #9
40202ea4:	8a000003 	bhi	40202eb8 <serial_printf+0x12c>
				precision = skip_atoi(&fmt);
40202ea8:	e28d0f42 	add	r0, sp, #264	; 0x108
40202eac:	ebffff16 	bl	40202b0c <skip_atoi>
40202eb0:	e1a03000 	mov	r3, r0
40202eb4:	ea000005 	b	40202ed0 <serial_printf+0x144>
			else if (*fmt == '*') {
40202eb8:	e353002a 	cmp	r3, #42	; 0x2a
40202ebc:	1a000005 	bne	40202ed8 <serial_printf+0x14c>
				++fmt;
40202ec0:	e2822001 	add	r2, r2, #1
40202ec4:	e58d2108 	str	r2, [sp, #264]	; 0x108
				/* it's the next argument */
				precision = va_arg(args, int);
40202ec8:	e5963000 	ldr	r3, [r6]
40202ecc:	e2866004 	add	r6, r6, #4
			}
			if (precision < 0)
40202ed0:	e3530000 	cmp	r3, #0
40202ed4:	aa000000 	bge	40202edc <serial_printf+0x150>
40202ed8:	e3a03000 	mov	r3, #0
				precision = 0;
		}

		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
40202edc:	e59d2108 	ldr	r2, [sp, #264]	; 0x108
40202ee0:	e5d21000 	ldrb	r1, [r2]
40202ee4:	e3510068 	cmp	r1, #104	; 0x68
40202ee8:	1351006c 	cmpne	r1, #108	; 0x6c
40202eec:	0a000002 	beq	40202efc <serial_printf+0x170>
40202ef0:	e351004c 	cmp	r1, #76	; 0x4c
40202ef4:	13e01000 	mvnne	r1, #0
40202ef8:	1a000001 	bne	40202f04 <serial_printf+0x178>
			qualifier = *fmt;
			++fmt;
40202efc:	e2822001 	add	r2, r2, #1
40202f00:	e58d2108 	str	r2, [sp, #264]	; 0x108
		}

		/* default base */
		base = 10;

		switch (*fmt) {
40202f04:	e59d2108 	ldr	r2, [sp, #264]	; 0x108
40202f08:	e5d22000 	ldrb	r2, [r2]
40202f0c:	e352006e 	cmp	r2, #110	; 0x6e
40202f10:	0a000061 	beq	4020309c <serial_printf+0x310>
40202f14:	8a00000c 	bhi	40202f4c <serial_printf+0x1c0>
40202f18:	e3520063 	cmp	r2, #99	; 0x63
40202f1c:	0a000017 	beq	40202f80 <serial_printf+0x1f4>
40202f20:	8a000004 	bhi	40202f38 <serial_printf+0x1ac>
40202f24:	e3520025 	cmp	r2, #37	; 0x25
40202f28:	0a000071 	beq	402030f4 <serial_printf+0x368>
40202f2c:	e3520058 	cmp	r2, #88	; 0x58
40202f30:	1a000067 	bne	402030d4 <serial_printf+0x348>
40202f34:	ea000061 	b	402030c0 <serial_printf+0x334>
40202f38:	e3520064 	cmp	r2, #100	; 0x64
40202f3c:	0a000062 	beq	402030cc <serial_printf+0x340>
40202f40:	e3520069 	cmp	r2, #105	; 0x69
40202f44:	1a000062 	bne	402030d4 <serial_printf+0x348>
40202f48:	ea00005f 	b	402030cc <serial_printf+0x340>
40202f4c:	e3520073 	cmp	r2, #115	; 0x73
40202f50:	0a000021 	beq	40202fdc <serial_printf+0x250>
40202f54:	8a000004 	bhi	40202f6c <serial_printf+0x1e0>
40202f58:	e352006f 	cmp	r2, #111	; 0x6f
40202f5c:	0a000055 	beq	402030b8 <serial_printf+0x32c>
40202f60:	e3520070 	cmp	r2, #112	; 0x70
40202f64:	1a00005a 	bne	402030d4 <serial_printf+0x348>
40202f68:	ea000041 	b	40203074 <serial_printf+0x2e8>
40202f6c:	e3520075 	cmp	r2, #117	; 0x75
40202f70:	0a000061 	beq	402030fc <serial_printf+0x370>
40202f74:	e3520078 	cmp	r2, #120	; 0x78
40202f78:	1a000055 	bne	402030d4 <serial_printf+0x348>
40202f7c:	ea000050 	b	402030c4 <serial_printf+0x338>
		case 'c':
			if (!(flags & LEFT))
40202f80:	e31a0010 	tst	sl, #16
40202f84:	01a03007 	moveq	r3, r7
40202f88:	0a000002 	beq	40202f98 <serial_printf+0x20c>
40202f8c:	ea000006 	b	40202fac <serial_printf+0x220>
				while (--field_width > 0)
					*str++ = ' ';
40202f90:	e3a02020 	mov	r2, #32
40202f94:	e5432001 	strb	r2, [r3, #-1]
		base = 10;

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
40202f98:	e2455001 	sub	r5, r5, #1
					*str++ = ' ';
40202f9c:	e1a07003 	mov	r7, r3
		base = 10;

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
40202fa0:	e3550000 	cmp	r5, #0
40202fa4:	e2833001 	add	r3, r3, #1
40202fa8:	cafffff8 	bgt	40202f90 <serial_printf+0x204>
					*str++ = ' ';
			*str++ = (unsigned char) va_arg(args, int);
40202fac:	e5962000 	ldr	r2, [r6]
40202fb0:	e1a03007 	mov	r3, r7
40202fb4:	e4c32001 	strb	r2, [r3], #1
40202fb8:	ea000001 	b	40202fc4 <serial_printf+0x238>
			while (--field_width > 0)
				*str++ = ' ';
40202fbc:	e3a02020 	mov	r2, #32
40202fc0:	e5432001 	strb	r2, [r3, #-1]
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
					*str++ = ' ';
			*str++ = (unsigned char) va_arg(args, int);
			while (--field_width > 0)
40202fc4:	e2455001 	sub	r5, r5, #1
				*str++ = ' ';
40202fc8:	e1a07003 	mov	r7, r3
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
					*str++ = ' ';
			*str++ = (unsigned char) va_arg(args, int);
			while (--field_width > 0)
40202fcc:	e3550000 	cmp	r5, #0
40202fd0:	e2833001 	add	r3, r3, #1
40202fd4:	cafffff8 	bgt	40202fbc <serial_printf+0x230>
40202fd8:	ea000023 	b	4020306c <serial_printf+0x2e0>
				*str++ = ' ';
			continue;

		case 's':
			s = va_arg(args, char *);
40202fdc:	e5964000 	ldr	r4, [r6]
			if (!s)
				s = "<NULL>";

			len = strnlen(s, precision);
40202fe0:	e1a01003 	mov	r1, r3
				*str++ = ' ';
			continue;

		case 's':
			s = va_arg(args, char *);
			if (!s)
40202fe4:	e59f2194 	ldr	r2, [pc, #404]	; 40203180 <serial_printf+0x3f4>
40202fe8:	e3540000 	cmp	r4, #0
40202fec:	01a04002 	moveq	r4, r2
				s = "<NULL>";

			len = strnlen(s, precision);
40202ff0:	e1a00004 	mov	r0, r4
40202ff4:	ebfffeba 	bl	40202ae4 <strnlen>

			if (!(flags & LEFT))
40202ff8:	e31a0010 	tst	sl, #16
40202ffc:	01a03007 	moveq	r3, r7
40203000:	0a000002 	beq	40203010 <serial_printf+0x284>
40203004:	ea000007 	b	40203028 <serial_printf+0x29c>
				while (len < field_width--)
					*str++ = ' ';
40203008:	e3a02020 	mov	r2, #32
4020300c:	e5432001 	strb	r2, [r3, #-1]
				s = "<NULL>";

			len = strnlen(s, precision);

			if (!(flags & LEFT))
				while (len < field_width--)
40203010:	e2455001 	sub	r5, r5, #1
					*str++ = ' ';
40203014:	e1a07003 	mov	r7, r3
	}
	*str = '\0';
	return str-buf;
}

void serial_printf (const char *fmt, ...)
40203018:	e2852001 	add	r2, r5, #1
				s = "<NULL>";

			len = strnlen(s, precision);

			if (!(flags & LEFT))
				while (len < field_width--)
4020301c:	e2833001 	add	r3, r3, #1
40203020:	e1500002 	cmp	r0, r2
40203024:	bafffff7 	blt	40203008 <serial_printf+0x27c>
40203028:	e3a03000 	mov	r3, #0
4020302c:	ea000002 	b	4020303c <serial_printf+0x2b0>
					*str++ = ' ';
			for (i = 0; i < len; ++i)
				*str++ = *s++;
40203030:	e7d42003 	ldrb	r2, [r4, r3]
40203034:	e7c72003 	strb	r2, [r7, r3]
			len = strnlen(s, precision);

			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
40203038:	e2833001 	add	r3, r3, #1
4020303c:	e1530000 	cmp	r3, r0
	}
	*str = '\0';
	return str-buf;
}

void serial_printf (const char *fmt, ...)
40203040:	e0832007 	add	r2, r3, r7
			len = strnlen(s, precision);

			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
40203044:	bafffff9 	blt	40203030 <serial_printf+0x2a4>
40203048:	e1a03002 	mov	r3, r2
4020304c:	ea000002 	b	4020305c <serial_printf+0x2d0>
				*str++ = *s++;
			while (len < field_width--)
				*str++ = ' ';
40203050:	e2455001 	sub	r5, r5, #1
40203054:	e3a02020 	mov	r2, #32
40203058:	e5432001 	strb	r2, [r3, #-1]
			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
				*str++ = *s++;
			while (len < field_width--)
4020305c:	e1500005 	cmp	r0, r5
				*str++ = ' ';
40203060:	e1a07003 	mov	r7, r3
40203064:	e2833001 	add	r3, r3, #1
			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
				*str++ = *s++;
			while (len < field_width--)
40203068:	bafffff8 	blt	40203050 <serial_printf+0x2c4>
			while (--field_width > 0)
				*str++ = ' ';
			continue;

		case 's':
			s = va_arg(args, char *);
4020306c:	e2866004 	add	r6, r6, #4
40203070:	ea000034 	b	40203148 <serial_printf+0x3bc>
			while (len < field_width--)
				*str++ = ' ';
			continue;

		case 'p':
			if (field_width == -1) {
40203074:	e3750001 	cmn	r5, #1
				field_width = 2*sizeof(void *);
				flags |= ZEROPAD;
			}
			str = number(str,
40203078:	e58d3000 	str	r3, [sp]
			continue;

		case 'p':
			if (field_width == -1) {
				field_width = 2*sizeof(void *);
				flags |= ZEROPAD;
4020307c:	038aa001 	orreq	sl, sl, #1
40203080:	02855009 	addeq	r5, r5, #9
			}
			str = number(str,
40203084:	e58da004 	str	sl, [sp, #4]
40203088:	e2864004 	add	r4, r6, #4
4020308c:	e1a00007 	mov	r0, r7
40203090:	e5961000 	ldr	r1, [r6]
40203094:	e3a02010 	mov	r2, #16
40203098:	ea000026 	b	40203138 <serial_printf+0x3ac>
4020309c:	e5962000 	ldr	r2, [r6]
402030a0:	e2863004 	add	r3, r6, #4
402030a4:	e28d1008 	add	r1, sp, #8
			if (qualifier == 'l') {
				long * ip = va_arg(args, long *);
				*ip = (str - buf);
			} else {
				int * ip = va_arg(args, int *);
				*ip = (str - buf);
402030a8:	e0611007 	rsb	r1, r1, r7
402030ac:	e1a06003 	mov	r6, r3
402030b0:	e5821000 	str	r1, [r2]
402030b4:	ea000023 	b	40203148 <serial_printf+0x3bc>
			}
			continue;

		case '%':
			*str++ = '%';
402030b8:	e3a02008 	mov	r2, #8
402030bc:	ea00000f 	b	40203100 <serial_printf+0x374>
		case 'o':
			base = 8;
			break;

		case 'X':
			flags |= LARGE;
402030c0:	e38aa040 	orr	sl, sl, #64	; 0x40
402030c4:	e3a02010 	mov	r2, #16
402030c8:	ea00000c 	b	40203100 <serial_printf+0x374>
			base = 16;
			break;

		case 'd':
		case 'i':
			flags |= SIGN;
402030cc:	e38aa002 	orr	sl, sl, #2
402030d0:	ea000009 	b	402030fc <serial_printf+0x370>
		case 'u':
			break;

		default:
			*str++ = '%';
402030d4:	e3a03025 	mov	r3, #37	; 0x25
402030d8:	e4c73001 	strb	r3, [r7], #1
			if (*fmt)
402030dc:	e59d3108 	ldr	r3, [sp, #264]	; 0x108
402030e0:	e5d32000 	ldrb	r2, [r3]
402030e4:	e3520000 	cmp	r2, #0
				*str++ = *fmt;
			else
				--fmt;
402030e8:	02433001 	subeq	r3, r3, #1
402030ec:	058d3108 	streq	r3, [sp, #264]	; 0x108
		case 'u':
			break;

		default:
			*str++ = '%';
			if (*fmt)
402030f0:	0a000014 	beq	40203148 <serial_printf+0x3bc>
				*str++ = *fmt;
402030f4:	e4c72001 	strb	r2, [r7], #1
402030f8:	ea000012 	b	40203148 <serial_printf+0x3bc>
			else
				--fmt;
402030fc:	e3a0200a 	mov	r2, #10
			continue;
		}
		if (qualifier == 'l')
40203100:	e351006c 	cmp	r1, #108	; 0x6c
40203104:	0a000007 	beq	40203128 <serial_printf+0x39c>
			num = va_arg(args, unsigned long);
		else if (qualifier == 'h') {
40203108:	e3510068 	cmp	r1, #104	; 0x68
4020310c:	e20a0002 	and	r0, sl, #2
40203110:	1a000004 	bne	40203128 <serial_printf+0x39c>
			num = (unsigned short) va_arg(args, int);
40203114:	e1d610b0 	ldrh	r1, [r6]
			if (flags & SIGN)
40203118:	e3500000 	cmp	r0, #0
			continue;
		}
		if (qualifier == 'l')
			num = va_arg(args, unsigned long);
		else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
4020311c:	e2864004 	add	r4, r6, #4
			if (flags & SIGN)
				num = (short) num;
40203120:	16bf1071 	sxthne	r1, r1
40203124:	ea000001 	b	40203130 <serial_printf+0x3a4>
		} else if (flags & SIGN)
			num = va_arg(args, int);
40203128:	e5961000 	ldr	r1, [r6]
4020312c:	e2864004 	add	r4, r6, #4
		else
			num = va_arg(args, unsigned int);
		str = number(str, num, base, field_width, precision, flags);
40203130:	e1a00007 	mov	r0, r7
40203134:	e88d0408 	stm	sp, {r3, sl}
40203138:	e1a03005 	mov	r3, r5
4020313c:	e1a06004 	mov	r6, r4
40203140:	ebfffe7f 	bl	40202b44 <number>
40203144:	e1a07000 	mov	r7, r0
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
40203148:	e59d3108 	ldr	r3, [sp, #264]	; 0x108
4020314c:	e2833001 	add	r3, r3, #1
40203150:	e58d3108 	str	r3, [sp, #264]	; 0x108
40203154:	e59d3108 	ldr	r3, [sp, #264]	; 0x108
40203158:	e5d33000 	ldrb	r3, [r3]
4020315c:	e3530000 	cmp	r3, #0
40203160:	1affff12 	bne	40202db0 <serial_printf+0x24>
			num = va_arg(args, int);
		else
			num = va_arg(args, unsigned int);
		str = number(str, num, base, field_width, precision, flags);
	}
	*str = '\0';
40203164:	e5c73000 	strb	r3, [r7]
	 */
	i = vsprintf (printbuffer, fmt, args);
	va_end (args);

	/* Print the string */
	serial_puts (printbuffer);
40203168:	e28d0008 	add	r0, sp, #8
4020316c:	eb0003b4 	bl	40204044 <serial_puts>
}
40203170:	e28dde11 	add	sp, sp, #272	; 0x110
40203174:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
40203178:	e28dd010 	add	sp, sp, #16
4020317c:	e12fff1e 	bx	lr
40203180:	40204bfe 	.word	0x40204bfe

40203184 <__div0>:
/* Replacement (=dummy) for GNU/Linux division-by zero handler */
void __div0 (void)
{
	extern void hang (void);

	hang();
40203184:	eafffe11 	b	402029d0 <hang>

40203188 <__umodsi3>:
	.text
	.globl	 __umodsi3
	.type  __umodsi3       ,function
	.align 0
 __umodsi3      :
	cmp	divisor, #0
40203188:	e3510000 	cmp	r1, #0
	beq	Ldiv0
4020318c:	0a000026 	beq	4020322c <Ldiv0>
	mov	curbit, #1
40203190:	e3a03001 	mov	r3, #1
	cmp	dividend, divisor
40203194:	e1500001 	cmp	r0, r1
	movcc  	pc, lr
40203198:	31a0f00e 	movcc	pc, lr

4020319c <Loop1>:
Loop1:
	@ Unless the divisor is very big, shift it up in multiples of
	@ four bits, since this is the amount of unwinding in the main
	@ division loop.  Continue shifting until the divisor is
	@ larger than the dividend.
	cmp	divisor, #0x10000000
4020319c:	e3510201 	cmp	r1, #268435456	; 0x10000000
	cmpcc	divisor, dividend
402031a0:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #4
402031a4:	31a01201 	lslcc	r1, r1, #4
	movcc	curbit, curbit, lsl #4
402031a8:	31a03203 	lslcc	r3, r3, #4
	bcc	Loop1
402031ac:	3afffffa 	bcc	4020319c <Loop1>

402031b0 <Lbignum>:
Lbignum:
	@ For very big divisors, we must shift it a bit at a time, or
	@ we will be in danger of overflowing.
	cmp	divisor, #0x80000000
402031b0:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
	cmpcc	divisor, dividend
402031b4:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #1
402031b8:	31a01081 	lslcc	r1, r1, #1
	movcc	curbit, curbit, lsl #1
402031bc:	31a03083 	lslcc	r3, r3, #1
	bcc	Lbignum
402031c0:	3afffffa 	bcc	402031b0 <Lbignum>

402031c4 <Loop3>:
Loop3:
	@ Test for possible subtractions.  On the final pass, this may
	@ subtract too much from the dividend, so keep track of which
	@ subtractions are done, we can fix them up afterwards...
	mov	overdone, #0
402031c4:	e3a02000 	mov	r2, #0
	cmp	dividend, divisor
402031c8:	e1500001 	cmp	r0, r1
	subcs	dividend, dividend, divisor
402031cc:	20400001 	subcs	r0, r0, r1
	cmp	dividend, divisor, lsr #1
402031d0:	e15000a1 	cmp	r0, r1, lsr #1
	subcs	dividend, dividend, divisor, lsr #1
402031d4:	204000a1 	subcs	r0, r0, r1, lsr #1
	orrcs	overdone, overdone, curbit, ror #1
402031d8:	218220e3 	orrcs	r2, r2, r3, ror #1
	cmp	dividend, divisor, lsr #2
402031dc:	e1500121 	cmp	r0, r1, lsr #2
	subcs	dividend, dividend, divisor, lsr #2
402031e0:	20400121 	subcs	r0, r0, r1, lsr #2
	orrcs	overdone, overdone, curbit, ror #2
402031e4:	21822163 	orrcs	r2, r2, r3, ror #2
	cmp	dividend, divisor, lsr #3
402031e8:	e15001a1 	cmp	r0, r1, lsr #3
	subcs	dividend, dividend, divisor, lsr #3
402031ec:	204001a1 	subcs	r0, r0, r1, lsr #3
	orrcs	overdone, overdone, curbit, ror #3
402031f0:	218221e3 	orrcs	r2, r2, r3, ror #3
	mov	ip, curbit
402031f4:	e1a0c003 	mov	ip, r3
	cmp	dividend, #0			@ Early termination?
402031f8:	e3500000 	cmp	r0, #0
	movnes	curbit, curbit, lsr #4		@ No, any more bits to do?
402031fc:	11b03223 	lsrsne	r3, r3, #4
	movne	divisor, divisor, lsr #4
40203200:	11a01221 	lsrne	r1, r1, #4
	bne	Loop3
40203204:	1affffee 	bne	402031c4 <Loop3>
	@ the top three bits of "overdone".  Exactly which were not needed
	@ are governed by the position of the bit, stored in ip.
	@ If we terminated early, because dividend became zero,
	@ then none of the below will match, since the bit in ip will not be
	@ in the bottom nibble.
	ands	overdone, overdone, #0xe0000000
40203208:	e212220e 	ands	r2, r2, #-536870912	; 0xe0000000
	moveq  	pc, lr				@ No fixups needed
4020320c:	01a0f00e 	moveq	pc, lr
	tst	overdone, ip, ror #3
40203210:	e11201ec 	tst	r2, ip, ror #3
	addne	dividend, dividend, divisor, lsr #3
40203214:	108001a1 	addne	r0, r0, r1, lsr #3
	tst	overdone, ip, ror #2
40203218:	e112016c 	tst	r2, ip, ror #2
	addne	dividend, dividend, divisor, lsr #2
4020321c:	10800121 	addne	r0, r0, r1, lsr #2
	tst	overdone, ip, ror #1
40203220:	e11200ec 	tst	r2, ip, ror #1
	addne	dividend, dividend, divisor, lsr #1
40203224:	108000a1 	addne	r0, r0, r1, lsr #1
	mov 	pc, lr
40203228:	e1a0f00e 	mov	pc, lr

4020322c <Ldiv0>:
Ldiv0:
	str	lr, [sp, #-4]!
4020322c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	bl	 __div0       (PLT)
40203230:	ebffffd3 	bl	40203184 <__div0>
	mov	r0, #0			@ about as wrong as it could be
40203234:	e3a00000 	mov	r0, #0
	ldmia	sp!, {pc}
40203238:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

4020323c <downcase>:
/*
 * Convert a string to lowercase.
 */
static void
downcase(char *str)
{
4020323c:	e3a03000 	mov	r3, #0
	while (*str != '\0') {
40203240:	ea000005 	b	4020325c <downcase+0x20>
		TOLOWER(*str);
40203244:	e2421041 	sub	r1, r2, #65	; 0x41
40203248:	e6ef1071 	uxtb	r1, r1
4020324c:	e3510019 	cmp	r1, #25
40203250:	92822020 	addls	r2, r2, #32
40203254:	97c02003 	strbls	r2, [r0, r3]
40203258:	e2833001 	add	r3, r3, #1
 * Convert a string to lowercase.
 */
static void
downcase(char *str)
{
	while (*str != '\0') {
4020325c:	e7d02003 	ldrb	r2, [r0, r3]
40203260:	e3520000 	cmp	r2, #0
40203264:	1afffff6 	bne	40203244 <downcase+0x8>
		TOLOWER(*str);
		str++;
	}
}
40203268:	e12fff1e 	bx	lr

4020326c <strncmp>:
#define DOS_PART_TBL_OFFSET	0x1be
#define DOS_PART_MAGIC_OFFSET	0x1fe
#define DOS_FS_TYPE_OFFSET	0x52

int strncmp(const char * cs,const char * ct,size_t count)
{
4020326c:	e92d4010 	push	{r4, lr}
40203270:	e3a03000 	mov	r3, #0
        register signed char __res = 0;

        while (count) {
40203274:	ea000009 	b	402032a0 <strncmp+0x34>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
40203278:	e7d04003 	ldrb	r4, [r0, r3]
4020327c:	e7d1c003 	ldrb	ip, [r1, r3]
40203280:	e06cc004 	rsb	ip, ip, r4
40203284:	e6efc07c 	uxtb	ip, ip
40203288:	e35c0000 	cmp	ip, #0
4020328c:	1a000006 	bne	402032ac <strncmp+0x40>
40203290:	e3540000 	cmp	r4, #0
40203294:	e2833001 	add	r3, r3, #1
40203298:	0a000003 	beq	402032ac <strncmp+0x40>
                        break;
                count--;
4020329c:	e2422001 	sub	r2, r2, #1

int strncmp(const char * cs,const char * ct,size_t count)
{
        register signed char __res = 0;

        while (count) {
402032a0:	e3520000 	cmp	r2, #0
402032a4:	1afffff3 	bne	40203278 <strncmp+0xc>
402032a8:	e1a0c002 	mov	ip, r2
                        break;
                count--;
        }

        return __res;
}
402032ac:	e6af007c 	sxtb	r0, ip
402032b0:	e8bd8010 	pop	{r4, pc}

402032b4 <strcpy>:

char * strcpy(char * dest,const char *src)
{
402032b4:	e3a03000 	mov	r3, #0
        char *tmp = dest;

        while ((*dest++ = *src++) != '\0')
402032b8:	e7d12003 	ldrb	r2, [r1, r3]
402032bc:	e3520000 	cmp	r2, #0
402032c0:	e7c02003 	strb	r2, [r0, r3]
402032c4:	e2833001 	add	r3, r3, #1
402032c8:	1afffffa 	bne	402032b8 <strcpy+0x4>
                /* nothing */;
        return tmp;
}
402032cc:	e12fff1e 	bx	lr

402032d0 <strcmp>:

int strcmp(const char * cs,const char * ct)
{
402032d0:	e3a03000 	mov	r3, #0
        register signed char __res;

        while (1) {
                if ((__res = *cs - *ct++) != 0 || !*cs++)
402032d4:	e7d0c003 	ldrb	ip, [r0, r3]
402032d8:	e7d12003 	ldrb	r2, [r1, r3]
402032dc:	e062200c 	rsb	r2, r2, ip
402032e0:	e6ef2072 	uxtb	r2, r2
402032e4:	e3520000 	cmp	r2, #0
402032e8:	1a000002 	bne	402032f8 <strcmp+0x28>
402032ec:	e35c0000 	cmp	ip, #0
402032f0:	e2833001 	add	r3, r3, #1
402032f4:	1afffff6 	bne	402032d4 <strcmp+0x4>
                        break;
        }

        return __res;
}
402032f8:	e6af0072 	sxtb	r0, r2
402032fc:	e12fff1e 	bx	lr

40203300 <memcpy>:
void * memcpy(void * dest,const void *src,size_t count)
{
40203300:	e3a03000 	mov	r3, #0
        char *tmp = (char *) dest, *s = (char *) src;

        while (count--)
40203304:	ea000003 	b	40203318 <memcpy+0x18>
                *tmp++ = *s++;
40203308:	e7d1c003 	ldrb	ip, [r1, r3]
4020330c:	e2422001 	sub	r2, r2, #1
40203310:	e7c0c003 	strb	ip, [r0, r3]
40203314:	e2833001 	add	r3, r3, #1
}
void * memcpy(void * dest,const void *src,size_t count)
{
        char *tmp = (char *) dest, *s = (char *) src;

        while (count--)
40203318:	e3520000 	cmp	r2, #0
4020331c:	1afffff9 	bne	40203308 <memcpy+0x8>
                *tmp++ = *s++;

        return dest;
}
40203320:	e12fff1e 	bx	lr

40203324 <disk_read>:


int disk_read (__u32 startblock, __u32 getsize, __u8 * bufptr)
{
40203324:	e1a03002 	mov	r3, r2
	startblock += part_offset;
40203328:	e59f2040 	ldr	r2, [pc, #64]	; 40203370 <disk_read+0x4c>
        return dest;
}


int disk_read (__u32 startblock, __u32 getsize, __u8 * bufptr)
{
4020332c:	e92d4030 	push	{r4, r5, lr}
40203330:	e1a04001 	mov	r4, r1
	startblock += part_offset;
40203334:	e5921000 	ldr	r1, [r2]
        return dest;
}


int disk_read (__u32 startblock, __u32 getsize, __u8 * bufptr)
{
40203338:	e1a05000 	mov	r5, r0
	startblock += part_offset;
	if (cur_dev == NULL)
4020333c:	e5922004 	ldr	r2, [r2, #4]
40203340:	e3520000 	cmp	r2, #0
40203344:	0a000007 	beq	40203368 <disk_read+0x44>
		return -1;
	if (cur_dev->block_read) {
40203348:	e592c060 	ldr	ip, [r2, #96]	; 0x60
4020334c:	e35c0000 	cmp	ip, #0
40203350:	0a000004 	beq	40203368 <disk_read+0x44>
		return cur_dev->block_read (cur_dev->dev, startblock, getsize, (unsigned long *)bufptr);
40203354:	e5920004 	ldr	r0, [r2, #4]
40203358:	e0851001 	add	r1, r5, r1
4020335c:	e1a02004 	mov	r2, r4
40203360:	e12fff3c 	blx	ip
40203364:	e8bd8030 	pop	{r4, r5, pc}
40203368:	e3e00000 	mvn	r0, #0
	}
	return -1;
}
4020336c:	e8bd8030 	pop	{r4, r5, pc}
40203370:	40204fe8 	.word	0x40204fe8

40203374 <dirdelim>:
 * Get the first occurence of a directory delimiter ('/' or '\') in a string.
 * Return index into string if found, -1 otherwise.
 */
static int
dirdelim(char *str)
{
40203374:	e1a03000 	mov	r3, r0
	char *start = str;

	while (*str != '\0') {
40203378:	ea000005 	b	40203394 <dirdelim+0x20>
		if (ISDIRDELIM(*str)) return str - start;
4020337c:	e352002f 	cmp	r2, #47	; 0x2f
40203380:	1352005c 	cmpne	r2, #92	; 0x5c
40203384:	1a000001 	bne	40203390 <dirdelim+0x1c>
40203388:	e0600003 	rsb	r0, r0, r3
4020338c:	e12fff1e 	bx	lr
		str++;
40203390:	e2833001 	add	r3, r3, #1
static int
dirdelim(char *str)
{
	char *start = str;

	while (*str != '\0') {
40203394:	e5d32000 	ldrb	r2, [r3]
40203398:	e3520000 	cmp	r2, #0
4020339c:	1afffff6 	bne	4020337c <dirdelim+0x8>
402033a0:	e3e00000 	mvn	r0, #0
		if (ISDIRDELIM(*str)) return str - start;
		str++;
	}
	return -1;
}
402033a4:	e12fff1e 	bx	lr

402033a8 <compare_sign>:
 * Match volume_info fs_type strings.
 * Return 0 on match, -1 otherwise.
 */
static int
compare_sign(char *str1, char *str2)
{
402033a8:	e3a03000 	mov	r3, #0
	char *end = str1+SIGNLEN;

	while (str1 != end) {
		if (*str1 != *str2) {
402033ac:	e7d0c003 	ldrb	ip, [r0, r3]
402033b0:	e7d12003 	ldrb	r2, [r1, r3]
402033b4:	e2833001 	add	r3, r3, #1
402033b8:	e15c0002 	cmp	ip, r2
402033bc:	0a000001 	beq	402033c8 <compare_sign+0x20>
402033c0:	e3e00000 	mvn	r0, #0
402033c4:	e12fff1e 	bx	lr
static int
compare_sign(char *str1, char *str2)
{
	char *end = str1+SIGNLEN;

	while (str1 != end) {
402033c8:	e3530007 	cmp	r3, #7
402033cc:	1afffff6 	bne	402033ac <compare_sign+0x4>
402033d0:	e3a00000 	mov	r0, #0
		str1++;
		str2++;
	}

	return 0;
}
402033d4:	e12fff1e 	bx	lr

402033d8 <read_bootsectandvi>:
/*
 * Read boot sector and volume info from a FAT filesystem
 */
static int
read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
{
402033d8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
402033dc:	e24ddc02 	sub	sp, sp, #512	; 0x200
402033e0:	e1a05000 	mov	r5, r0
	__u8 block[FS_BLOCK_SIZE];
	volume_info *vistart;

	printf("Reading boot sector\n");
402033e4:	e59f00d8 	ldr	r0, [pc, #216]	; 402034c4 <read_bootsectandvi+0xec>
/*
 * Read boot sector and volume info from a FAT filesystem
 */
static int
read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
{
402033e8:	e1a07001 	mov	r7, r1
402033ec:	e1a04002 	mov	r4, r2
	__u8 block[FS_BLOCK_SIZE];
	volume_info *vistart;

	printf("Reading boot sector\n");
402033f0:	ebfffe65 	bl	40202d8c <serial_printf>

	if (disk_read(0, 1, block) < 0) {
402033f4:	e3a00000 	mov	r0, #0
402033f8:	e3a01001 	mov	r1, #1
402033fc:	e1a0200d 	mov	r2, sp
40203400:	ebffffc7 	bl	40203324 <disk_read>
40203404:	e1a0600d 	mov	r6, sp
40203408:	e3500000 	cmp	r0, #0
4020340c:	ba000029 	blt	402034b8 <read_bootsectandvi+0xe0>
		FAT_DPRINT("Error: reading block\n");
		return -1;
	}

	memcpy(bs, block, sizeof(boot_sector));
40203410:	e1a00005 	mov	r0, r5
40203414:	e1a0100d 	mov	r1, sp
40203418:	e3a02040 	mov	r2, #64	; 0x40
4020341c:	ebffffb7 	bl	40203300 <memcpy>
	bs->reserved	= FAT2CPU16(bs->reserved);
	bs->fat_length	= FAT2CPU16(bs->fat_length);
40203420:	e1d531b6 	ldrh	r3, [r5, #22]
		*fatsize = 32;
	} else {
		vistart = (volume_info*) &(bs->fat32_length);
		*fatsize = 0;
	}
	memcpy(volinfo, vistart, sizeof(volume_info));
40203424:	e1a00007 	mov	r0, r7
40203428:	e3a0201c 	mov	r2, #28
	bs->hidden	= FAT2CPU32(bs->hidden);
#endif
	bs->total_sect	= FAT2CPU32(bs->total_sect);

	/* FAT32 entries */
	if (bs->fat_length == 0) {
4020342c:	e3530000 	cmp	r3, #0
		return -1;
	}

	memcpy(bs, block, sizeof(boot_sector));
	bs->reserved	= FAT2CPU16(bs->reserved);
	bs->fat_length	= FAT2CPU16(bs->fat_length);
40203430:	e1c531b6 	strh	r3, [r5, #22]
		bs->fat32_length = FAT2CPU32(bs->fat32_length);
		bs->flags	 = FAT2CPU16(bs->flags);
		bs->root_cluster = FAT2CPU32(bs->root_cluster);
		bs->info_sector  = FAT2CPU16(bs->info_sector);
		bs->backup_boot  = FAT2CPU16(bs->backup_boot);
		vistart = (volume_info*) (block + sizeof(boot_sector));
40203434:	028d5040 	addeq	r5, sp, #64	; 0x40
		*fatsize = 32;
	} else {
		vistart = (volume_info*) &(bs->fat32_length);
40203438:	12855024 	addne	r5, r5, #36	; 0x24
		bs->flags	 = FAT2CPU16(bs->flags);
		bs->root_cluster = FAT2CPU32(bs->root_cluster);
		bs->info_sector  = FAT2CPU16(bs->info_sector);
		bs->backup_boot  = FAT2CPU16(bs->backup_boot);
		vistart = (volume_info*) (block + sizeof(boot_sector));
		*fatsize = 32;
4020343c:	02833020 	addeq	r3, r3, #32
	} else {
		vistart = (volume_info*) &(bs->fat32_length);
		*fatsize = 0;
40203440:	13a03000 	movne	r3, #0
40203444:	e5843000 	str	r3, [r4]
	}
	memcpy(volinfo, vistart, sizeof(volume_info));
40203448:	e1a01005 	mov	r1, r5
4020344c:	ebffffab 	bl	40203300 <memcpy>

	/* Terminate fs_type string. Writing past the end of vistart
	   is ok - it's just the buffer. */
	vistart->fs_type[7] = '\0';
40203450:	e3a03000 	mov	r3, #0
40203454:	e5c53019 	strb	r3, [r5, #25]
40203458:	e2855012 	add	r5, r5, #18

	if (*fatsize == 32) {
4020345c:	e5943000 	ldr	r3, [r4]
40203460:	e3530020 	cmp	r3, #32
40203464:	1a000005 	bne	40203480 <read_bootsectandvi+0xa8>
		if (compare_sign(FAT32_SIGN, vistart->fs_type) == 0) {
40203468:	e59f0058 	ldr	r0, [pc, #88]	; 402034c8 <read_bootsectandvi+0xf0>
4020346c:	e1a01005 	mov	r1, r5
40203470:	ebffffcc 	bl	402033a8 <compare_sign>
40203474:	e3500000 	cmp	r0, #0
40203478:	0a00000f 	beq	402034bc <read_bootsectandvi+0xe4>
4020347c:	ea00000d 	b	402034b8 <read_bootsectandvi+0xe0>
			return 0;
		}
	} else {
		if (compare_sign(FAT12_SIGN, vistart->fs_type) == 0) {
40203480:	e59f0044 	ldr	r0, [pc, #68]	; 402034cc <read_bootsectandvi+0xf4>
40203484:	e1a01005 	mov	r1, r5
40203488:	ebffffc6 	bl	402033a8 <compare_sign>
4020348c:	e3500000 	cmp	r0, #0
			*fatsize = 12;
40203490:	03a0300c 	moveq	r3, #12
	if (*fatsize == 32) {
		if (compare_sign(FAT32_SIGN, vistart->fs_type) == 0) {
			return 0;
		}
	} else {
		if (compare_sign(FAT12_SIGN, vistart->fs_type) == 0) {
40203494:	0a000005 	beq	402034b0 <read_bootsectandvi+0xd8>
			*fatsize = 12;
			return 0;
		}
		if (compare_sign(FAT16_SIGN, vistart->fs_type) == 0) {
40203498:	e59f0030 	ldr	r0, [pc, #48]	; 402034d0 <read_bootsectandvi+0xf8>
4020349c:	e1a01005 	mov	r1, r5
402034a0:	ebffffc0 	bl	402033a8 <compare_sign>
402034a4:	e3500000 	cmp	r0, #0
402034a8:	1a000002 	bne	402034b8 <read_bootsectandvi+0xe0>
			*fatsize = 16;
402034ac:	e3a03010 	mov	r3, #16
402034b0:	e5843000 	str	r3, [r4]
			return 0;
402034b4:	ea000000 	b	402034bc <read_bootsectandvi+0xe4>
402034b8:	e3e00000 	mvn	r0, #0
		}
	}

	FAT_DPRINT("Error: broken fs_type sign\n");
	return -1;
}
402034bc:	e28ddc02 	add	sp, sp, #512	; 0x200
402034c0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
402034c4:	40204c05 	.word	0x40204c05
402034c8:	40204c1a 	.word	0x40204c1a
402034cc:	40204c23 	.word	0x40204c23
402034d0:	40204c2c 	.word	0x40204c2c

402034d4 <fat_register_device>:
}


int
fat_register_device(block_dev_desc_t *dev_desc, int part_no)
{
402034d4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	unsigned char buffer[SECTOR_SIZE];

	if (!dev_desc->block_read)
402034d8:	e590c060 	ldr	ip, [r0, #96]	; 0x60
}


int
fat_register_device(block_dev_desc_t *dev_desc, int part_no)
{
402034dc:	e24ddc02 	sub	sp, sp, #512	; 0x200
402034e0:	e1a04000 	mov	r4, r0
	unsigned char buffer[SECTOR_SIZE];

	if (!dev_desc->block_read)
402034e4:	e35c0000 	cmp	ip, #0
402034e8:	0a000021 	beq	40203574 <fat_register_device+0xa0>
		return -1;
	cur_dev=dev_desc;
402034ec:	e59f508c 	ldr	r5, [pc, #140]	; 40203580 <fat_register_device+0xac>
	/* check if we have a MBR (on floppies we have only a PBR) */
	if (dev_desc->block_read (dev_desc->dev, 0, 1, (ulong *) buffer) != 1) {
402034f0:	e3a01000 	mov	r1, #0
402034f4:	e3a02001 	mov	r2, #1
402034f8:	e1a0300d 	mov	r3, sp
402034fc:	e1a0600d 	mov	r6, sp
{
	unsigned char buffer[SECTOR_SIZE];

	if (!dev_desc->block_read)
		return -1;
	cur_dev=dev_desc;
40203500:	e5850004 	str	r0, [r5, #4]
	/* check if we have a MBR (on floppies we have only a PBR) */
	if (dev_desc->block_read (dev_desc->dev, 0, 1, (ulong *) buffer) != 1) {
40203504:	e5900004 	ldr	r0, [r0, #4]
40203508:	e12fff3c 	blx	ip
4020350c:	e3500001 	cmp	r0, #1
40203510:	e1a07000 	mov	r7, r0
40203514:	0a000003 	beq	40203528 <fat_register_device+0x54>
		printf ("** Can't read from device %d **\n", dev_desc->dev);
40203518:	e59f0064 	ldr	r0, [pc, #100]	; 40203584 <fat_register_device+0xb0>
4020351c:	e5941004 	ldr	r1, [r4, #4]
40203520:	ebfffe19 	bl	40202d8c <serial_printf>
40203524:	ea000012 	b	40203574 <fat_register_device+0xa0>
		return -1;
	}
	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
40203528:	e5dd31fe 	ldrb	r3, [sp, #510]	; 0x1fe
4020352c:	e3530055 	cmp	r3, #85	; 0x55
40203530:	1a00000f 	bne	40203574 <fat_register_device+0xa0>
		buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) {
40203534:	e5dd31ff 	ldrb	r3, [sp, #511]	; 0x1ff
40203538:	e35300aa 	cmp	r3, #170	; 0xaa
4020353c:	1a00000c 	bne	40203574 <fat_register_device+0xa0>
		/* no signature found */
		return -1;
	}
	if(!strncmp((char *)&buffer[DOS_FS_TYPE_OFFSET],"FAT",3)) {
40203540:	e3a02003 	mov	r2, #3
40203544:	e28d0052 	add	r0, sp, #82	; 0x52
40203548:	e59f1038 	ldr	r1, [pc, #56]	; 40203588 <fat_register_device+0xb4>
4020354c:	ebffff46 	bl	4020326c <strncmp>
40203550:	e59f3034 	ldr	r3, [pc, #52]	; 4020358c <fat_register_device+0xb8>
40203554:	e3500000 	cmp	r0, #0
		/* ok, we assume we are on a PBR only */
		cur_part = 1;
40203558:	05837000 	streq	r7, [r3]
		part_offset=0;
4020355c:	05850000 	streq	r0, [r5]
		/* FIXME we need to determine the start block of the
		 * partition where the DOS FS resides. This can be done
		 * by using the get_partition_info routine. For this
		 * purpose the libpart must be included.
		 */
		part_offset=63;
40203560:	13a0203f 	movne	r2, #63	; 0x3f
		//part_offset=0;
		cur_part = 1;
40203564:	15837000 	strne	r7, [r3]
		/* FIXME we need to determine the start block of the
		 * partition where the DOS FS resides. This can be done
		 * by using the get_partition_info routine. For this
		 * purpose the libpart must be included.
		 */
		part_offset=63;
40203568:	15852000 	strne	r2, [r5]
		//part_offset=0;
		cur_part = 1;
4020356c:	13a00000 	movne	r0, #0
40203570:	ea000000 	b	40203578 <fat_register_device+0xa4>
40203574:	e3e00000 	mvn	r0, #0
#endif
	}
	return 0;
}
40203578:	e28ddc02 	add	sp, sp, #512	; 0x200
4020357c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
40203580:	40204fe8 	.word	0x40204fe8
40203584:	40204c35 	.word	0x40204c35
40203588:	40204c56 	.word	0x40204c56
4020358c:	40204f64 	.word	0x40204f64

40203590 <file_fat_detectfs>:
}


int
file_fat_detectfs(void)
{
40203590:	e92d4070 	push	{r4, r5, r6, lr}
	boot_sector	bs;
	volume_info	volinfo;
	int		fatsize;
	char	vol_label[12];

	if(cur_dev==NULL) {
40203594:	e59f4108 	ldr	r4, [pc, #264]	; 402036a4 <file_fat_detectfs+0x114>
}


int
file_fat_detectfs(void)
{
40203598:	e24dd06c 	sub	sp, sp, #108	; 0x6c
	boot_sector	bs;
	volume_info	volinfo;
	int		fatsize;
	char	vol_label[12];

	if(cur_dev==NULL) {
4020359c:	e5943004 	ldr	r3, [r4, #4]
402035a0:	e3530000 	cmp	r3, #0
		printf("No current device\n");
402035a4:	059f00fc 	ldreq	r0, [pc, #252]	; 402036a8 <file_fat_detectfs+0x118>
	boot_sector	bs;
	volume_info	volinfo;
	int		fatsize;
	char	vol_label[12];

	if(cur_dev==NULL) {
402035a8:	0a00002a 	beq	40203658 <file_fat_detectfs+0xc8>
		printf("No current device\n");
		return 1;
	}
#if (CONFIG_COMMANDS & CFG_CMD_IDE) || (CONFIG_COMMANDS & CFG_CMD_SCSI) || \
    (CONFIG_COMMANDS & CFG_CMD_USB) || (CONFIG_MMC)
	printf("Interface:  ");
402035ac:	e59f00f8 	ldr	r0, [pc, #248]	; 402036ac <file_fat_detectfs+0x11c>
402035b0:	ebfffdf5 	bl	40202d8c <serial_printf>
	switch(cur_dev->if_type) {
402035b4:	e5943004 	ldr	r3, [r4, #4]
402035b8:	e5933000 	ldr	r3, [r3]
402035bc:	e2433001 	sub	r3, r3, #1
402035c0:	e3530005 	cmp	r3, #5
402035c4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
402035c8:	ea000011 	b	40203614 <file_fat_detectfs+0x84>
402035cc:	402035e4 	.word	0x402035e4
402035d0:	402035ec 	.word	0x402035ec
402035d4:	402035f4 	.word	0x402035f4
402035d8:	402035fc 	.word	0x402035fc
402035dc:	40203604 	.word	0x40203604
402035e0:	4020360c 	.word	0x4020360c
		case IF_TYPE_IDE :	printf("IDE"); break;
402035e4:	e59f00c4 	ldr	r0, [pc, #196]	; 402036b0 <file_fat_detectfs+0x120>
402035e8:	ea00000a 	b	40203618 <file_fat_detectfs+0x88>
		case IF_TYPE_SCSI :	printf("SCSI"); break;
402035ec:	e59f00c0 	ldr	r0, [pc, #192]	; 402036b4 <file_fat_detectfs+0x124>
402035f0:	ea000008 	b	40203618 <file_fat_detectfs+0x88>
		case IF_TYPE_ATAPI :	printf("ATAPI"); break;
402035f4:	e59f00bc 	ldr	r0, [pc, #188]	; 402036b8 <file_fat_detectfs+0x128>
402035f8:	ea000006 	b	40203618 <file_fat_detectfs+0x88>
		case IF_TYPE_USB :	printf("USB"); break;
402035fc:	e59f00b8 	ldr	r0, [pc, #184]	; 402036bc <file_fat_detectfs+0x12c>
40203600:	ea000004 	b	40203618 <file_fat_detectfs+0x88>
		case IF_TYPE_DOC :	printf("DOC"); break;
40203604:	e59f00b4 	ldr	r0, [pc, #180]	; 402036c0 <file_fat_detectfs+0x130>
40203608:	ea000002 	b	40203618 <file_fat_detectfs+0x88>
		case IF_TYPE_MMC :	printf("MMC"); break;
4020360c:	e59f00b0 	ldr	r0, [pc, #176]	; 402036c4 <file_fat_detectfs+0x134>
40203610:	ea000000 	b	40203618 <file_fat_detectfs+0x88>
		default :		printf("Unknown");
40203614:	e59f00ac 	ldr	r0, [pc, #172]	; 402036c8 <file_fat_detectfs+0x138>
	}
	printf("\n  Device %d: ",cur_dev->dev);
40203618:	e59f4084 	ldr	r4, [pc, #132]	; 402036a4 <file_fat_detectfs+0x114>
		case IF_TYPE_SCSI :	printf("SCSI"); break;
		case IF_TYPE_ATAPI :	printf("ATAPI"); break;
		case IF_TYPE_USB :	printf("USB"); break;
		case IF_TYPE_DOC :	printf("DOC"); break;
		case IF_TYPE_MMC :	printf("MMC"); break;
		default :		printf("Unknown");
4020361c:	ebfffdda 	bl	40202d8c <serial_printf>
	}
	printf("\n  Device %d: ",cur_dev->dev);
	dev_print(cur_dev);
#endif
	if(read_bootsectandvi(&bs, &volinfo, &fatsize)) {
40203620:	e28d5040 	add	r5, sp, #64	; 0x40
		case IF_TYPE_USB :	printf("USB"); break;
		case IF_TYPE_DOC :	printf("DOC"); break;
		case IF_TYPE_MMC :	printf("MMC"); break;
		default :		printf("Unknown");
	}
	printf("\n  Device %d: ",cur_dev->dev);
40203624:	e59f00a0 	ldr	r0, [pc, #160]	; 402036cc <file_fat_detectfs+0x13c>
40203628:	e5943004 	ldr	r3, [r4, #4]
4020362c:	e5931004 	ldr	r1, [r3, #4]
40203630:	ebfffdd5 	bl	40202d8c <serial_printf>
	dev_print(cur_dev);
40203634:	e5940004 	ldr	r0, [r4, #4]
40203638:	eb00020c 	bl	40203e70 <dev_print>
#endif
	if(read_bootsectandvi(&bs, &volinfo, &fatsize)) {
4020363c:	e1a0000d 	mov	r0, sp
40203640:	e1a01005 	mov	r1, r5
40203644:	e28d2068 	add	r2, sp, #104	; 0x68
40203648:	ebffff62 	bl	402033d8 <read_bootsectandvi>
4020364c:	e2504000 	subs	r4, r0, #0
40203650:	0a000003 	beq	40203664 <file_fat_detectfs+0xd4>
		printf("\nNo valid FAT fs found\n");
40203654:	e59f0074 	ldr	r0, [pc, #116]	; 402036d0 <file_fat_detectfs+0x140>
40203658:	ebfffdcb 	bl	40202d8c <serial_printf>
4020365c:	e3a00001 	mov	r0, #1
		return 1;
40203660:	ea00000d 	b	4020369c <file_fat_detectfs+0x10c>
	}
	memcpy (vol_label, volinfo.volume_label, 11);
40203664:	e28d605c 	add	r6, sp, #92	; 0x5c
40203668:	e2851007 	add	r1, r5, #7
4020366c:	e3a0200b 	mov	r2, #11
40203670:	e1a00006 	mov	r0, r6
40203674:	ebffff21 	bl	40203300 <memcpy>
	vol_label[11] = '\0';
	volinfo.fs_type[5]='\0';
	printf("Partition %d: Filesystem: %s \"%s\"\n",cur_part,volinfo.fs_type,vol_label);
40203678:	e59f3054 	ldr	r3, [pc, #84]	; 402036d4 <file_fat_detectfs+0x144>
4020367c:	e59f0054 	ldr	r0, [pc, #84]	; 402036d8 <file_fat_detectfs+0x148>
40203680:	e2852012 	add	r2, r5, #18
	if(read_bootsectandvi(&bs, &volinfo, &fatsize)) {
		printf("\nNo valid FAT fs found\n");
		return 1;
	}
	memcpy (vol_label, volinfo.volume_label, 11);
	vol_label[11] = '\0';
40203684:	e5cd4067 	strb	r4, [sp, #103]	; 0x67
	volinfo.fs_type[5]='\0';
	printf("Partition %d: Filesystem: %s \"%s\"\n",cur_part,volinfo.fs_type,vol_label);
40203688:	e5931000 	ldr	r1, [r3]
4020368c:	e1a03006 	mov	r3, r6
		printf("\nNo valid FAT fs found\n");
		return 1;
	}
	memcpy (vol_label, volinfo.volume_label, 11);
	vol_label[11] = '\0';
	volinfo.fs_type[5]='\0';
40203690:	e5cd4057 	strb	r4, [sp, #87]	; 0x57
	printf("Partition %d: Filesystem: %s \"%s\"\n",cur_part,volinfo.fs_type,vol_label);
40203694:	ebfffdbc 	bl	40202d8c <serial_printf>
40203698:	e1a00004 	mov	r0, r4
	return 0;
}
4020369c:	e28dd06c 	add	sp, sp, #108	; 0x6c
402036a0:	e8bd8070 	pop	{r4, r5, r6, pc}
402036a4:	40204fe8 	.word	0x40204fe8
402036a8:	40204c5a 	.word	0x40204c5a
402036ac:	40204c6d 	.word	0x40204c6d
402036b0:	40204c7a 	.word	0x40204c7a
402036b4:	40204c7e 	.word	0x40204c7e
402036b8:	40204c83 	.word	0x40204c83
402036bc:	40204c89 	.word	0x40204c89
402036c0:	40204c8d 	.word	0x40204c8d
402036c4:	40204c91 	.word	0x40204c91
402036c8:	40204c95 	.word	0x40204c95
402036cc:	40204c9d 	.word	0x40204c9d
402036d0:	40204cac 	.word	0x40204cac
402036d4:	40204f64 	.word	0x40204f64
402036d8:	40204cc4 	.word	0x40204cc4

402036dc <T.33>:
/*
 * Read at most 'size' bytes from the specified cluster into 'buffer'.
 * Return 0 on success, -1 otherwise.
 */
static int
get_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer, unsigned long size)
402036dc:	e59f3090 	ldr	r3, [pc, #144]	; 40203774 <T.33+0x98>
{
	int idx = 0;
	__u32 startsect;

	if (clustnum > 0) {
402036e0:	e3500000 	cmp	r0, #0
/*
 * Read at most 'size' bytes from the specified cluster into 'buffer'.
 * Return 0 on success, -1 otherwise.
 */
static int
get_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer, unsigned long size)
402036e4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
		startsect = mydata->data_begin + clustnum*mydata->clust_size;
	} else {
		startsect = mydata->rootdir_sect;
	}

	if (disk_read(startsect, size/FS_BLOCK_SIZE , buffer) < 0) {
402036e8:	e1a054a2 	lsr	r5, r2, #9
{
	int idx = 0;
	__u32 startsect;

	if (clustnum > 0) {
		startsect = mydata->data_begin + clustnum*mydata->clust_size;
402036ec:	11d361b2 	ldrhne	r6, [r3, #18]
/*
 * Read at most 'size' bytes from the specified cluster into 'buffer'.
 * Return 0 on success, -1 otherwise.
 */
static int
get_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer, unsigned long size)
402036f0:	e1a0a001 	mov	sl, r1
{
	int idx = 0;
	__u32 startsect;

	if (clustnum > 0) {
		startsect = mydata->data_begin + clustnum*mydata->clust_size;
402036f4:	11d331f4 	ldrshne	r3, [r3, #20]
/*
 * Read at most 'size' bytes from the specified cluster into 'buffer'.
 * Return 0 on success, -1 otherwise.
 */
static int
get_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer, unsigned long size)
402036f8:	e24ddc02 	sub	sp, sp, #512	; 0x200
	__u32 startsect;

	if (clustnum > 0) {
		startsect = mydata->data_begin + clustnum*mydata->clust_size;
	} else {
		startsect = mydata->rootdir_sect;
402036fc:	01d361b0 	ldrheq	r6, [r3, #16]
/*
 * Read at most 'size' bytes from the specified cluster into 'buffer'.
 * Return 0 on success, -1 otherwise.
 */
static int
get_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer, unsigned long size)
40203700:	e1a04002 	mov	r4, r2
		startsect = mydata->data_begin + clustnum*mydata->clust_size;
	} else {
		startsect = mydata->rootdir_sect;
	}

	if (disk_read(startsect, size/FS_BLOCK_SIZE , buffer) < 0) {
40203704:	e1a01005 	mov	r1, r5
40203708:	e1a0200a 	mov	r2, sl
{
	int idx = 0;
	__u32 startsect;

	if (clustnum > 0) {
		startsect = mydata->data_begin + clustnum*mydata->clust_size;
4020370c:	10263096 	mlane	r6, r6, r0, r3
	} else {
		startsect = mydata->rootdir_sect;
	}

	if (disk_read(startsect, size/FS_BLOCK_SIZE , buffer) < 0) {
40203710:	e1a00006 	mov	r0, r6
40203714:	ebffff02 	bl	40203324 <disk_read>
40203718:	e3500000 	cmp	r0, #0
4020371c:	ba000011 	blt	40203768 <T.33+0x8c>
		FAT_DPRINT("Error reading data\n");
		return -1;
	}
	if(size % FS_BLOCK_SIZE) {
40203720:	e1a04b84 	lsl	r4, r4, #23
40203724:	e1a04ba4 	lsr	r4, r4, #23
40203728:	e3540000 	cmp	r4, #0
4020372c:	01a00004 	moveq	r0, r4
40203730:	0a00000d 	beq	4020376c <T.33+0x90>
		__u8 tmpbuf[FS_BLOCK_SIZE];
		idx= size/FS_BLOCK_SIZE;
		if (disk_read(startsect + idx, 1, tmpbuf) < 0) {
40203734:	e0860005 	add	r0, r6, r5
40203738:	e3a01001 	mov	r1, #1
4020373c:	e1a0200d 	mov	r2, sp
40203740:	e1a0700d 	mov	r7, sp
40203744:	ebfffef6 	bl	40203324 <disk_read>
40203748:	e3500000 	cmp	r0, #0
4020374c:	ba000005 	blt	40203768 <T.33+0x8c>
			FAT_DPRINT("Error reading data\n");
			return -1;
		}
		buffer += idx*FS_BLOCK_SIZE;

		memcpy(buffer, tmpbuf, size % FS_BLOCK_SIZE);
40203750:	e08a0485 	add	r0, sl, r5, lsl #9
40203754:	e1a0100d 	mov	r1, sp
40203758:	e1a02004 	mov	r2, r4
4020375c:	ebfffee7 	bl	40203300 <memcpy>
40203760:	e3a00000 	mov	r0, #0
40203764:	ea000000 	b	4020376c <T.33+0x90>
40203768:	e3e00000 	mvn	r0, #0
		return 0;
	}

	return 0;
}
4020376c:	e28ddc02 	add	sp, sp, #512	; 0x200
40203770:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
40203774:	40204fe8 	.word	0x40204fe8

40203778 <T.34>:
{
	__u32 bufnum;
	__u32 offset;
	__u32 ret = 0x00;

	switch (mydata->fatsize) {
40203778:	e59f315c 	ldr	r3, [pc, #348]	; 402038dc <T.34+0x164>
/*
 * Get the entry at index 'entry' in a FAT (12/16/32) table.
 * On failure 0x00 is returned.
 */
static __u32
get_fatent(fsdata *mydata, __u32 entry)
4020377c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
40203780:	e1a05000 	mov	r5, r0
{
	__u32 bufnum;
	__u32 offset;
	__u32 ret = 0x00;

	switch (mydata->fatsize) {
40203784:	e5933008 	ldr	r3, [r3, #8]
40203788:	e3530010 	cmp	r3, #16
4020378c:	0a000009 	beq	402037b8 <T.34+0x40>
40203790:	e3530020 	cmp	r3, #32
40203794:	0a000002 	beq	402037a4 <T.34+0x2c>
40203798:	e353000c 	cmp	r3, #12
4020379c:	0a00000b 	beq	402037d0 <T.34+0x58>
402037a0:	ea00004b 	b	402038d4 <T.34+0x15c>
	case 32:
		bufnum = entry / FAT32BUFSIZE;
402037a4:	e3a01c03 	mov	r1, #768	; 0x300
402037a8:	ebfffc62 	bl	40202938 <__udivsi3>
		offset = entry - bufnum * FAT32BUFSIZE;
402037ac:	e3a03c03 	mov	r3, #768	; 0x300
	__u32 offset;
	__u32 ret = 0x00;

	switch (mydata->fatsize) {
	case 32:
		bufnum = entry / FAT32BUFSIZE;
402037b0:	e1a04000 	mov	r4, r0
402037b4:	ea000003 	b	402037c8 <T.34+0x50>
		offset = entry - bufnum * FAT32BUFSIZE;
		break;
	case 16:
		bufnum = entry / FAT16BUFSIZE;
402037b8:	e3a01c06 	mov	r1, #1536	; 0x600
402037bc:	ebfffc5d 	bl	40202938 <__udivsi3>
		offset = entry - bufnum * FAT16BUFSIZE;
402037c0:	e3a03c06 	mov	r3, #1536	; 0x600
	case 32:
		bufnum = entry / FAT32BUFSIZE;
		offset = entry - bufnum * FAT32BUFSIZE;
		break;
	case 16:
		bufnum = entry / FAT16BUFSIZE;
402037c4:	e1a04000 	mov	r4, r0
		offset = entry - bufnum * FAT16BUFSIZE;
402037c8:	e0655493 	mls	r5, r3, r4, r5
402037cc:	ea000001 	b	402037d8 <T.34+0x60>
		break;
	case 12:
		bufnum = entry / FAT12BUFSIZE;
402037d0:	e1a045a0 	lsr	r4, r0, #11
		offset = entry - bufnum * FAT12BUFSIZE;
402037d4:	e0405584 	sub	r5, r0, r4, lsl #11
	default:
		/* Unsupported FAT size */
		return ret;
	}
	/* Read a new block of FAT entries into the cache. */
	if (bufnum != mydata->fatbufnum) {
402037d8:	e59f60fc 	ldr	r6, [pc, #252]	; 402038dc <T.34+0x164>
402037dc:	e3037018 	movw	r7, #12312	; 0x3018
402037e0:	e7963007 	ldr	r3, [r6, r7]
402037e4:	e1540003 	cmp	r4, r3
402037e8:	0a00000b 	beq	4020381c <T.34+0xa4>
		int getsize = FATBUFSIZE/FS_BLOCK_SIZE;
		__u8 *bufptr = (__u8 *)mydata->fatbuf;
		__u32 fatlength = mydata->fatlength;
402037ec:	e1d610bc 	ldrh	r1, [r6, #12]

		fatlength *= SECTOR_SIZE;	/* We want it in bytes now */
		startblock += mydata->fat_sect;	/* Offset from start of disk */

		if (getsize > fatlength) getsize = fatlength;
		if (disk_read(startblock, getsize, bufptr) < 0) {
402037f0:	e3a00006 	mov	r0, #6
		__u8 *bufptr = (__u8 *)mydata->fatbuf;
		__u32 fatlength = mydata->fatlength;
		__u32 startblock = bufnum * FATBUFBLOCKS;

		fatlength *= SECTOR_SIZE;	/* We want it in bytes now */
		startblock += mydata->fat_sect;	/* Offset from start of disk */
402037f4:	e1d630be 	ldrh	r3, [r6, #14]

		if (getsize > fatlength) getsize = fatlength;
		if (disk_read(startblock, getsize, bufptr) < 0) {
402037f8:	e2862018 	add	r2, r6, #24
		int getsize = FATBUFSIZE/FS_BLOCK_SIZE;
		__u8 *bufptr = (__u8 *)mydata->fatbuf;
		__u32 fatlength = mydata->fatlength;
		__u32 startblock = bufnum * FATBUFBLOCKS;

		fatlength *= SECTOR_SIZE;	/* We want it in bytes now */
402037fc:	e1a01481 	lsl	r1, r1, #9
		startblock += mydata->fat_sect;	/* Offset from start of disk */

		if (getsize > fatlength) getsize = fatlength;
		if (disk_read(startblock, getsize, bufptr) < 0) {
40203800:	e3510006 	cmp	r1, #6
40203804:	23a01006 	movcs	r1, #6
40203808:	e0203490 	mla	r0, r0, r4, r3
4020380c:	ebfffec4 	bl	40203324 <disk_read>
40203810:	e3500000 	cmp	r0, #0
40203814:	ba00002e 	blt	402038d4 <T.34+0x15c>
			FAT_DPRINT("Error reading FAT blocks\n");
			return ret;
		}
		mydata->fatbufnum = bufnum;
40203818:	e7864007 	str	r4, [r6, r7]
	}

	/* Get the actual entry from the table */
	switch (mydata->fatsize) {
4020381c:	e59f30b8 	ldr	r3, [pc, #184]	; 402038dc <T.34+0x164>
40203820:	e5932008 	ldr	r2, [r3, #8]
40203824:	e3520010 	cmp	r2, #16
	case 32:
		ret = FAT2CPU32(((__u32*)mydata->fatbuf)[offset]);
		break;
	case 16:
		ret = FAT2CPU16(((__u16*)mydata->fatbuf)[offset]);
40203828:	00835085 	addeq	r5, r3, r5, lsl #1
4020382c:	01d501b8 	ldrheq	r0, [r5, #24]
		}
		mydata->fatbufnum = bufnum;
	}

	/* Get the actual entry from the table */
	switch (mydata->fatsize) {
40203830:	08bd80f0 	popeq	{r4, r5, r6, r7, pc}
40203834:	e3520020 	cmp	r2, #32
	case 32:
		ret = FAT2CPU32(((__u32*)mydata->fatbuf)[offset]);
40203838:	00835105 	addeq	r5, r3, r5, lsl #2
4020383c:	05950018 	ldreq	r0, [r5, #24]
		}
		mydata->fatbufnum = bufnum;
	}

	/* Get the actual entry from the table */
	switch (mydata->fatsize) {
40203840:	08bd80f0 	popeq	{r4, r5, r6, r7, pc}
40203844:	e352000c 	cmp	r2, #12
40203848:	1a000021 	bne	402038d4 <T.34+0x15c>
		break;
	case 16:
		ret = FAT2CPU16(((__u16*)mydata->fatbuf)[offset]);
		break;
	case 12: {
		__u32 off16 = (offset*3)/4;
4020384c:	e3a02003 	mov	r2, #3
40203850:	e0020592 	mul	r2, r2, r5
		__u16 val1, val2;

		switch (offset & 0x3) {
40203854:	e2055003 	and	r5, r5, #3
40203858:	e3550002 	cmp	r5, #2
		break;
	case 16:
		ret = FAT2CPU16(((__u16*)mydata->fatbuf)[offset]);
		break;
	case 12: {
		__u32 off16 = (offset*3)/4;
4020385c:	e1a02122 	lsr	r2, r2, #2
		__u16 val1, val2;

		switch (offset & 0x3) {
40203860:	0a00000e 	beq	402038a0 <T.34+0x128>
40203864:	e3550003 	cmp	r5, #3
40203868:	0a000015 	beq	402038c4 <T.34+0x14c>
4020386c:	e3550001 	cmp	r5, #1
40203870:	e1a05082 	lsl	r5, r2, #1
		case 0:
			ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
			ret &= 0xfff;
			break;
		case 1:
			val1 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
40203874:	02833018 	addeq	r3, r3, #24
		__u32 off16 = (offset*3)/4;
		__u16 val1, val2;

		switch (offset & 0x3) {
		case 0:
			ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
40203878:	10833005 	addne	r3, r3, r5
			ret &= 0xfff;
			break;
		case 1:
			val1 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
4020387c:	019500b3 	ldrheq	r0, [r5, r3]
			val1 &= 0xf000;
			val2 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16+1]);
40203880:	00833082 	addeq	r3, r3, r2, lsl #1
		__u32 off16 = (offset*3)/4;
		__u16 val1, val2;

		switch (offset & 0x3) {
		case 0:
			ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
40203884:	11d301b8 	ldrhne	r0, [r3, #24]
		case 1:
			val1 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
			val1 &= 0xf000;
			val2 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16+1]);
			val2 &= 0x00ff;
			ret = (val2 << 4) | (val1 >> 12);
40203888:	05d33002 	ldrbeq	r3, [r3, #2]
4020388c:	01a00620 	lsreq	r0, r0, #12
		__u16 val1, val2;

		switch (offset & 0x3) {
		case 0:
			ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
			ret &= 0xfff;
40203890:	11a00a00 	lslne	r0, r0, #20
		case 1:
			val1 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
			val1 &= 0xf000;
			val2 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16+1]);
			val2 &= 0x00ff;
			ret = (val2 << 4) | (val1 >> 12);
40203894:	01800203 	orreq	r0, r0, r3, lsl #4
		__u16 val1, val2;

		switch (offset & 0x3) {
		case 0:
			ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
			ret &= 0xfff;
40203898:	11a00a20 	lsrne	r0, r0, #20
4020389c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
			val2 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16+1]);
			val2 &= 0x00ff;
			ret = (val2 << 4) | (val1 >> 12);
			break;
		case 2:
			val1 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
402038a0:	e2833018 	add	r3, r3, #24
402038a4:	e1a01082 	lsl	r1, r2, #1
402038a8:	e19110b3 	ldrh	r1, [r1, r3]
			val1 &= 0xff00;
			val2 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16+1]);
402038ac:	e0833082 	add	r3, r3, r2, lsl #1
402038b0:	e1d300b2 	ldrh	r0, [r3, #2]
			val2 &= 0x000f;
			ret = (val2 << 8) | (val1 >> 8);
402038b4:	e1a03421 	lsr	r3, r1, #8
402038b8:	e200000f 	and	r0, r0, #15
402038bc:	e1830400 	orr	r0, r3, r0, lsl #8
402038c0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
			break;
		case 3:
			ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);;
			ret = (ret & 0xfff0) >> 4;
402038c4:	e0833082 	add	r3, r3, r2, lsl #1
402038c8:	e1d301b8 	ldrh	r0, [r3, #24]
402038cc:	e1a00220 	lsr	r0, r0, #4
402038d0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
402038d4:	e3a00000 	mov	r0, #0
	break;
	}
	FAT_DPRINT("ret: %d, offset: %d\n", ret, offset);

	return ret;
}
402038d8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
402038dc:	40204fe8 	.word	0x40204fe8

402038e0 <do_fat_read>:
fsdata datablock;

long
do_fat_read(const char *filename, void *buffer, unsigned long maxsize,
	     int dols)
{
402038e0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    int idx, isdir = 0;
    int files = 0, dirs = 0;
    long ret = 0;
    int firsttime;

    if (read_bootsectandvi (&bs, &volinfo, &mydata->fatsize)) {
402038e4:	e59f652c 	ldr	r6, [pc, #1324]	; 40203e18 <do_fat_read+0x538>
fsdata datablock;

long
do_fat_read(const char *filename, void *buffer, unsigned long maxsize,
	     int dols)
{
402038e8:	e24ddf4a 	sub	sp, sp, #296	; 0x128
402038ec:	e1a04000 	mov	r4, r0
402038f0:	e1a07002 	mov	r7, r2
    int idx, isdir = 0;
    int files = 0, dirs = 0;
    long ret = 0;
    int firsttime;

    if (read_bootsectandvi (&bs, &volinfo, &mydata->fatsize)) {
402038f4:	e59f0520 	ldr	r0, [pc, #1312]	; 40203e1c <do_fat_read+0x53c>
fsdata datablock;

long
do_fat_read(const char *filename, void *buffer, unsigned long maxsize,
	     int dols)
{
402038f8:	e58d1014 	str	r1, [sp, #20]
    int idx, isdir = 0;
    int files = 0, dirs = 0;
    long ret = 0;
    int firsttime;

    if (read_bootsectandvi (&bs, &volinfo, &mydata->fatsize)) {
402038fc:	e2862008 	add	r2, r6, #8
40203900:	e59f1518 	ldr	r1, [pc, #1304]	; 40203e20 <do_fat_read+0x540>
fsdata datablock;

long
do_fat_read(const char *filename, void *buffer, unsigned long maxsize,
	     int dols)
{
40203904:	e1a05003 	mov	r5, r3
    int idx, isdir = 0;
    int files = 0, dirs = 0;
    long ret = 0;
    int firsttime;

    if (read_bootsectandvi (&bs, &volinfo, &mydata->fatsize)) {
40203908:	ebfffeb2 	bl	402033d8 <read_bootsectandvi>
4020390c:	e59fa510 	ldr	sl, [pc, #1296]	; 40203e24 <do_fat_read+0x544>
40203910:	e3500000 	cmp	r0, #0
	printf ("Error: reading boot sector\n");
40203914:	159f050c 	ldrne	r0, [pc, #1292]	; 40203e28 <do_fat_read+0x548>
    int idx, isdir = 0;
    int files = 0, dirs = 0;
    long ret = 0;
    int firsttime;

    if (read_bootsectandvi (&bs, &volinfo, &mydata->fatsize)) {
40203918:	1a000124 	bne	40203db0 <do_fat_read+0x4d0>
	printf ("Error: reading boot sector\n");
	return -1;
    }
	//printf("kai test-1...\n");
    if (mydata->fatsize == 32) {
4020391c:	e5963008 	ldr	r3, [r6, #8]
	mydata->fatlength = bs.fat32_length;
    } else {
	mydata->fatlength = bs.fat_length;
    }
    mydata->fat_sect = bs.reserved;
40203920:	e59f24fc 	ldr	r2, [pc, #1276]	; 40203e24 <do_fat_read+0x544>
    if (read_bootsectandvi (&bs, &volinfo, &mydata->fatsize)) {
	printf ("Error: reading boot sector\n");
	return -1;
    }
	//printf("kai test-1...\n");
    if (mydata->fatsize == 32) {
40203924:	e3530020 	cmp	r3, #32
	mydata->fatlength = bs.fat32_length;
    } else {
	mydata->fatlength = bs.fat_length;
40203928:	159f34fc 	ldrne	r3, [pc, #1276]	; 40203e2c <do_fat_read+0x54c>
	printf ("Error: reading boot sector\n");
	return -1;
    }
	//printf("kai test-1...\n");
    if (mydata->fatsize == 32) {
	mydata->fatlength = bs.fat32_length;
4020392c:	051a3fb0 	ldreq	r3, [sl, #-4016]	; 0xfb0
    } else {
	mydata->fatlength = bs.fat_length;
    }
    mydata->fat_sect = bs.reserved;
    cursect = mydata->rootdir_sect
	    = mydata->fat_sect + mydata->fatlength * bs.fats;
40203930:	e5520fc4 	ldrb	r0, [r2, #-4036]	; 0xfc4
    }
	//printf("kai test-1...\n");
    if (mydata->fatsize == 32) {
	mydata->fatlength = bs.fat32_length;
    } else {
	mydata->fatlength = bs.fat_length;
40203934:	119a30b3 	ldrhne	r3, [sl, r3]
40203938:	e1c630bc 	strh	r3, [r6, #12]
    }
    mydata->fat_sect = bs.reserved;
4020393c:	e59f34ec 	ldr	r3, [pc, #1260]	; 40203e30 <do_fat_read+0x550>
40203940:	e19210b3 	ldrh	r1, [r2, r3]
40203944:	e59f34cc 	ldr	r3, [pc, #1228]	; 40203e18 <do_fat_read+0x538>
    cursect = mydata->rootdir_sect
	    = mydata->fat_sect + mydata->fatlength * bs.fats;
40203948:	e1d3a0bc 	ldrh	sl, [r3, #12]
    if (mydata->fatsize == 32) {
	mydata->fatlength = bs.fat32_length;
    } else {
	mydata->fatlength = bs.fat_length;
    }
    mydata->fat_sect = bs.reserved;
4020394c:	e1c310be 	strh	r1, [r3, #14]
    cursect = mydata->rootdir_sect
	    = mydata->fat_sect + mydata->fatlength * bs.fats;
40203950:	e02a109a 	mla	sl, sl, r0, r1
    mydata->clust_size = bs.cluster_size;
    if (mydata->fatsize == 32) {
40203954:	e5930008 	ldr	r0, [r3, #8]
	mydata->fatlength = bs.fat_length;
    }
    mydata->fat_sect = bs.reserved;
    cursect = mydata->rootdir_sect
	    = mydata->fat_sect + mydata->fatlength * bs.fats;
    mydata->clust_size = bs.cluster_size;
40203958:	e5521fc7 	ldrb	r1, [r2, #-4039]	; 0xfc7
    if (mydata->fatsize == 32) {
4020395c:	e3500020 	cmp	r0, #32
	mydata->data_begin = mydata->rootdir_sect   /* + rootdir_size */
		- (mydata->clust_size * 2);
    } else {
	rootdir_size = ((bs.dir_entries[1] * (int) 256 + bs.dir_entries[0])
			* sizeof (dir_entry)) / SECTOR_SIZE;
	mydata->data_begin = mydata->rootdir_sect + rootdir_size
40203960:	13e00001 	mvnne	r0, #1
	mydata->fatlength = bs.fat_length;
    }
    mydata->fat_sect = bs.reserved;
    cursect = mydata->rootdir_sect
	    = mydata->fat_sect + mydata->fatlength * bs.fats;
    mydata->clust_size = bs.cluster_size;
40203964:	e1c311b2 	strh	r1, [r3, #18]
    } else {
	mydata->fatlength = bs.fat_length;
    }
    mydata->fat_sect = bs.reserved;
    cursect = mydata->rootdir_sect
	    = mydata->fat_sect + mydata->fatlength * bs.fats;
40203968:	e6ffa07a 	uxth	sl, sl
    mydata->clust_size = bs.cluster_size;
    if (mydata->fatsize == 32) {
	rootdir_size = mydata->clust_size;
	mydata->data_begin = mydata->rootdir_sect   /* + rootdir_size */
4020396c:	03e02001 	mvneq	r2, #1
	mydata->fatlength = bs.fat32_length;
    } else {
	mydata->fatlength = bs.fat_length;
    }
    mydata->fat_sect = bs.reserved;
    cursect = mydata->rootdir_sect
40203970:	e1c3a1b0 	strh	sl, [r3, #16]
	mydata->data_begin = mydata->rootdir_sect   /* + rootdir_size */
		- (mydata->clust_size * 2);
    } else {
	rootdir_size = ((bs.dir_entries[1] * (int) 256 + bs.dir_entries[0])
			* sizeof (dir_entry)) / SECTOR_SIZE;
	mydata->data_begin = mydata->rootdir_sect + rootdir_size
40203974:	1021a190 	mlane	r1, r0, r1, sl
40203978:	15520fc2 	ldrbne	r0, [r2, #-4034]	; 0xfc2
    cursect = mydata->rootdir_sect
	    = mydata->fat_sect + mydata->fatlength * bs.fats;
    mydata->clust_size = bs.cluster_size;
    if (mydata->fatsize == 32) {
	rootdir_size = mydata->clust_size;
	mydata->data_begin = mydata->rootdir_sect   /* + rootdir_size */
4020397c:	0021a192 	mlaeq	r1, r2, r1, sl
		- (mydata->clust_size * 2);
    } else {
	rootdir_size = ((bs.dir_entries[1] * (int) 256 + bs.dir_entries[0])
			* sizeof (dir_entry)) / SECTOR_SIZE;
	mydata->data_begin = mydata->rootdir_sect + rootdir_size
40203980:	15522fc3 	ldrbne	r2, [r2, #-4035]	; 0xfc3
40203984:	10822400 	addne	r2, r2, r0, lsl #8
40203988:	10811222 	addne	r1, r1, r2, lsr #4
		- (mydata->clust_size * 2);
    }
    mydata->fatbufnum = -1;
4020398c:	e59f2484 	ldr	r2, [pc, #1156]	; 40203e18 <do_fat_read+0x538>
	mydata->data_begin = mydata->rootdir_sect   /* + rootdir_size */
		- (mydata->clust_size * 2);
    } else {
	rootdir_size = ((bs.dir_entries[1] * (int) 256 + bs.dir_entries[0])
			* sizeof (dir_entry)) / SECTOR_SIZE;
	mydata->data_begin = mydata->rootdir_sect + rootdir_size
40203990:	e1c311b4 	strh	r1, [r3, #20]
		- (mydata->clust_size * 2);
    }
    mydata->fatbufnum = -1;
40203994:	e3033018 	movw	r3, #12312	; 0x3018
40203998:	e3e01000 	mvn	r1, #0
4020399c:	e7821003 	str	r1, [r2, r3]
		mydata->rootdir_sect, mydata->rootdir_sect * SECTOR_SIZE,
		rootdir_size, mydata->data_begin);
    FAT_DPRINT ("Cluster size: %d\n", mydata->clust_size);

    /* "cwd" is always the root... */
    while (ISDIRDELIM (*filename))
402039a0:	ea000000 	b	402039a8 <do_fat_read+0xc8>
	filename++;
402039a4:	e2844001 	add	r4, r4, #1
		mydata->rootdir_sect, mydata->rootdir_sect * SECTOR_SIZE,
		rootdir_size, mydata->data_begin);
    FAT_DPRINT ("Cluster size: %d\n", mydata->clust_size);

    /* "cwd" is always the root... */
    while (ISDIRDELIM (*filename))
402039a8:	e5d4b000 	ldrb	fp, [r4]
402039ac:	e35b002f 	cmp	fp, #47	; 0x2f
402039b0:	135b005c 	cmpne	fp, #92	; 0x5c
402039b4:	13a0b000 	movne	fp, #0
402039b8:	03a0b001 	moveq	fp, #1
402039bc:	0afffff8 	beq	402039a4 <do_fat_read+0xc4>
	filename++;
    /* Make a copy of the filename and convert it to lowercase */
    strcpy((char *)fnamecopy, filename);
402039c0:	e59f946c 	ldr	r9, [pc, #1132]	; 40203e34 <do_fat_read+0x554>
402039c4:	e1a01004 	mov	r1, r4
402039c8:	e5990004 	ldr	r0, [r9, #4]
402039cc:	ebfffe38 	bl	402032b4 <strcpy>
    downcase((char *)fnamecopy);
402039d0:	e5990004 	ldr	r0, [r9, #4]
402039d4:	ebfffe18 	bl	4020323c <downcase>
    if (*fnamecopy == '\0') {
402039d8:	e5990004 	ldr	r0, [r9, #4]
402039dc:	e5d03000 	ldrb	r3, [r0]
402039e0:	e3530000 	cmp	r3, #0
402039e4:	1a000006 	bne	40203a04 <do_fat_read+0x124>
	if (!dols){
402039e8:	e3550000 	cmp	r5, #0
402039ec:	158d3000 	strne	r3, [sp]
402039f0:	13a05002 	movne	r5, #2
402039f4:	159f643c 	ldrne	r6, [pc, #1084]	; 40203e38 <do_fat_read+0x558>
402039f8:	1a000017 	bne	40203a5c <do_fat_read+0x17c>
		printf("\n not there\n");
402039fc:	e59f0438 	ldr	r0, [pc, #1080]	; 40203e3c <do_fat_read+0x55c>
40203a00:	ea0000ea 	b	40203db0 <do_fat_read+0x4d0>
	    return -1;
	}
	dols = LS_ROOT;
    } else if((idx = dirdelim((char *)fnamecopy)) >= 0) {
40203a04:	ebfffe5a 	bl	40203374 <dirdelim>
40203a08:	e3500000 	cmp	r0, #0
40203a0c:	ba00000d 	blt	40203a48 <do_fat_read+0x168>
	isdir = 1;
	fnamecopy[idx] = '\0';
40203a10:	e5993004 	ldr	r3, [r9, #4]
	subname = (char *)fnamecopy + idx + 1;
40203a14:	e2806001 	add	r6, r0, #1
	    return -1;
	}
	dols = LS_ROOT;
    } else if((idx = dirdelim((char *)fnamecopy)) >= 0) {
	isdir = 1;
	fnamecopy[idx] = '\0';
40203a18:	e7c3b000 	strb	fp, [r3, r0]
	subname = (char *)fnamecopy + idx + 1;
40203a1c:	e5993004 	ldr	r3, [r9, #4]
40203a20:	e0866003 	add	r6, r6, r3
	/* Handle multiple delimiters */
	while (ISDIRDELIM (*subname))
40203a24:	ea000000 	b	40203a2c <do_fat_read+0x14c>
	    subname++;
40203a28:	e2866001 	add	r6, r6, #1
    } else if((idx = dirdelim((char *)fnamecopy)) >= 0) {
	isdir = 1;
	fnamecopy[idx] = '\0';
	subname = (char *)fnamecopy + idx + 1;
	/* Handle multiple delimiters */
	while (ISDIRDELIM (*subname))
40203a2c:	e5d63000 	ldrb	r3, [r6]
40203a30:	e353002f 	cmp	r3, #47	; 0x2f
40203a34:	1353005c 	cmpne	r3, #92	; 0x5c
40203a38:	0afffffa 	beq	40203a28 <do_fat_read+0x148>
40203a3c:	e3a03001 	mov	r3, #1
40203a40:	e58d3000 	str	r3, [sp]
40203a44:	ea000004 	b	40203a5c <do_fat_read+0x17c>
	    subname++;
    } else if (dols) {
40203a48:	e59f63e8 	ldr	r6, [pc, #1000]	; 40203e38 <do_fat_read+0x558>
40203a4c:	e3550000 	cmp	r5, #0
40203a50:	13a03001 	movne	r3, #1
40203a54:	03a03000 	moveq	r3, #0
40203a58:	e58d3000 	str	r3, [sp]
	mydata->fatlength = bs.fat32_length;
    } else {
	mydata->fatlength = bs.fat_length;
    }
    mydata->fat_sect = bs.reserved;
    cursect = mydata->rootdir_sect
40203a5c:	e58da00c 	str	sl, [sp, #12]
40203a60:	e1a0a006 	mov	sl, r6
40203a64:	e3a03000 	mov	r3, #0
40203a68:	e58d3004 	str	r3, [sp, #4]
40203a6c:	e58d3008 	str	r3, [sp, #8]
    }
	//printf("kai test-2...\n");
    while (1) {
	int i;
	//printf("kai test-xxxxx...\n");
	if (disk_read (cursect, mydata->clust_size, do_fat_read_block) < 0) {
40203a70:	e59f33a0 	ldr	r3, [pc, #928]	; 40203e18 <do_fat_read+0x538>
40203a74:	e59f43b8 	ldr	r4, [pc, #952]	; 40203e34 <do_fat_read+0x554>
40203a78:	e59d000c 	ldr	r0, [sp, #12]
40203a7c:	e1d311b2 	ldrh	r1, [r3, #18]
40203a80:	e5942008 	ldr	r2, [r4, #8]
40203a84:	ebfffe26 	bl	40203324 <disk_read>
40203a88:	e3500000 	cmp	r0, #0
	    printf ("Error: reading rootdir block\n");
40203a8c:	b59f03ac 	ldrlt	r0, [pc, #940]	; 40203e40 <do_fat_read+0x560>
40203a90:	ba0000c6 	blt	40203db0 <do_fat_read+0x4d0>
	    return -1;
	}
	//printf("kai test-11111...\n");
	dentptr = (dir_entry *) do_fat_read_block;
40203a94:	e5943008 	ldr	r3, [r4, #8]
40203a98:	e2834020 	add	r4, r3, #32
boot_sector bs;
volume_info volinfo;
fsdata datablock;

long
do_fat_read(const char *filename, void *buffer, unsigned long maxsize,
40203a9c:	e2833e22 	add	r3, r3, #544	; 0x220
40203aa0:	e58d3010 	str	r3, [sp, #16]
	    printf ("Error: reading rootdir block\n");
	    return -1;
	}
	//printf("kai test-11111...\n");
	dentptr = (dir_entry *) do_fat_read_block;
	for (i = 0; i < DIRENTSPERBLOCK; i++) {
40203aa4:	ea00006f 	b	40203c68 <do_fat_read+0x388>
	    char s_name[14], l_name[256];

	    l_name[0] = '\0';
40203aa8:	e3a03000 	mov	r3, #0
40203aac:	e5cd3018 	strb	r3, [sp, #24]
	    if ((dentptr->attr & ATTR_VOLUME)) {
40203ab0:	e5543015 	ldrb	r3, [r4, #-21]
40203ab4:	e2133008 	ands	r3, r3, #8
40203ab8:	1a000069 	bne	40203c64 <do_fat_read+0x384>
		    /* Volume label or VFAT entry */
		    dentptr++;
		    continue;
	    } else if (dentptr->name[0] == 0) {
40203abc:	e554b020 	ldrb	fp, [r4, #-32]
40203ac0:	e35b0000 	cmp	fp, #0
40203ac4:	1a000007 	bne	40203ae8 <do_fat_read+0x208>
		FAT_DPRINT ("RootDentname == NULL - %d\n", i);
		if (dols == LS_ROOT) {
40203ac8:	e3550002 	cmp	r5, #2
40203acc:	1a0000cd 	bne	40203e08 <do_fat_read+0x528>
		    printf ("\n%d file(s), %d dir(s)\n\n", files, dirs);
40203ad0:	e59f036c 	ldr	r0, [pc, #876]	; 40203e44 <do_fat_read+0x564>
40203ad4:	e1a0600b 	mov	r6, fp
40203ad8:	e59d1008 	ldr	r1, [sp, #8]
40203adc:	e59d2004 	ldr	r2, [sp, #4]
40203ae0:	ebfffca9 	bl	40202d8c <serial_printf>
		    return 0;
40203ae4:	ea0000c8 	b	40203e0c <do_fat_read+0x52c>
		}
		return -1;
	    }
#ifdef CONFIG_SUPPORT_VFAT
	    else if (dols == LS_ROOT
40203ae8:	e3550002 	cmp	r5, #2
40203aec:	1a000002 	bne	40203afc <do_fat_read+0x21c>
mkcksum(const char *str)
{
	int i;
	__u8 ret = 0;

	for (i = 0; i < 11; i++) {
40203af0:	e2833001 	add	r3, r3, #1
40203af4:	e353000b 	cmp	r3, #11
40203af8:	1afffffc 	bne	40203af0 <do_fat_read+0x210>
 */
static void get_name (dir_entry *dirent, char *s_name)
{
	char *ptr;

	memcpy (s_name, dirent->name, 8);
40203afc:	e28d6f46 	add	r6, sp, #280	; 0x118
40203b00:	e1a01009 	mov	r1, r9
40203b04:	e3a02008 	mov	r2, #8
40203b08:	e1a00006 	mov	r0, r6
40203b0c:	ebfffdfb 	bl	40203300 <memcpy>
	s_name[8] = '\0';
40203b10:	e3a03000 	mov	r3, #0
40203b14:	e5cd3120 	strb	r3, [sp, #288]	; 0x120
40203b18:	ea000000 	b	40203b20 <do_fat_read+0x240>
	ptr = s_name;
	while (*ptr && *ptr != ' ')
		ptr++;
40203b1c:	e2866001 	add	r6, r6, #1
	char *ptr;

	memcpy (s_name, dirent->name, 8);
	s_name[8] = '\0';
	ptr = s_name;
	while (*ptr && *ptr != ' ')
40203b20:	e5d6b000 	ldrb	fp, [r6]
40203b24:	e35b0020 	cmp	fp, #32
40203b28:	135b0000 	cmpne	fp, #0
40203b2c:	03a0b000 	moveq	fp, #0
40203b30:	13a0b001 	movne	fp, #1
40203b34:	1afffff8 	bne	40203b1c <do_fat_read+0x23c>
		ptr++;
	if (dirent->ext[0] && dirent->ext[0] != ' ') {
40203b38:	e5543018 	ldrb	r3, [r4, #-24]
40203b3c:	e3530020 	cmp	r3, #32
40203b40:	13530000 	cmpne	r3, #0
40203b44:	0a00000c 	beq	40203b7c <do_fat_read+0x29c>
		*ptr = '.';
40203b48:	e3a0302e 	mov	r3, #46	; 0x2e
		ptr++;
		memcpy (ptr, dirent->ext, 3);
40203b4c:	e2891008 	add	r1, r9, #8
	s_name[8] = '\0';
	ptr = s_name;
	while (*ptr && *ptr != ' ')
		ptr++;
	if (dirent->ext[0] && dirent->ext[0] != ' ') {
		*ptr = '.';
40203b50:	e4c63001 	strb	r3, [r6], #1
		ptr++;
		memcpy (ptr, dirent->ext, 3);
40203b54:	e3a02003 	mov	r2, #3
40203b58:	e1a00006 	mov	r0, r6
40203b5c:	ebfffde7 	bl	40203300 <memcpy>
		ptr[3] = '\0';
40203b60:	e5c6b003 	strb	fp, [r6, #3]
40203b64:	ea000000 	b	40203b6c <do_fat_read+0x28c>
		while (*ptr && *ptr != ' ')
			ptr++;
40203b68:	e2866001 	add	r6, r6, #1
	if (dirent->ext[0] && dirent->ext[0] != ' ') {
		*ptr = '.';
		ptr++;
		memcpy (ptr, dirent->ext, 3);
		ptr[3] = '\0';
		while (*ptr && *ptr != ' ')
40203b6c:	e5d63000 	ldrb	r3, [r6]
40203b70:	e3530020 	cmp	r3, #32
40203b74:	13530000 	cmpne	r3, #0
40203b78:	1afffffa 	bne	40203b68 <do_fat_read+0x288>
			ptr++;
	}
	*ptr = '\0';
40203b7c:	e3a03000 	mov	r3, #0
40203b80:	e5c63000 	strb	r3, [r6]
	if (*s_name == DELETED_FLAG)
40203b84:	e5dd2118 	ldrb	r2, [sp, #280]	; 0x118
40203b88:	e35200e5 	cmp	r2, #229	; 0xe5
40203b8c:	0a000002 	beq	40203b9c <do_fat_read+0x2bc>
		*s_name = '\0';
	else if (*s_name == aRING)
40203b90:	e3520005 	cmp	r2, #5
40203b94:	1a000001 	bne	40203ba0 <do_fat_read+0x2c0>
		*s_name = '';
40203b98:	e3e0301a 	mvn	r3, #26
40203b9c:	e5cd3118 	strb	r3, [sp, #280]	; 0x118
	downcase (s_name);
40203ba0:	e28d6f46 	add	r6, sp, #280	; 0x118
40203ba4:	e1a00006 	mov	r0, r6
40203ba8:	ebfffda3 	bl	4020323c <downcase>
		dentptr++;
		continue;
	    }
#endif
	    get_name (dentptr, s_name);
	    if (dols == LS_ROOT) {
40203bac:	e3550002 	cmp	r5, #2
40203bb0:	1a000018 	bne	40203c18 <do_fat_read+0x338>
		int isdir = (dentptr->attr & ATTR_DIR);
		char dirc;
		int doit = 0;

		if (isdir) {
40203bb4:	e5543015 	ldrb	r3, [r4, #-21]
40203bb8:	e3130010 	tst	r3, #16
40203bbc:	e5dd3118 	ldrb	r3, [sp, #280]	; 0x118
40203bc0:	0a000009 	beq	40203bec <do_fat_read+0x30c>
		    dirc = '/';
		    if (s_name[0] != 0) {
40203bc4:	e3530000 	cmp	r3, #0
40203bc8:	0a000025 	beq	40203c64 <do_fat_read+0x384>
			dirs++;
40203bcc:	e59d3004 	ldr	r3, [sp, #4]
		    if (dirc == ' ') {
			printf (" %8ld   %s%c\n",
				(long) FAT2CPU32 (dentptr->size), s_name,
				dirc);
		    } else {
			printf ("            %s%c\n", s_name, dirc);
40203bd0:	e1a01006 	mov	r1, r6
40203bd4:	e59f026c 	ldr	r0, [pc, #620]	; 40203e48 <do_fat_read+0x568>
40203bd8:	e3a0202f 	mov	r2, #47	; 0x2f
		int doit = 0;

		if (isdir) {
		    dirc = '/';
		    if (s_name[0] != 0) {
			dirs++;
40203bdc:	e2833001 	add	r3, r3, #1
40203be0:	e58d3004 	str	r3, [sp, #4]
		    if (dirc == ' ') {
			printf (" %8ld   %s%c\n",
				(long) FAT2CPU32 (dentptr->size), s_name,
				dirc);
		    } else {
			printf ("            %s%c\n", s_name, dirc);
40203be4:	ebfffc68 	bl	40202d8c <serial_printf>
40203be8:	ea00001d 	b	40203c64 <do_fat_read+0x384>
			dirs++;
			doit = 1;
		    }
		} else {
		    dirc = ' ';
		    if (s_name[0] != 0) {
40203bec:	e3530000 	cmp	r3, #0
40203bf0:	0a00001b 	beq	40203c64 <do_fat_read+0x384>
			files++;
40203bf4:	e59d3008 	ldr	r3, [sp, #8]
			doit = 1;
		    }
		}
		if (doit) {
		    if (dirc == ' ') {
			printf (" %8ld   %s%c\n",
40203bf8:	e1a02006 	mov	r2, r6
40203bfc:	e59f0248 	ldr	r0, [pc, #584]	; 40203e4c <do_fat_read+0x56c>
			doit = 1;
		    }
		} else {
		    dirc = ' ';
		    if (s_name[0] != 0) {
			files++;
40203c00:	e2833001 	add	r3, r3, #1
40203c04:	e58d3008 	str	r3, [sp, #8]
			doit = 1;
		    }
		}
		if (doit) {
		    if (dirc == ' ') {
			printf (" %8ld   %s%c\n",
40203c08:	e3a03020 	mov	r3, #32
40203c0c:	e5141004 	ldr	r1, [r4, #-4]
40203c10:	ebfffc5d 	bl	40202d8c <serial_printf>
40203c14:	ea000012 	b	40203c64 <do_fat_read+0x384>
		    }
		}
		dentptr++;
		continue;
	    }
	    if (strcmp((char *)fnamecopy, s_name) &&
40203c18:	e59fb214 	ldr	fp, [pc, #532]	; 40203e34 <do_fat_read+0x554>
40203c1c:	e1a01006 	mov	r1, r6
40203c20:	e59b0004 	ldr	r0, [fp, #4]
40203c24:	ebfffda9 	bl	402032d0 <strcmp>
40203c28:	e3500000 	cmp	r0, #0
40203c2c:	0a000004 	beq	40203c44 <do_fat_read+0x364>
		strcmp((char *)fnamecopy, l_name)) {
40203c30:	e59b0004 	ldr	r0, [fp, #4]
40203c34:	e28d1018 	add	r1, sp, #24
40203c38:	ebfffda4 	bl	402032d0 <strcmp>
		    }
		}
		dentptr++;
		continue;
	    }
	    if (strcmp((char *)fnamecopy, s_name) &&
40203c3c:	e3500000 	cmp	r0, #0
40203c40:	1a000007 	bne	40203c64 <do_fat_read+0x384>
		FAT_DPRINT ("RootMismatch: |%s|%s|\n", s_name, l_name);
		dentptr++;
		continue;
	    }
	//printf("kai test-11111...\n");
	    if (isdir && !(dentptr->attr & ATTR_DIR))
40203c44:	e59d3000 	ldr	r3, [sp]
40203c48:	e1a0600a 	mov	r6, sl
40203c4c:	e3530000 	cmp	r3, #0
40203c50:	0a000025 	beq	40203cec <do_fat_read+0x40c>
40203c54:	e5d9300b 	ldrb	r3, [r9, #11]
40203c58:	e3130010 	tst	r3, #16
40203c5c:	1a000009 	bne	40203c88 <do_fat_read+0x3a8>
40203c60:	ea000068 	b	40203e08 <do_fat_read+0x528>
40203c64:	e2844020 	add	r4, r4, #32
	    printf ("Error: reading rootdir block\n");
	    return -1;
	}
	//printf("kai test-11111...\n");
	dentptr = (dir_entry *) do_fat_read_block;
	for (i = 0; i < DIRENTSPERBLOCK; i++) {
40203c68:	e59d3010 	ldr	r3, [sp, #16]
		FAT_DPRINT ("RootMismatch: |%s|%s|\n", s_name, l_name);
		dentptr++;
		continue;
	    }
	//printf("kai test-11111...\n");
	    if (isdir && !(dentptr->attr & ATTR_DIR))
40203c6c:	e2449020 	sub	r9, r4, #32
	    printf ("Error: reading rootdir block\n");
	    return -1;
	}
	//printf("kai test-11111...\n");
	dentptr = (dir_entry *) do_fat_read_block;
	for (i = 0; i < DIRENTSPERBLOCK; i++) {
40203c70:	e1540003 	cmp	r4, r3
40203c74:	1affff8b 	bne	40203aa8 <do_fat_read+0x1c8>
			FAT2CPU32 (dentptr->size), isdir ? "(DIR)" : "");

	    goto rootdir_done;  /* We got a match */

	}
	cursect++;
40203c78:	e59d300c 	ldr	r3, [sp, #12]
40203c7c:	e2833001 	add	r3, r3, #1
40203c80:	e58d300c 	str	r3, [sp, #12]
    }
40203c84:	eaffff79 	b	40203a70 <do_fat_read+0x190>
	dir_entry dent;
	char *nextname = NULL;

	dent = *dentptr;
	dentptr = &dent;
	idx = dirdelim (subname);
40203c88:	e1a0000a 	mov	r0, sl
40203c8c:	ebfffdb8 	bl	40203374 <dirdelim>
	if (idx >= 0) {
40203c90:	e3500000 	cmp	r0, #0
40203c94:	ba00000a 	blt	40203cc4 <do_fat_read+0x3e4>
	    subname[idx] = '\0';
40203c98:	e3a03000 	mov	r3, #0
40203c9c:	e7ca3000 	strb	r3, [sl, r0]
	    nextname = subname + idx + 1;
40203ca0:	e2800001 	add	r0, r0, #1
40203ca4:	e08a6000 	add	r6, sl, r0
	    /* Handle multiple delimiters */
	    while (ISDIRDELIM (*nextname))
40203ca8:	e7d62003 	ldrb	r2, [r6, r3]
40203cac:	e2833001 	add	r3, r3, #1
40203cb0:	e352002f 	cmp	r2, #47	; 0x2f
40203cb4:	1352005c 	cmpne	r2, #92	; 0x5c
40203cb8:	0afffffa 	beq	40203ca8 <do_fat_read+0x3c8>
40203cbc:	e3a03001 	mov	r3, #1
40203cc0:	ea000001 	b	40203ccc <do_fat_read+0x3ec>
40203cc4:	e2553000 	subs	r3, r5, #0
40203cc8:	13a03001 	movne	r3, #1
	    }
	}

	if (get_dentfromdir (mydata, startsect, subname, dentptr,
			     isdir ? 0 : dols) == NULL) {
	    if (dols && !isdir)
40203ccc:	e2233001 	eor	r3, r3, #1
40203cd0:	e3550000 	cmp	r5, #0
40203cd4:	03a05000 	moveq	r5, #0
40203cd8:	12035001 	andne	r5, r3, #1
40203cdc:	e3550000 	cmp	r5, #0
40203ce0:	13a06000 	movne	r6, #0
40203ce4:	1a000048 	bne	40203e0c <do_fat_read+0x52c>
40203ce8:	ea000046 	b	40203e08 <do_fat_read+0x528>
static long
get_contents(fsdata *mydata, dir_entry *dentptr, __u8 *buffer,
	     unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
	unsigned int bytesperclust = mydata->clust_size * SECTOR_SIZE;
40203cec:	e59f2124 	ldr	r2, [pc, #292]	; 40203e18 <do_fat_read+0x538>
	    if (!(dentptr->attr & ATTR_DIR))
		return -1;
	    subname = nextname;
	}
    }
    ret = get_contents (mydata, dentptr, buffer, maxsize);
40203cf0:	e3a06000 	mov	r6, #0
 */
static long
get_contents(fsdata *mydata, dir_entry *dentptr, __u8 *buffer,
	     unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
40203cf4:	e599301c 	ldr	r3, [r9, #28]
	unsigned int bytesperclust = mydata->clust_size * SECTOR_SIZE;
	__u32 curclust = START(dentptr);
40203cf8:	e1d911ba 	ldrh	r1, [r9, #26]
static long
get_contents(fsdata *mydata, dir_entry *dentptr, __u8 *buffer,
	     unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
	unsigned int bytesperclust = mydata->clust_size * SECTOR_SIZE;
40203cfc:	e1d2b1b2 	ldrh	fp, [r2, #18]
	__u32 curclust = START(dentptr);
40203d00:	e5922008 	ldr	r2, [r2, #8]
	    if (!(dentptr->attr & ATTR_DIR))
		return -1;
	    subname = nextname;
	}
    }
    ret = get_contents (mydata, dentptr, buffer, maxsize);
40203d04:	e59da014 	ldr	sl, [sp, #20]
get_contents(fsdata *mydata, dir_entry *dentptr, __u8 *buffer,
	     unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
	unsigned int bytesperclust = mydata->clust_size * SECTOR_SIZE;
	__u32 curclust = START(dentptr);
40203d08:	e3520020 	cmp	r2, #32
static long
get_contents(fsdata *mydata, dir_entry *dentptr, __u8 *buffer,
	     unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
	unsigned int bytesperclust = mydata->clust_size * SECTOR_SIZE;
40203d0c:	e1a0b48b 	lsl	fp, fp, #9
	__u32 curclust = START(dentptr);
40203d10:	01d951b4 	ldrheq	r5, [r9, #20]
	    if (!(dentptr->attr & ATTR_DIR))
		return -1;
	    subname = nextname;
	}
    }
    ret = get_contents (mydata, dentptr, buffer, maxsize);
40203d14:	e1a0400b 	mov	r4, fp
get_contents(fsdata *mydata, dir_entry *dentptr, __u8 *buffer,
	     unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
	unsigned int bytesperclust = mydata->clust_size * SECTOR_SIZE;
	__u32 curclust = START(dentptr);
40203d18:	159d5000 	ldrne	r5, [sp]
40203d1c:	01a05805 	lsleq	r5, r5, #16
	__u32 endclust, newclust;
	unsigned long actsize;

	FAT_DPRINT("Filesize: %ld bytes\n", filesize);

	if (maxsize > 0 && filesize > maxsize) filesize = maxsize;
40203d20:	e3570000 	cmp	r7, #0
40203d24:	11530007 	cmpne	r3, r7
get_contents(fsdata *mydata, dir_entry *dentptr, __u8 *buffer,
	     unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
	unsigned int bytesperclust = mydata->clust_size * SECTOR_SIZE;
	__u32 curclust = START(dentptr);
40203d28:	e0855001 	add	r5, r5, r1
	__u32 endclust, newclust;
	unsigned long actsize;

	FAT_DPRINT("Filesize: %ld bytes\n", filesize);

	if (maxsize > 0 && filesize > maxsize) filesize = maxsize;
40203d2c:	91a07003 	movls	r7, r3
	    if (!(dentptr->attr & ATTR_DIR))
		return -1;
	    subname = nextname;
	}
    }
    ret = get_contents (mydata, dentptr, buffer, maxsize);
40203d30:	e1a09005 	mov	r9, r5
40203d34:	ea00000a 	b	40203d64 <do_fat_read+0x484>
	actsize=bytesperclust;
	endclust=curclust;
	do {
		/* search for consecutive clusters */
		while(actsize < filesize) {
			newclust = get_fatent(mydata, endclust);
40203d38:	e1a00005 	mov	r0, r5
40203d3c:	ebfffe8d 	bl	40203778 <T.34>
			if((newclust -1)!=endclust)
40203d40:	e2403001 	sub	r3, r0, #1
40203d44:	e1530005 	cmp	r3, r5
40203d48:	1a00001a 	bne	40203db8 <do_fat_read+0x4d8>
				goto getit;
			if (newclust <= 0x0001 || newclust >= 0xfff0) {
40203d4c:	e2402002 	sub	r2, r0, #2
40203d50:	e30f3fed 	movw	r3, #65517	; 0xffed
40203d54:	e1520003 	cmp	r2, r3
40203d58:	8a00002b 	bhi	40203e0c <do_fat_read+0x52c>
				FAT_DPRINT("curclust: 0x%x\n", newclust);
				FAT_DPRINT("Invalid FAT entry\n");
				return gotsize;
			}
			endclust=newclust;
			actsize+= bytesperclust;
40203d5c:	e084400b 	add	r4, r4, fp
40203d60:	e1a05000 	mov	r5, r0

	actsize=bytesperclust;
	endclust=curclust;
	do {
		/* search for consecutive clusters */
		while(actsize < filesize) {
40203d64:	e1540007 	cmp	r4, r7
40203d68:	3afffff2 	bcc	40203d38 <do_fat_read+0x458>
			}
			endclust=newclust;
			actsize+= bytesperclust;
		}
		/* actsize >= file size */
		actsize -= bytesperclust;
40203d6c:	e06b4004 	rsb	r4, fp, r4
		/* get remaining clusters */
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
40203d70:	e1a00009 	mov	r0, r9
40203d74:	e1a0100a 	mov	r1, sl
40203d78:	e1a02004 	mov	r2, r4
40203d7c:	ebfffe56 	bl	402036dc <T.33>
40203d80:	e3500000 	cmp	r0, #0
40203d84:	1a000008 	bne	40203dac <do_fat_read+0x4cc>
			FAT_ERROR("Error reading cluster\n");
			return -1;
		}
		/* get remaining bytes */
		gotsize += (int)actsize;
		filesize -= actsize;
40203d88:	e0647007 	rsb	r7, r4, r7
		buffer += actsize;
		actsize= filesize;
		if (get_cluster(mydata, endclust, buffer, (int)actsize) != 0) {
40203d8c:	e1a00005 	mov	r0, r5
40203d90:	e08a1004 	add	r1, sl, r4
40203d94:	e1a02007 	mov	r2, r7
40203d98:	ebfffe4f 	bl	402036dc <T.33>
40203d9c:	e3500000 	cmp	r0, #0
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
			FAT_ERROR("Error reading cluster\n");
			return -1;
		}
		/* get remaining bytes */
		gotsize += (int)actsize;
40203da0:	00846006 	addeq	r6, r4, r6
		if (get_cluster(mydata, endclust, buffer, (int)actsize) != 0) {
			FAT_ERROR("Error reading cluster\n");
			return -1;
		}
		gotsize+=actsize;
		return gotsize;
40203da4:	00866007 	addeq	r6, r6, r7
		/* get remaining bytes */
		gotsize += (int)actsize;
		filesize -= actsize;
		buffer += actsize;
		actsize= filesize;
		if (get_cluster(mydata, endclust, buffer, (int)actsize) != 0) {
40203da8:	0a000017 	beq	40203e0c <do_fat_read+0x52c>
			FAT_ERROR("Error reading cluster\n");
40203dac:	e59f009c 	ldr	r0, [pc, #156]	; 40203e50 <do_fat_read+0x570>
40203db0:	ebfffbf5 	bl	40202d8c <serial_printf>
40203db4:	ea000013 	b	40203e08 <do_fat_read+0x528>
			return -1;
		}
		gotsize+=actsize;
		return gotsize;
getit:
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
40203db8:	e1a00009 	mov	r0, r9
40203dbc:	e1a0100a 	mov	r1, sl
40203dc0:	e1a02004 	mov	r2, r4
40203dc4:	ebfffe44 	bl	402036dc <T.33>
40203dc8:	e3500000 	cmp	r0, #0
40203dcc:	1afffff6 	bne	40203dac <do_fat_read+0x4cc>
			return -1;
		}
		gotsize += (int)actsize;
		filesize -= actsize;
		buffer += actsize;
		curclust = get_fatent(mydata, endclust);
40203dd0:	e1a00005 	mov	r0, r5
getit:
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
			FAT_ERROR("Error reading cluster\n");
			return -1;
		}
		gotsize += (int)actsize;
40203dd4:	e0866004 	add	r6, r6, r4
		filesize -= actsize;
		buffer += actsize;
		curclust = get_fatent(mydata, endclust);
40203dd8:	ebfffe66 	bl	40203778 <T.34>
		if (curclust <= 0x0001 || curclust >= 0xfff0) {
40203ddc:	e30f3fed 	movw	r3, #65517	; 0xffed
40203de0:	e2402002 	sub	r2, r0, #2
40203de4:	e1520003 	cmp	r2, r3
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
			FAT_ERROR("Error reading cluster\n");
			return -1;
		}
		gotsize += (int)actsize;
		filesize -= actsize;
40203de8:	90647007 	rsbls	r7, r4, r7
		buffer += actsize;
40203dec:	908aa004 	addls	sl, sl, r4
40203df0:	91a09000 	movls	r9, r0
40203df4:	91a0400b 	movls	r4, fp
40203df8:	9affffd8 	bls	40203d60 <do_fat_read+0x480>
		curclust = get_fatent(mydata, endclust);
		if (curclust <= 0x0001 || curclust >= 0xfff0) {
			FAT_DPRINT("curclust: 0x%x\n", curclust);
			FAT_ERROR("Invalid FAT entry\n");
40203dfc:	e59f0050 	ldr	r0, [pc, #80]	; 40203e54 <do_fat_read+0x574>
40203e00:	ebfffbe1 	bl	40202d8c <serial_printf>
40203e04:	ea000000 	b	40203e0c <do_fat_read+0x52c>
			return gotsize;
40203e08:	e3e06000 	mvn	r6, #0
    ret = get_contents (mydata, dentptr, buffer, maxsize);
	//printf("kai test-3...\n");
    FAT_DPRINT ("Size: %d, got: %ld\n", FAT2CPU32 (dentptr->size), ret);

    return ret;
}
40203e0c:	e1a00006 	mov	r0, r6
40203e10:	e28ddf4a 	add	sp, sp, #296	; 0x128
40203e14:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
40203e18:	40204fe8 	.word	0x40204fe8
40203e1c:	40208004 	.word	0x40208004
40203e20:	40208044 	.word	0x40208044
40203e24:	40208fd8 	.word	0x40208fd8
40203e28:	40204ce7 	.word	0x40204ce7
40203e2c:	fffff042 	.word	0xfffff042
40203e30:	fffff03a 	.word	0xfffff03a
40203e34:	40204f64 	.word	0x40204f64
40203e38:	40204d46 	.word	0x40204d46
40203e3c:	40204d03 	.word	0x40204d03
40203e40:	40204d10 	.word	0x40204d10
40203e44:	40204d2e 	.word	0x40204d2e
40203e48:	40204d47 	.word	0x40204d47
40203e4c:	40204d59 	.word	0x40204d59
40203e50:	40204d67 	.word	0x40204d67
40203e54:	40204d7e 	.word	0x40204d7e

40203e58 <file_fat_read>:

long
file_fat_read(const char *filename, void *buffer, unsigned long maxsize)
{
	long ret;
	ret = do_fat_read(filename, buffer, maxsize, LS_NO);
40203e58:	e3a03000 	mov	r3, #0
40203e5c:	eafffe9f 	b	402038e0 <do_fat_read>

40203e60 <file_fat_ls>:


int
file_fat_ls(const char *dir)
{
	return do_fat_read(dir, NULL, 0, LS_YES);
40203e60:	e3a01000 	mov	r1, #0
40203e64:	e3a03001 	mov	r3, #1
40203e68:	e1a02001 	mov	r2, r1
40203e6c:	eafffe9b 	b	402038e0 <do_fat_read>

40203e70 <dev_print>:
/* ------------------------------------------------------------------------- */
/*
 * reports device info to the user
 */
void dev_print (block_dev_desc_t *dev_desc)
{
40203e70:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	uint64_t lba512; /* number of blocks if 512bytes block size */
#else
	lbaint_t lba512;
#endif

	if (dev_desc->type==DEV_TYPE_UNKNOWN) {
40203e74:	e5d0300b 	ldrb	r3, [r0, #11]
/* ------------------------------------------------------------------------- */
/*
 * reports device info to the user
 */
void dev_print (block_dev_desc_t *dev_desc)
{
40203e78:	e1a04000 	mov	r4, r0
	uint64_t lba512; /* number of blocks if 512bytes block size */
#else
	lbaint_t lba512;
#endif

	if (dev_desc->type==DEV_TYPE_UNKNOWN) {
40203e7c:	e35300ff 	cmp	r3, #255	; 0xff
40203e80:	0a00004a 	beq	40203fb0 <dev_print+0x140>
		return;
	}
	if (dev_desc->if_type==IF_TYPE_SCSI)  {
40203e84:	e5903000 	ldr	r3, [r0]
40203e88:	e3530002 	cmp	r3, #2
40203e8c:	1a000003 	bne	40203ea0 <dev_print+0x30>
		printf ("(%d:%d) ", dev_desc->target,dev_desc->lun);
40203e90:	e59f0120 	ldr	r0, [pc, #288]	; 40203fb8 <dev_print+0x148>
40203e94:	e5d41009 	ldrb	r1, [r4, #9]
40203e98:	e5d4200a 	ldrb	r2, [r4, #10]
40203e9c:	ebfffbba 	bl	40202d8c <serial_printf>
	}
	if (dev_desc->if_type==IF_TYPE_IDE) {
40203ea0:	e1a01004 	mov	r1, r4
40203ea4:	e284c041 	add	ip, r4, #65	; 0x41
40203ea8:	e4913018 	ldr	r3, [r1], #24
40203eac:	e3530001 	cmp	r3, #1
40203eb0:	e2843056 	add	r3, r4, #86	; 0x56
		printf ("Model: %s Firm: %s Ser#: %s\n",
40203eb4:	059f0100 	ldreq	r0, [pc, #256]	; 40203fbc <dev_print+0x14c>
40203eb8:	01a02003 	moveq	r2, r3
			dev_desc->vendor,
			dev_desc->revision,
			dev_desc->product);
	} else {
		printf ("Vendor: %s Prod.: %s Rev: %s\n",
40203ebc:	159f00fc 	ldrne	r0, [pc, #252]	; 40203fc0 <dev_print+0x150>
	}
	if (dev_desc->if_type==IF_TYPE_SCSI)  {
		printf ("(%d:%d) ", dev_desc->target,dev_desc->lun);
	}
	if (dev_desc->if_type==IF_TYPE_IDE) {
		printf ("Model: %s Firm: %s Ser#: %s\n",
40203ec0:	01a0300c 	moveq	r3, ip
			dev_desc->vendor,
			dev_desc->revision,
			dev_desc->product);
	} else {
		printf ("Vendor: %s Prod.: %s Rev: %s\n",
40203ec4:	11a0200c 	movne	r2, ip
40203ec8:	ebfffbaf 	bl	40202d8c <serial_printf>
			dev_desc->vendor,
			dev_desc->product,
			dev_desc->revision);
	}
	printf ("            Type: ");
40203ecc:	e59f00f0 	ldr	r0, [pc, #240]	; 40203fc4 <dev_print+0x154>
40203ed0:	ebfffbad 	bl	40202d8c <serial_printf>
	switch (dev_desc->type & 0x1F) {
40203ed4:	e5d4100b 	ldrb	r1, [r4, #11]
40203ed8:	e201101f 	and	r1, r1, #31
40203edc:	e3510007 	cmp	r1, #7
40203ee0:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
40203ee4:	ea000010 	b	40203f2c <dev_print+0xbc>
40203ee8:	40203f08 	.word	0x40203f08
40203eec:	40203f24 	.word	0x40203f24
40203ef0:	40203f2c 	.word	0x40203f2c
40203ef4:	40203f2c 	.word	0x40203f2c
40203ef8:	40203f2c 	.word	0x40203f2c
40203efc:	40203f10 	.word	0x40203f10
40203f00:	40203f2c 	.word	0x40203f2c
40203f04:	40203f1c 	.word	0x40203f1c
		case DEV_TYPE_HARDDISK: printf ("Hard Disk");
40203f08:	e59f00b8 	ldr	r0, [pc, #184]	; 40203fc8 <dev_print+0x158>
40203f0c:	ea000000 	b	40203f14 <dev_print+0xa4>
					break;
		case DEV_TYPE_CDROM: 	printf ("CD ROM");
40203f10:	e59f00b4 	ldr	r0, [pc, #180]	; 40203fcc <dev_print+0x15c>
40203f14:	ebfffb9c 	bl	40202d8c <serial_printf>
					break;
40203f18:	ea000005 	b	40203f34 <dev_print+0xc4>
		case DEV_TYPE_OPDISK: 	printf ("Optical Device");
40203f1c:	e59f00ac 	ldr	r0, [pc, #172]	; 40203fd0 <dev_print+0x160>
40203f20:	eafffffb 	b	40203f14 <dev_print+0xa4>
					break;
		case DEV_TYPE_TAPE: 	printf ("Tape");
40203f24:	e59f00a8 	ldr	r0, [pc, #168]	; 40203fd4 <dev_print+0x164>
40203f28:	eafffff9 	b	40203f14 <dev_print+0xa4>
					break;
		default:		printf ("# %02X #", dev_desc->type & 0x1F);
40203f2c:	e59f00a4 	ldr	r0, [pc, #164]	; 40203fd8 <dev_print+0x168>
40203f30:	ebfffb95 	bl	40202d8c <serial_printf>
					break;
	}
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
40203f34:	e5946010 	ldr	r6, [r4, #16]
40203f38:	e5945014 	ldr	r5, [r4, #20]
40203f3c:	e0130596 	muls	r3, r6, r5
40203f40:	0a000016 	beq	40203fa0 <dev_print+0x130>
		lbaint_t lba;

		lba = dev_desc->lba;

		lba512 = (lba * (dev_desc->blksz/512));
		mb = (10 * lba512) / 2048;	/* 2048 = (1024 * 1024) / 512 MB */
40203f44:	e3a0400a 	mov	r4, #10
40203f48:	e1a0a4a5 	lsr	sl, r5, #9
40203f4c:	e0030694 	mul	r3, r4, r6
		/* round to 1 digit */
		mb_quot	= mb / 10;
40203f50:	e1a01004 	mov	r1, r4
		lbaint_t lba;

		lba = dev_desc->lba;

		lba512 = (lba * (dev_desc->blksz/512));
		mb = (10 * lba512) / 2048;	/* 2048 = (1024 * 1024) / 512 MB */
40203f54:	e00a039a 	mul	sl, sl, r3
40203f58:	e1a075aa 	lsr	r7, sl, #11
		/* round to 1 digit */
		mb_quot	= mb / 10;
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
40203f5c:	e1a0aaaa 	lsr	sl, sl, #21
		lba = dev_desc->lba;

		lba512 = (lba * (dev_desc->blksz/512));
		mb = (10 * lba512) / 2048;	/* 2048 = (1024 * 1024) / 512 MB */
		/* round to 1 digit */
		mb_quot	= mb / 10;
40203f60:	e1a00007 	mov	r0, r7
40203f64:	ebfffa73 	bl	40202938 <__udivsi3>
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
40203f68:	e1a01004 	mov	r1, r4
		lba = dev_desc->lba;

		lba512 = (lba * (dev_desc->blksz/512));
		mb = (10 * lba512) / 2048;	/* 2048 = (1024 * 1024) / 512 MB */
		/* round to 1 digit */
		mb_quot	= mb / 10;
40203f6c:	e1a09000 	mov	r9, r0
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
40203f70:	e1a0000a 	mov	r0, sl
40203f74:	ebfffa6f 	bl	40202938 <__udivsi3>
			mb_quot, mb_rem,
			gb_quot, gb_rem,
			lba,
			dev_desc->blksz);
#else
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
40203f78:	e1a01009 	mov	r1, r9
40203f7c:	e0627994 	mls	r2, r4, r9, r7
40203f80:	e58d6004 	str	r6, [sp, #4]
40203f84:	e58d5008 	str	r5, [sp, #8]
40203f88:	e06aa094 	mls	sl, r4, r0, sl
		/* round to 1 digit */
		mb_quot	= mb / 10;
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
40203f8c:	e1a03000 	mov	r3, r0
			mb_quot, mb_rem,
			gb_quot, gb_rem,
			lba,
			dev_desc->blksz);
#else
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
40203f90:	e59f0044 	ldr	r0, [pc, #68]	; 40203fdc <dev_print+0x16c>
40203f94:	e58da000 	str	sl, [sp]
40203f98:	ebfffb7b 	bl	40202d8c <serial_printf>
40203f9c:	ea000003 	b	40203fb0 <dev_print+0x140>
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		printf ("            Capacity: not available\n");
40203fa0:	e59f0038 	ldr	r0, [pc, #56]	; 40203fe0 <dev_print+0x170>
	}
}
40203fa4:	e28dd00c 	add	sp, sp, #12
40203fa8:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		printf ("            Capacity: not available\n");
40203fac:	eafffb76 	b	40202d8c <serial_printf>
	}
}
40203fb0:	e28dd00c 	add	sp, sp, #12
40203fb4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
40203fb8:	40204d91 	.word	0x40204d91
40203fbc:	40204d9a 	.word	0x40204d9a
40203fc0:	40204db7 	.word	0x40204db7
40203fc4:	40204dd5 	.word	0x40204dd5
40203fc8:	40204de8 	.word	0x40204de8
40203fcc:	40204df2 	.word	0x40204df2
40203fd0:	40204df9 	.word	0x40204df9
40203fd4:	40204e08 	.word	0x40204e08
40203fd8:	40204e0d 	.word	0x40204e0d
40203fdc:	40204e16 	.word	0x40204e16
40203fe0:	40204e51 	.word	0x40204e51

40203fe4 <serial_setbrg>:
serial_setbrg (void)
{
	int clock_divisor;

    clock_divisor = calc_divisor();
	NS16550_reinit(console, clock_divisor);
40203fe4:	e59f0004 	ldr	r0, [pc, #4]	; 40203ff0 <serial_setbrg+0xc>
40203fe8:	e3a0101a 	mov	r1, #26
40203fec:	ea000035 	b	402040c8 <NS16550_reinit>
40203ff0:	49020000 	.word	0x49020000

40203ff4 <serial_tstc>:
}

int
serial_tstc(void)
{
	return NS16550_tstc(console);
40203ff4:	e51f0000 	ldr	r0, [pc, #0]	; 40203ffc <serial_tstc+0x8>
40203ff8:	ea00004b 	b	4020412c <NS16550_tstc>
40203ffc:	49020000 	.word	0x49020000

40204000 <serial_getc>:
}


int
serial_getc(void)
{
40204000:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	return NS16550_getc(console);
40204004:	e59f0004 	ldr	r0, [pc, #4]	; 40204010 <serial_getc+0x10>
40204008:	eb000042 	bl	40204118 <NS16550_getc>
}
4020400c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
40204010:	49020000 	.word	0x49020000

40204014 <serial_putc>:
	return (0);
}

void
serial_putc(const char c)
{
40204014:	e92d4010 	push	{r4, lr}
40204018:	e6ef4070 	uxtb	r4, r0
	if (c == '\n')
4020401c:	e354000a 	cmp	r4, #10
40204020:	1a000002 	bne	40204030 <serial_putc+0x1c>
		NS16550_putc(console, '\r');
40204024:	e59f0014 	ldr	r0, [pc, #20]	; 40204040 <serial_putc+0x2c>
40204028:	e3a0100d 	mov	r1, #13
4020402c:	eb000033 	bl	40204100 <NS16550_putc>

	NS16550_putc(console, c);
40204030:	e59f0008 	ldr	r0, [pc, #8]	; 40204040 <serial_putc+0x2c>
40204034:	e1a01004 	mov	r1, r4
}
40204038:	e8bd4010 	pop	{r4, lr}
serial_putc(const char c)
{
	if (c == '\n')
		NS16550_putc(console, '\r');

	NS16550_putc(console, c);
4020403c:	ea00002f 	b	40204100 <NS16550_putc>
40204040:	49020000 	.word	0x49020000

40204044 <serial_puts>:
}

void
serial_puts (const char *s)
{
40204044:	e92d4030 	push	{r4, r5, lr}
40204048:	e1a05000 	mov	r5, r0
4020404c:	e3a04000 	mov	r4, #0
	while (*s) {
40204050:	ea000000 	b	40204058 <serial_puts+0x14>
		serial_putc (*s++);
40204054:	ebffffee 	bl	40204014 <serial_putc>
}

void
serial_puts (const char *s)
{
	while (*s) {
40204058:	e7d50004 	ldrb	r0, [r5, r4]
4020405c:	e2844001 	add	r4, r4, #1
40204060:	e3500000 	cmp	r0, #0
40204064:	1afffffa 	bne	40204054 <serial_puts+0x10>
		serial_putc (*s++);
	}
}
40204068:	e8bd8030 	pop	{r4, r5, pc}

4020406c <serial_init>:
#endif
	return (CFG_NS16550_CLK / 16 / CONFIG_BAUDRATE);
}

int serial_init (void)
{
4020406c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)

#ifdef CFG_NS87308
	initialise_ns87308();
#endif

	NS16550_init(console, clock_divisor);
40204070:	e59f000c 	ldr	r0, [pc, #12]	; 40204084 <serial_init+0x18>
40204074:	e3a0101a 	mov	r1, #26
40204078:	eb000002 	bl	40204088 <NS16550_init>

	return (0);
}
4020407c:	e3a00000 	mov	r0, #0
40204080:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
40204084:	49020000 	.word	0x49020000

40204088 <NS16550_init>:
#define MCRVAL (MCR_DTR | MCR_RTS)			/* RTS/DTR */
#define FCRVAL (FCR_FIFO_EN | FCR_RXSR | FCR_TXSR)	/* Clear & enable FIFOs */

void NS16550_init (NS16550_t com_port, int baud_divisor)
{
	com_port->ier = 0x00;
40204088:	e3a03000 	mov	r3, #0
#ifdef CONFIG_OMAP
	com_port->mdr1 = 0x7;   /* mode select reset TL16C750*/
4020408c:	e3a02007 	mov	r2, #7
#define MCRVAL (MCR_DTR | MCR_RTS)			/* RTS/DTR */
#define FCRVAL (FCR_FIFO_EN | FCR_RXSR | FCR_TXSR)	/* Clear & enable FIFOs */

void NS16550_init (NS16550_t com_port, int baud_divisor)
{
	com_port->ier = 0x00;
40204090:	e5c03004 	strb	r3, [r0, #4]
#ifdef CONFIG_OMAP
	com_port->mdr1 = 0x7;   /* mode select reset TL16C750*/
#endif
	com_port->lcr = LCR_BKSE | LCRVAL;
40204094:	e3e0c07c 	mvn	ip, #124	; 0x7c

void NS16550_init (NS16550_t com_port, int baud_divisor)
{
	com_port->ier = 0x00;
#ifdef CONFIG_OMAP
	com_port->mdr1 = 0x7;   /* mode select reset TL16C750*/
40204098:	e5c02020 	strb	r2, [r0, #32]
#endif
	com_port->lcr = LCR_BKSE | LCRVAL;
4020409c:	e5c0c00c 	strb	ip, [r0, #12]
	com_port->dll = baud_divisor & 0xff;
402040a0:	e6efc071 	uxtb	ip, r1
	com_port->dlm = (baud_divisor >> 8) & 0xff;
402040a4:	e7e71451 	ubfx	r1, r1, #8, #8
	com_port->ier = 0x00;
#ifdef CONFIG_OMAP
	com_port->mdr1 = 0x7;   /* mode select reset TL16C750*/
#endif
	com_port->lcr = LCR_BKSE | LCRVAL;
	com_port->dll = baud_divisor & 0xff;
402040a8:	e5c0c000 	strb	ip, [r0]
	com_port->dlm = (baud_divisor >> 8) & 0xff;
402040ac:	e5c01004 	strb	r1, [r0, #4]
	com_port->lcr = LCRVAL;
402040b0:	e3a01003 	mov	r1, #3
402040b4:	e5c0100c 	strb	r1, [r0, #12]
	com_port->mcr = MCRVAL;
402040b8:	e5c01010 	strb	r1, [r0, #16]
	com_port->fcr = FCRVAL;
402040bc:	e5c02008 	strb	r2, [r0, #8]
#if defined(CONFIG_OMAP)
	com_port->mdr1 = 0;	/* select uart mode */
402040c0:	e5c03020 	strb	r3, [r0, #32]
#endif
}
402040c4:	e12fff1e 	bx	lr

402040c8 <NS16550_reinit>:

void NS16550_reinit (NS16550_t com_port, int baud_divisor)
{
	com_port->ier = 0x00;
402040c8:	e3a03000 	mov	r3, #0
402040cc:	e5c03004 	strb	r3, [r0, #4]
	com_port->lcr = LCR_BKSE;
402040d0:	e3e0307f 	mvn	r3, #127	; 0x7f
402040d4:	e5c0300c 	strb	r3, [r0, #12]
	com_port->dll = baud_divisor & 0xff;
402040d8:	e6ef3071 	uxtb	r3, r1
	com_port->dlm = (baud_divisor >> 8) & 0xff;
402040dc:	e7e71451 	ubfx	r1, r1, #8, #8

void NS16550_reinit (NS16550_t com_port, int baud_divisor)
{
	com_port->ier = 0x00;
	com_port->lcr = LCR_BKSE;
	com_port->dll = baud_divisor & 0xff;
402040e0:	e5c03000 	strb	r3, [r0]
	com_port->dlm = (baud_divisor >> 8) & 0xff;
	com_port->lcr = LCRVAL;
402040e4:	e3a03003 	mov	r3, #3
void NS16550_reinit (NS16550_t com_port, int baud_divisor)
{
	com_port->ier = 0x00;
	com_port->lcr = LCR_BKSE;
	com_port->dll = baud_divisor & 0xff;
	com_port->dlm = (baud_divisor >> 8) & 0xff;
402040e8:	e5c01004 	strb	r1, [r0, #4]
	com_port->lcr = LCRVAL;
402040ec:	e5c0300c 	strb	r3, [r0, #12]
	com_port->mcr = MCRVAL;
402040f0:	e5c03010 	strb	r3, [r0, #16]
	com_port->fcr = FCRVAL;
402040f4:	e2833004 	add	r3, r3, #4
402040f8:	e5c03008 	strb	r3, [r0, #8]
}
402040fc:	e12fff1e 	bx	lr

40204100 <NS16550_putc>:

void NS16550_putc (NS16550_t com_port, char c)
{
40204100:	e6ef1071 	uxtb	r1, r1
	while ((com_port->lsr & LSR_THRE) == 0);
40204104:	e5d03014 	ldrb	r3, [r0, #20]
40204108:	e3130020 	tst	r3, #32
4020410c:	0afffffc 	beq	40204104 <NS16550_putc+0x4>
	com_port->thr = c;
40204110:	e5c01000 	strb	r1, [r0]
}
40204114:	e12fff1e 	bx	lr

40204118 <NS16550_getc>:

char NS16550_getc (NS16550_t com_port)
{
	while ((com_port->lsr & LSR_DR) == 0);
40204118:	e5d03014 	ldrb	r3, [r0, #20]
4020411c:	e3130001 	tst	r3, #1
40204120:	0afffffc 	beq	40204118 <NS16550_getc>
	return (com_port->rbr);
40204124:	e5d00000 	ldrb	r0, [r0]
}
40204128:	e12fff1e 	bx	lr

4020412c <NS16550_tstc>:

int NS16550_tstc (NS16550_t com_port)
{
	return ((com_port->lsr & LSR_DR) != 0);
4020412c:	e5d00014 	ldrb	r0, [r0, #20]
}
40204130:	e2000001 	and	r0, r0, #1
40204134:	e12fff1e 	bx	lr

40204138 <onenand_read_block>:
 * onenand_read_block - Read a block data to buf
 * @return 0 on sucess
 */ 

int onenand_read_block(unsigned char *buf, ulong block)
{
40204138:	e3a03000 	mov	r3, #0
4020413c:	e92d4010 	push	{r4, lr}
	unsigned long *p;
	unsigned int ctrl, ecc;
	unsigned short bbmarker;
#endif

	onenand_writew(onenand_block_address(block),
40204140:	e59fc0d4 	ldr	ip, [pc, #212]	; 4020421c <onenand_read_block+0xe4>
40204144:	e6ff2071 	uxth	r2, r1
		THIS_ONENAND(ONENAND_REG_START_ADDRESS1));

	onenand_writew(onenand_sector_address(page),
		THIS_ONENAND(ONENAND_REG_START_ADDRESS8));

	onenand_writew(onenand_buffer_address(),
40204148:	e3a04b02 	mov	r4, #2048	; 0x800
	unsigned long *p;
	unsigned int ctrl, ecc;
	unsigned short bbmarker;
#endif

	onenand_writew(onenand_block_address(block),
4020414c:	e1cc20b0 	strh	r2, [ip]
		THIS_ONENAND(ONENAND_REG_START_ADDRESS1));

	onenand_writew(onenand_sector_address(page),
40204150:	e1a02103 	lsl	r2, r3, #2
40204154:	e6ff2072 	uxth	r2, r2
40204158:	e1cc20be 	strh	r2, [ip, #14]
		THIS_ONENAND(ONENAND_REG_START_ADDRESS8));

	onenand_writew(onenand_buffer_address(),
4020415c:	e59f20bc 	ldr	r2, [pc, #188]	; 40204220 <onenand_read_block+0xe8>
40204160:	e1c240b0 	strh	r4, [r2]
		THIS_ONENAND(ONENAND_REG_START_BUFFER));

	onenand_writew(onenand_bufferram_address(block),
40204164:	e3a04000 	mov	r4, #0
40204168:	e1cc40b2 	strh	r4, [ip, #2]
		THIS_ONENAND(ONENAND_REG_START_ADDRESS2));

	onenand_writew(ONENAND_INT_CLEAR, THIS_ONENAND(ONENAND_REG_INTERRUPT));
4020416c:	e1c248b2 	strh	r4, [r2, #130]	; 0x82

	onenand_writew(ONENAND_CMD_READ, THIS_ONENAND(ONENAND_REG_COMMAND));
40204170:	e1c244b0 	strh	r4, [r2, #64]	; 0x40
#ifndef __HAVE_ARCH_MEMCPY32
 	p = (unsigned long *) buf;
#endif
	base = (unsigned long *) (ONENAND_ADDR + ONENAND_DATARAM);

	while (!(READ_INTERRUPT() & ONENAND_INT_MASTER))
40204174:	e59f20a4 	ldr	r2, [pc, #164]	; 40204220 <onenand_read_block+0xe8>
40204178:	e1d228b2 	ldrh	r2, [r2, #130]	; 0x82
4020417c:	e3120902 	tst	r2, #32768	; 0x8000
40204180:	0afffffb 	beq	40204174 <onenand_read_block+0x3c>
		continue;
	/* Check if the block is bad. Bad block markers    */
	/* are stored in spare area of 1st or 2nd page */
	if ((page == 0) || (page == 1))
40204184:	e3530001 	cmp	r3, #1
40204188:	8a000004 	bhi	402041a0 <onenand_read_block+0x68>
	{
	    unsigned long *spareArea = (unsigned long *) (ONENAND_ADDR + ONENAND_SPARERAM);
	    bbmarker = *spareArea;
            /* for bad block markers */
            if (bbmarker != 0xFFFF){
4020418c:	e59f2090 	ldr	r2, [pc, #144]	; 40204224 <onenand_read_block+0xec>
40204190:	e1d2c2b0 	ldrh	ip, [r2, #32]
40204194:	e2422212 	sub	r2, r2, #536870913	; 0x20000001
40204198:	e15c0002 	cmp	ip, r2
4020419c:	1a000016 	bne	402041fc <onenand_read_block+0xc4>
                return 1;
            }
	}

	ctrl = READ_CTRL_STATUS();
402041a0:	e59f2078 	ldr	r2, [pc, #120]	; 40204220 <onenand_read_block+0xe8>
402041a4:	e1d2c8b0 	ldrh	ip, [r2, #128]	; 0x80
	
	if (ctrl & ONENAND_CTRL_ERROR) {
402041a8:	e31c0b01 	tst	ip, #1024	; 0x400
402041ac:	1a000008 	bne	402041d4 <onenand_read_block+0x9c>
		hang();
	}
	
	if (READ_INTERRUPT() & ONENAND_INT_READ) {
402041b0:	e1d228b2 	ldrh	r2, [r2, #130]	; 0x82
402041b4:	e3120080 	tst	r2, #128	; 0x80
402041b8:	0a000006 	beq	402041d8 <onenand_read_block+0xa0>

		ecc = READ_ECC_STATUS();
402041bc:	e59f2064 	ldr	r2, [pc, #100]	; 40204228 <onenand_read_block+0xf0>
402041c0:	e1d2c0b0 	ldrh	ip, [r2]
		if (ecc & ONENAND_ECC_2BIT_ALL) {
402041c4:	e30a2aaa 	movw	r2, #43690	; 0xaaaa
402041c8:	e00c2002 	and	r2, ip, r2
402041cc:	e3520000 	cmp	r2, #0
402041d0:	0a000000 	beq	402041d8 <onenand_read_block+0xa0>
			hang();
402041d4:	ebfff9fd 	bl	402029d0 <hang>
402041d8:	e3a02000 	mov	r2, #0
	/* 32 bytes boundary memory copy */
	memcpy32(buf, base, ONENAND_PAGE_SIZE);
#else
	for (offset = 0; offset < (ONENAND_PAGE_SIZE >> 2); offset++) {
		value = *(base + offset);
		*p++ = value;
402041dc:	e282c202 	add	ip, r2, #536870912	; 0x20000000
402041e0:	e28ccb01 	add	ip, ip, #1024	; 0x400
402041e4:	e59cc000 	ldr	ip, [ip]
402041e8:	e780c002 	str	ip, [r0, r2]
402041ec:	e2822004 	add	r2, r2, #4
	
#ifdef __HAVE_ARCH_MEMCPY32
	/* 32 bytes boundary memory copy */
	memcpy32(buf, base, ONENAND_PAGE_SIZE);
#else
	for (offset = 0; offset < (ONENAND_PAGE_SIZE >> 2); offset++) {
402041f0:	e3520b02 	cmp	r2, #2048	; 0x800
402041f4:	1afffff8 	bne	402041dc <onenand_read_block+0xa4>
402041f8:	ea000001 	b	40204204 <onenand_read_block+0xcc>
402041fc:	e3a00001 	mov	r0, #1
	}

	set_async_read();

	return 0;
}
40204200:	e8bd8010 	pop	{r4, pc}
	set_sync_burst_read();

	/* NOTE: you must read page from page 1 of block 0 */
	/* read the block page by page*/
	for (page = ONENAND_START_PAGE;
	    page < ONENAND_PAGES_PER_BLOCK; page++) {
40204204:	e2833001 	add	r3, r3, #1
40204208:	e2800b02 	add	r0, r0, #2048	; 0x800

	set_sync_burst_read();

	/* NOTE: you must read page from page 1 of block 0 */
	/* read the block page by page*/
	for (page = ONENAND_START_PAGE;
4020420c:	e3530040 	cmp	r3, #64	; 0x40
40204210:	1affffca 	bne	40204140 <onenand_read_block+0x8>
40204214:	e3a00000 	mov	r0, #0
40204218:	e8bd8010 	pop	{r4, pc}
4020421c:	2001e200 	.word	0x2001e200
40204220:	2001e400 	.word	0x2001e400
40204224:	20010000 	.word	0x20010000
40204228:	2001fe00 	.word	0x2001fe00

4020422c <onenand_chip>:

int
onenand_chip()
{
	unsigned short mf_id, dev_id;
	mf_id = (*(volatile unsigned short *)(THIS_ONENAND(ONENAND_REG_MANUFACTURER_ID)));
4020422c:	e59f3054 	ldr	r3, [pc, #84]	; 40204288 <onenand_chip+0x5c>
#define set_async_read(...)		do { } while (0)
#endif

int
onenand_chip()
{
40204230:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	unsigned short mf_id, dev_id;
	mf_id = (*(volatile unsigned short *)(THIS_ONENAND(ONENAND_REG_MANUFACTURER_ID)));
40204234:	e1d320b0 	ldrh	r2, [r3]
	dev_id = (*(volatile unsigned short *)(THIS_ONENAND(ONENAND_REG_DEVICE_ID)));
40204238:	e1d330b2 	ldrh	r3, [r3, #2]

	if(mf_id == SAMSUNG_MFR_ID) {
4020423c:	e35200ec 	cmp	r2, #236	; 0xec
40204240:	1a00000c 	bne	40204278 <onenand_chip+0x4c>
		if (dev_id == KFM1G16Q2A_DEV_ID) {
40204244:	e3530030 	cmp	r3, #48	; 0x30
		printf("Detected Samsung MuxOneNAND1G Flash \r\n");
40204248:	059f003c 	ldreq	r0, [pc, #60]	; 4020428c <onenand_chip+0x60>
	unsigned short mf_id, dev_id;
	mf_id = (*(volatile unsigned short *)(THIS_ONENAND(ONENAND_REG_MANUFACTURER_ID)));
	dev_id = (*(volatile unsigned short *)(THIS_ONENAND(ONENAND_REG_DEVICE_ID)));

	if(mf_id == SAMSUNG_MFR_ID) {
		if (dev_id == KFM1G16Q2A_DEV_ID) {
4020424c:	0a000002 	beq	4020425c <onenand_chip+0x30>
		printf("Detected Samsung MuxOneNAND1G Flash \r\n");
		return 0;
		} else if (dev_id == KFN2G16Q2A_DEV_ID) {
40204250:	e3530040 	cmp	r3, #64	; 0x40
40204254:	1a000003 	bne	40204268 <onenand_chip+0x3c>
			printf("Detected Samsung MuxOneNAND2G Flash \r\n");
40204258:	e59f0030 	ldr	r0, [pc, #48]	; 40204290 <onenand_chip+0x64>
4020425c:	ebfffaca 	bl	40202d8c <serial_printf>
40204260:	e3a00000 	mov	r0, #0
                        return 0;
40204264:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
		} else {
			printf(" ONENAND Flash unsupported\r\n");
40204268:	e59f0024 	ldr	r0, [pc, #36]	; 40204294 <onenand_chip+0x68>
4020426c:	ebfffac6 	bl	40202d8c <serial_printf>
40204270:	e3a00001 	mov	r0, #1
                        return 1;
40204274:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
		}
	} else {
		printf("ONENAND Flash Unsupported\r\n");
40204278:	e59f0018 	ldr	r0, [pc, #24]	; 40204298 <onenand_chip+0x6c>
4020427c:	ebfffac2 	bl	40202d8c <serial_printf>
40204280:	e3a00001 	mov	r0, #1
		return 1;
	}
}
40204284:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
40204288:	2001e000 	.word	0x2001e000
4020428c:	40204e76 	.word	0x40204e76
40204290:	40204e9d 	.word	0x40204e9d
40204294:	40204ec4 	.word	0x40204ec4
40204298:	40204ee1 	.word	0x40204ee1

4020429c <delay>:
 * Routine: delay
 * Description: spinning delay to use before udelay works
 ******************************************************/
static inline void delay (unsigned long loops)
{
	__asm__ volatile ("1:\n"
4020429c:	e2500001 	subs	r0, r0, #1
402042a0:	1afffffd 	bne	4020429c <delay>
					  "subs %0, %0, #1\n"
					  "bne 1b":"=r" (loops):"0" (loops));
}
402042a4:	e12fff1e 	bx	lr

402042a8 <NanD_Command>:
static int bus_width = 8;
#endif

/* NanD_Command: Send a flash command to the flash chip */
static int NanD_Command(unsigned char command)
{
402042a8:	e6ef0070 	uxtb	r0, r0
 	NAND_CTL_SETCLE(NAND_ADDR);

 	WRITE_NAND_COMMAND(command, NAND_ADDR);
402042ac:	e3a0346e 	mov	r3, #1845493760	; 0x6e000000
 	NAND_CTL_CLRCLE(NAND_ADDR);

  	if(command == NAND_CMD_RESET){
402042b0:	e35000ff 	cmp	r0, #255	; 0xff
static int bus_width = 8;
#endif

/* NanD_Command: Send a flash command to the flash chip */
static int NanD_Command(unsigned char command)
{
402042b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
 	NAND_CTL_SETCLE(NAND_ADDR);

 	WRITE_NAND_COMMAND(command, NAND_ADDR);
402042b8:	e1c307bc 	strh	r0, [r3, #124]	; 0x7c
 	NAND_CTL_CLRCLE(NAND_ADDR);

  	if(command == NAND_CMD_RESET){
402042bc:	1a000005 	bne	402042d8 <NanD_Command+0x30>
		unsigned char ret_val;
		NanD_Command(NAND_CMD_STATUS);
402042c0:	e3a00070 	mov	r0, #112	; 0x70
402042c4:	ebfffff7 	bl	402042a8 <NanD_Command>
		do{
			ret_val = READ_NAND(NAND_ADDR);/* wait till ready */
402042c8:	e3a0346e 	mov	r3, #1845493760	; 0x6e000000
402042cc:	e1d338b4 	ldrh	r3, [r3, #132]	; 0x84
  		} while((ret_val & 0x40) != 0x40);
402042d0:	e3130040 	tst	r3, #64	; 0x40
402042d4:	0afffffb 	beq	402042c8 <NanD_Command+0x20>
 	}

	NAND_WAIT_READY();
	return 0;
}
402042d8:	e3a00000 	mov	r0, #0
402042dc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

402042e0 <NanD_Address>:
{
	uchar u;

 	NAND_CTL_SETALE(NAND_ADDR);

	if (numbytes == ADDR_COLUMN || numbytes == ADDR_COLUMN_PAGE
402042e0:	e3500001 	cmp	r0, #1
402042e4:	13500003 	cmpne	r0, #3
402042e8:	0a000001 	beq	402042f4 <NanD_Address+0x14>
402042ec:	e3500007 	cmp	r0, #7
402042f0:	1a000008 	bne	40204318 <NanD_Address+0x38>
				|| numbytes == ADDR_OOB)
	{
		ushort col = ofs;
402042f4:	e6ff3071 	uxth	r3, r1

		u = col  & 0xff;
		WRITE_NAND_ADDRESS(u, NAND_ADDR);
402042f8:	e3a0246e 	mov	r2, #1845493760	; 0x6e000000

		u = (col >> 8) & 0x07;
		if (numbytes == ADDR_OOB)
402042fc:	e3500007 	cmp	r0, #7
				|| numbytes == ADDR_OOB)
	{
		ushort col = ofs;

		u = col  & 0xff;
		WRITE_NAND_ADDRESS(u, NAND_ADDR);
40204300:	e6efc073 	uxtb	ip, r3

		u = (col >> 8) & 0x07;
40204304:	e7e23453 	ubfx	r3, r3, #8, #3
				|| numbytes == ADDR_OOB)
	{
		ushort col = ofs;

		u = col  & 0xff;
		WRITE_NAND_ADDRESS(u, NAND_ADDR);
40204308:	e1c2c8b0 	strh	ip, [r2, #128]	; 0x80

		u = (col >> 8) & 0x07;
		if (numbytes == ADDR_OOB)
			u = u | ((bus_width == 16) ? (1 << 2) : (1 << 3));
		WRITE_NAND_ADDRESS(u, NAND_ADDR);
4020430c:	e3a0246e 	mov	r2, #1845493760	; 0x6e000000
		u = col  & 0xff;
		WRITE_NAND_ADDRESS(u, NAND_ADDR);

		u = (col >> 8) & 0x07;
		if (numbytes == ADDR_OOB)
			u = u | ((bus_width == 16) ? (1 << 2) : (1 << 3));
40204310:	03833004 	orreq	r3, r3, #4
		WRITE_NAND_ADDRESS(u, NAND_ADDR);
40204314:	e1c238b0 	strh	r3, [r2, #128]	; 0x80
	}

	if (numbytes == ADDR_PAGE || numbytes == ADDR_COLUMN_PAGE
40204318:	e2403002 	sub	r3, r0, #2
4020431c:	e3500007 	cmp	r0, #7
40204320:	13530001 	cmpne	r3, #1
40204324:	8a000006 	bhi	40204344 <NanD_Address+0x64>
				|| numbytes == ADDR_OOB)
	{
		u = (ofs >> 11) & 0xff;
		WRITE_NAND_ADDRESS(u, NAND_ADDR);
40204328:	e3a0346e 	mov	r3, #1845493760	; 0x6e000000
4020432c:	e7e725d1 	ubfx	r2, r1, #11, #8
40204330:	e1c328b0 	strh	r2, [r3, #128]	; 0x80
		u = (ofs >> 19) & 0xff;
		WRITE_NAND_ADDRESS(u, NAND_ADDR);
40204334:	e7e729d1 	ubfx	r2, r1, #19, #8

		/* One more address cycle for devices > 128MiB */
		if (chipsize > (128 << 20)) {
			u = (ofs >> 27) & 0xff;
			WRITE_NAND_ADDRESS(u, NAND_ADDR);
40204338:	e1a01da1 	lsr	r1, r1, #27
				|| numbytes == ADDR_OOB)
	{
		u = (ofs >> 11) & 0xff;
		WRITE_NAND_ADDRESS(u, NAND_ADDR);
		u = (ofs >> 19) & 0xff;
		WRITE_NAND_ADDRESS(u, NAND_ADDR);
4020433c:	e1c328b0 	strh	r2, [r3, #128]	; 0x80

		/* One more address cycle for devices > 128MiB */
		if (chipsize > (128 << 20)) {
			u = (ofs >> 27) & 0xff;
			WRITE_NAND_ADDRESS(u, NAND_ADDR);
40204340:	e1c318b0 	strh	r1, [r3, #128]	; 0x80

 	NAND_CTL_CLRALE(NAND_ADDR);

 	NAND_WAIT_READY();
	return 0;
}
40204344:	e3a00000 	mov	r0, #0
40204348:	e12fff1e 	bx	lr

4020434c <nand_read_block>:
/* read a block data to buf
 * return 1 if the block is bad or ECC error can't be corrected for any page
 * return 0 on sucess
 */
int nand_read_block(unsigned char *buf, ulong block_addr)
{
4020434c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
40204350:	e1a0a001 	mov	sl, r1
40204354:	e24dd0a4 	sub	sp, sp, #164	; 0xa4
40204358:	e1a05000 	mov	r5, r0
#endif
	p = (u16 *)buf;
        len = (bus_width == 16) ? OOB_SIZE >> 1 : OOB_SIZE;

  	NAND_ENABLE_CE();  /* set pin low */
	NanD_Command(NAND_CMD_READ0);
4020435c:	e3a00000 	mov	r0, #0
40204360:	ebffffd0 	bl	402042a8 <NanD_Command>
 	NanD_Address(ADDR_OOB, page_addr);
40204364:	e1a0100a 	mov	r1, sl
40204368:	e3a00007 	mov	r0, #7
4020436c:	ebffffdb 	bl	402042e0 <NanD_Address>
	NanD_Command(NAND_CMD_READSTART);
40204370:	e3a00030 	mov	r0, #48	; 0x30
40204374:	ebffffcb 	bl	402042a8 <NanD_Command>
	NAND_WAIT_READY();

	/* A delay seems to be helping here. needs more investigation */
	delay(10000);
40204378:	e3020710 	movw	r0, #10000	; 0x2710
4020437c:	ebffffc6 	bl	4020429c <delay>
40204380:	e3a03000 	mov	r3, #0
	for (cntr = 0; cntr < len; cntr++)
		*p++ = READ_NAND(NAND_ADDR);
40204384:	e3a0246e 	mov	r2, #1845493760	; 0x6e000000
40204388:	e1d218b4 	ldrh	r1, [r2, #132]	; 0x84
4020438c:	e28d2048 	add	r2, sp, #72	; 0x48
40204390:	e18210b3 	strh	r1, [r2, r3]
40204394:	e2833002 	add	r3, r3, #2
	NanD_Command(NAND_CMD_READSTART);
	NAND_WAIT_READY();

	/* A delay seems to be helping here. needs more investigation */
	delay(10000);
	for (cntr = 0; cntr < len; cntr++)
40204398:	e3530040 	cmp	r3, #64	; 0x40
4020439c:	1afffff8 	bne	40204384 <nand_read_block+0x38>
	u16 oob_buf[OOB_SIZE >> 1];

	/* check bad block */
	/* 0th word in spare area needs be 0xff */
	if (nand_read_oob((unsigned char *)oob_buf, block_addr)
		|| (oob_buf[0] & 0xff) != 0xff) {
402043a0:	e5dd3048 	ldrb	r3, [sp, #72]	; 0x48
402043a4:	e35300ff 	cmp	r3, #255	; 0xff
402043a8:	0a000004 	beq	402043c0 <nand_read_block+0x74>
		printf("Skipped bad block at 0x%x\n", block_addr);
402043ac:	e59f0178 	ldr	r0, [pc, #376]	; 4020452c <nand_read_block+0x1e0>
402043b0:	e1a0100a 	mov	r1, sl
402043b4:	ebfffa74 	bl	40202d8c <serial_printf>
402043b8:	e3a00001 	mov	r0, #1
		return 1;    /* skip bad block */
402043bc:	ea000058 	b	40204524 <nand_read_block+0x1d8>
402043c0:	e3a04000 	mov	r4, #0
#else
	u_char *p;
#endif

	NAND_ENABLE_CE();
	NanD_Command(NAND_CMD_READ0);
402043c4:	e3a00000 	mov	r0, #0
	/* check bad block */
	/* 0th word in spare area needs be 0xff */
	if (nand_read_oob((unsigned char *)oob_buf, block_addr)
		|| (oob_buf[0] & 0xff) != 0xff) {
		printf("Skipped bad block at 0x%x\n", block_addr);
		return 1;    /* skip bad block */
402043c8:	e084100a 	add	r1, r4, sl
402043cc:	e58d1004 	str	r1, [sp, #4]
#else
	u_char *p;
#endif

	NAND_ENABLE_CE();
	NanD_Command(NAND_CMD_READ0);
402043d0:	ebffffb4 	bl	402042a8 <NanD_Command>
	NanD_Address(ADDR_COLUMN_PAGE, page_addr);
402043d4:	e59d1004 	ldr	r1, [sp, #4]
402043d8:	e3a00003 	mov	r0, #3
402043dc:	ebffffbf 	bl	402042e0 <NanD_Address>
	NanD_Command(NAND_CMD_READSTART);
402043e0:	e3a00030 	mov	r0, #48	; 0x30
402043e4:	ebffffaf 	bl	402042a8 <NanD_Command>
	NAND_WAIT_READY();

	/* A delay seems to be helping here. needs more investigation */
	delay(10000);
402043e8:	e3020710 	movw	r0, #10000	; 0x2710
402043ec:	ebffffaa 	bl	4020429c <delay>
402043f0:	e3a06000 	mov	r6, #0
	len = (bus_width == 16) ? PAGE_SIZE >> 1 : PAGE_SIZE;
	p = (u16 *)buf;
	for (cntr = 0; cntr < len; cntr++){
		*p++ = READ_NAND(NAND_ADDR);
402043f4:	e3a0346e 	mov	r3, #1845493760	; 0x6e000000
		delay(10);
402043f8:	e3a0000a 	mov	r0, #10
	/* A delay seems to be helping here. needs more investigation */
	delay(10000);
	len = (bus_width == 16) ? PAGE_SIZE >> 1 : PAGE_SIZE;
	p = (u16 *)buf;
	for (cntr = 0; cntr < len; cntr++){
		*p++ = READ_NAND(NAND_ADDR);
402043fc:	e1d338b4 	ldrh	r3, [r3, #132]	; 0x84
40204400:	e18530b6 	strh	r3, [r5, r6]
		delay(10);
40204404:	e2866002 	add	r6, r6, #2
40204408:	ebffffa3 	bl	4020429c <delay>

	/* A delay seems to be helping here. needs more investigation */
	delay(10000);
	len = (bus_width == 16) ? PAGE_SIZE >> 1 : PAGE_SIZE;
	p = (u16 *)buf;
	for (cntr = 0; cntr < len; cntr++){
4020440c:	e3560b02 	cmp	r6, #2048	; 0x800
40204410:	1afffff7 	bne	402043f4 <nand_read_block+0xa8>
40204414:	e2466b02 	sub	r6, r6, #2048	; 0x800

#ifdef ECC_CHECK_ENABLE
	p = (u16 *)oob_buf;
        len = (bus_width == 16) ? OOB_SIZE >> 1 : OOB_SIZE;
	for (cntr = 0; cntr < len; cntr++){
		*p++ = READ_NAND(NAND_ADDR);
40204418:	e3a0346e 	mov	r3, #1845493760	; 0x6e000000
		delay(10);
4020441c:	e3a0000a 	mov	r0, #10

#ifdef ECC_CHECK_ENABLE
	p = (u16 *)oob_buf;
        len = (bus_width == 16) ? OOB_SIZE >> 1 : OOB_SIZE;
	for (cntr = 0; cntr < len; cntr++){
		*p++ = READ_NAND(NAND_ADDR);
40204420:	e1d328b4 	ldrh	r2, [r3, #132]	; 0x84
40204424:	e28d3008 	add	r3, sp, #8
40204428:	e18320b6 	strh	r2, [r3, r6]
		delay(10);
4020442c:	e2866002 	add	r6, r6, #2
40204430:	ebffff99 	bl	4020429c <delay>
   	}

#ifdef ECC_CHECK_ENABLE
	p = (u16 *)oob_buf;
        len = (bus_width == 16) ? OOB_SIZE >> 1 : OOB_SIZE;
	for (cntr = 0; cntr < len; cntr++){
40204434:	e3560040 	cmp	r6, #64	; 0x40
40204438:	1afffff6 	bne	40204418 <nand_read_block+0xcc>
4020443c:	e3a03000 	mov	r3, #0
	count = 0;
 	NAND_DISABLE_CE();  /* set pin high */

 	/* Pick the ECC bytes out of the oob data */
	for (cntr = 0; cntr < ECC_SIZE; cntr++)
		ecc_code[cntr] =  oob_buf[ecc_pos[cntr]];
40204440:	e59f20e8 	ldr	r2, [pc, #232]	; 40204530 <nand_read_block+0x1e4>
40204444:	e28d10a4 	add	r1, sp, #164	; 0xa4
40204448:	e7d22003 	ldrb	r2, [r2, r3]
4020444c:	e0812002 	add	r2, r1, r2
40204450:	e552109c 	ldrb	r1, [r2, #-156]	; 0x9c
40204454:	e28d2088 	add	r2, sp, #136	; 0x88
40204458:	e7c21003 	strb	r1, [r2, r3]
 	}
	count = 0;
 	NAND_DISABLE_CE();  /* set pin high */

 	/* Pick the ECC bytes out of the oob data */
	for (cntr = 0; cntr < ECC_SIZE; cntr++)
4020445c:	e2833001 	add	r3, r3, #1
40204460:	e3530018 	cmp	r3, #24
40204464:	1afffff5 	bne	40204440 <nand_read_block+0xf4>
		ecc_code[cntr] =  oob_buf[ecc_pos[cntr]];

	for(count = 0; count < ECC_SIZE; count += ECC_STEPS) {
40204468:	e59f30c4 	ldr	r3, [pc, #196]	; 40204534 <nand_read_block+0x1e8>
4020446c:	e3a06000 	mov	r6, #0
40204470:	e5836000 	str	r6, [r3]
40204474:	ea00001e 	b	402044f4 <nand_read_block+0x1a8>
 		nand_calculate_ecc (buf, &ecc_calc[0]);
40204478:	e28db0a0 	add	fp, sp, #160	; 0xa0
4020447c:	e1a00009 	mov	r0, r9
40204480:	e58d3000 	str	r3, [sp]
		if (nand_correct_data (buf, &ecc_code[count], &ecc_calc[0]) == -1) {
40204484:	e2866c01 	add	r6, r6, #256	; 0x100
 	/* Pick the ECC bytes out of the oob data */
	for (cntr = 0; cntr < ECC_SIZE; cntr++)
		ecc_code[cntr] =  oob_buf[ecc_pos[cntr]];

	for(count = 0; count < ECC_SIZE; count += ECC_STEPS) {
 		nand_calculate_ecc (buf, &ecc_calc[0]);
40204488:	e1a0100b 	mov	r1, fp
4020448c:	eb000059 	bl	402045f8 <nand_calculate_ecc>
		if (nand_correct_data (buf, &ecc_code[count], &ecc_calc[0]) == -1) {
40204490:	e5972000 	ldr	r2, [r7]
40204494:	e28d1088 	add	r1, sp, #136	; 0x88
40204498:	e1a00009 	mov	r0, r9
4020449c:	e0811002 	add	r1, r1, r2
402044a0:	e1a0200b 	mov	r2, fp
402044a4:	eb000091 	bl	402046f0 <nand_correct_data>
402044a8:	e59d3000 	ldr	r3, [sp]
402044ac:	e3700001 	cmn	r0, #1
402044b0:	1a00000c 	bne	402044e8 <nand_read_block+0x19c>
 			printf ("ECC Failed, page 0x%08x\n", page_addr);
402044b4:	e59f007c 	ldr	r0, [pc, #124]	; 40204538 <nand_read_block+0x1ec>
402044b8:	e1a01003 	mov	r1, r3
402044bc:	ebfffa32 	bl	40202d8c <serial_printf>
402044c0:	e3a04000 	mov	r4, #0
			for (val=0; val <256; val++)
				printf("%x ", buf[val]);
402044c4:	e7d91004 	ldrb	r1, [r9, r4]
402044c8:	e2844001 	add	r4, r4, #1
402044cc:	e59f0068 	ldr	r0, [pc, #104]	; 4020453c <nand_read_block+0x1f0>
402044d0:	ebfffa2d 	bl	40202d8c <serial_printf>

	for(count = 0; count < ECC_SIZE; count += ECC_STEPS) {
 		nand_calculate_ecc (buf, &ecc_calc[0]);
		if (nand_correct_data (buf, &ecc_code[count], &ecc_calc[0]) == -1) {
 			printf ("ECC Failed, page 0x%08x\n", page_addr);
			for (val=0; val <256; val++)
402044d4:	e3540c01 	cmp	r4, #256	; 0x100
402044d8:	1afffff9 	bne	402044c4 <nand_read_block+0x178>
				printf("%x ", buf[val]);
			printf("\n");
402044dc:	e59f005c 	ldr	r0, [pc, #92]	; 40204540 <nand_read_block+0x1f4>
402044e0:	ebfffa29 	bl	40202d8c <serial_printf>
402044e4:	eafffffe 	b	402044e4 <nand_read_block+0x198>

 	/* Pick the ECC bytes out of the oob data */
	for (cntr = 0; cntr < ECC_SIZE; cntr++)
		ecc_code[cntr] =  oob_buf[ecc_pos[cntr]];

	for(count = 0; count < ECC_SIZE; count += ECC_STEPS) {
402044e8:	e5973000 	ldr	r3, [r7]
402044ec:	e2833003 	add	r3, r3, #3
402044f0:	e5873000 	str	r3, [r7]
402044f4:	e59f7038 	ldr	r7, [pc, #56]	; 40204534 <nand_read_block+0x1e8>
402044f8:	e0869005 	add	r9, r6, r5
402044fc:	e59d2004 	ldr	r2, [sp, #4]
40204500:	e0863002 	add	r3, r6, r2
40204504:	e5972000 	ldr	r2, [r7]
40204508:	e3520017 	cmp	r2, #23
4020450c:	daffffd9 	ble	40204478 <nand_read_block+0x12c>
		printf("Skipped bad block at 0x%x\n", block_addr);
		return 1;    /* skip bad block */
	}
#endif
	/* read the block page by page*/
	for (i=0; i<MAX_NUM_PAGES; i++){
40204510:	e3540b7e 	cmp	r4, #129024	; 0x1f800

 	/* Pick the ECC bytes out of the oob data */
	for (cntr = 0; cntr < ECC_SIZE; cntr++)
		ecc_code[cntr] =  oob_buf[ecc_pos[cntr]];

	for(count = 0; count < ECC_SIZE; count += ECC_STEPS) {
40204514:	e2855b02 	add	r5, r5, #2048	; 0x800
#endif
	/* read the block page by page*/
	for (i=0; i<MAX_NUM_PAGES; i++){
		if (nand_read_page(buf+offset, block_addr + offset))
			return 1;
		offset += PAGE_SIZE;
40204518:	12844b02 	addne	r4, r4, #2048	; 0x800
4020451c:	1affffa8 	bne	402043c4 <nand_read_block+0x78>
40204520:	e3a00000 	mov	r0, #0
	}

	return 0;
}
40204524:	e28dd0a4 	add	sp, sp, #164	; 0xa4
40204528:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
4020452c:	40204efd 	.word	0x40204efd
40204530:	40204960 	.word	0x40204960
40204534:	40208060 	.word	0x40208060
40204538:	40204f18 	.word	0x40204f18
4020453c:	40204f31 	.word	0x40204f31
40204540:	40204d45 	.word	0x40204d45

40204544 <nand_chip>:
/* read chip mfr and id
 * return 0 if they match board config
 * return 1 if not
 */
int nand_chip()
{
40204544:	e92d4030 	push	{r4, r5, lr}
	int mfr, id;

 	NAND_ENABLE_CE();

 	if (NanD_Command(NAND_CMD_RESET)) {
40204548:	e3a000ff 	mov	r0, #255	; 0xff
4020454c:	ebffff55 	bl	402042a8 <NanD_Command>
40204550:	e3500000 	cmp	r0, #0
 		printf("Err: RESET\n");
40204554:	159f008c 	ldrne	r0, [pc, #140]	; 402045e8 <nand_chip+0xa4>
{
	int mfr, id;

 	NAND_ENABLE_CE();

 	if (NanD_Command(NAND_CMD_RESET)) {
40204558:	1a000004 	bne	40204570 <nand_chip+0x2c>
 		printf("Err: RESET\n");
 		NAND_DISABLE_CE();
		return 1;
	}

 	if (NanD_Command(NAND_CMD_READID)) {
4020455c:	e3a00090 	mov	r0, #144	; 0x90
40204560:	ebffff50 	bl	402042a8 <NanD_Command>
40204564:	e2501000 	subs	r1, r0, #0
40204568:	0a000002 	beq	40204578 <nand_chip+0x34>
 		printf("Err: READID\n");
4020456c:	e59f0078 	ldr	r0, [pc, #120]	; 402045ec <nand_chip+0xa8>
40204570:	ebfffa05 	bl	40202d8c <serial_printf>
40204574:	ea00000f 	b	402045b8 <nand_chip+0x74>
 		NAND_DISABLE_CE();
		return 1;
 	}

 	NanD_Address(ADDR_COLUMN, 0);
40204578:	e3a00001 	mov	r0, #1
4020457c:	ebffff57 	bl	402042e0 <NanD_Address>

 	mfr = READ_NAND(NAND_ADDR);
40204580:	e3a0346e 	mov	r3, #1845493760	; 0x6e000000
40204584:	e1d358b4 	ldrh	r5, [r3, #132]	; 0x84
	id = READ_NAND(NAND_ADDR);
40204588:	e1d348b4 	ldrh	r4, [r3, #132]	; 0x84

	NAND_DISABLE_CE();

	if (is_cpu_family() == CPU_OMAP36XX) {
4020458c:	ebfff25d 	bl	40200f08 <is_cpu_family>
40204590:	e3500c36 	cmp	r0, #13824	; 0x3600
40204594:	1a000002 	bne	402045a4 <nand_chip+0x60>
		return (mfr != HYNIX4GiB_MFR || id != HYNIX4GiB_ID);
40204598:	e35500ad 	cmp	r5, #173	; 0xad
4020459c:	035400bc 	cmpeq	r4, #188	; 0xbc
402045a0:	ea000008 	b	402045c8 <nand_chip+0x84>
	} else {
		if (get_cpu_rev() == CPU_3430_ES2)
402045a4:	ebfff252 	bl	40200ef4 <get_cpu_rev>
402045a8:	e3500002 	cmp	r0, #2
402045ac:	1a000008 	bne	402045d4 <nand_chip+0x90>
#if defined (CONFIG_OMAP34XX) || defined (CONFIG_OMAP3EVM)
			return (mfr != MT29F1G_MFR || !(id == MT29F1G_ID || id == MT29F2G_ID));
402045b0:	e355002c 	cmp	r5, #44	; 0x2c
402045b4:	0a000001 	beq	402045c0 <nand_chip+0x7c>
402045b8:	e3a00001 	mov	r0, #1
402045bc:	e8bd8030 	pop	{r4, r5, pc}
402045c0:	e35400ba 	cmp	r4, #186	; 0xba
402045c4:	135400a1 	cmpne	r4, #161	; 0xa1
402045c8:	03a00000 	moveq	r0, #0
402045cc:	13a00001 	movne	r0, #1
402045d0:	e8bd8030 	pop	{r4, r5, pc}
#elif defined (CONFIG_AM3517EVM) || defined (CONFIG_AM3517TEB)
		return (mfr != MT29F1G_MFR && !(id == MT29F1G_ID || id == MT29F2G_ID));
#endif
		else
			return (mfr != K9F1G08R0A_MFR || id != K9F1G08R0A_ID);
402045d4:	e35500ec 	cmp	r5, #236	; 0xec
402045d8:	035400a1 	cmpeq	r4, #161	; 0xa1
402045dc:	03a00000 	moveq	r0, #0
402045e0:	13a00001 	movne	r0, #1
	}
}
402045e4:	e8bd8030 	pop	{r4, r5, pc}
402045e8:	40204f35 	.word	0x40204f35
402045ec:	40204f41 	.word	0x40204f41

402045f0 <cpu_init>:
#define RESERVED_1	(0xf << 3)	/* must be 111b for R/W */

int cpu_init (void)
{
	return 0;
}
402045f0:	e3a00000 	mov	r0, #0
402045f4:	e12fff1e 	bx	lr

402045f8 <nand_calculate_ecc>:
	u_char idx, reg1, reg2, reg3;
	int j;

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;
	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;
402045f8:	e3a03000 	mov	r3, #0
402045fc:	e3a020ff 	mov	r2, #255	; 0xff
	ecc_code[1] = ~ecc_code[1];
	ecc_code[2] = ((~reg1) << 2) | 0x03;
}
#else
void nand_calculate_ecc (const u_char *dat, u_char *ecc_code)
{
40204600:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	u_char idx, reg1, reg2, reg3;
	int j;

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;
	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;
40204604:	e1a04003 	mov	r4, r3
40204608:	e1a05003 	mov	r5, r3
4020460c:	e1a06003 	mov	r6, r3
40204610:	e5c13002 	strb	r3, [r1, #2]
40204614:	e5c13001 	strb	r3, [r1, #1]
40204618:	e5c13000 	strb	r3, [r1]

	/* Build up column parity */
	for(j = 0; j < 256; j++) {

		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[dat[j]];
4020461c:	e7d0c003 	ldrb	ip, [r0, r3]
40204620:	e59f70c4 	ldr	r7, [pc, #196]	; 402046ec <nand_calculate_ecc+0xf4>
40204624:	e7d7c00c 	ldrb	ip, [r7, ip]
		reg1 ^= (idx & 0x3f);

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
40204628:	e31c0040 	tst	ip, #64	; 0x40
	/* Build up column parity */
	for(j = 0; j < 256; j++) {

		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[dat[j]];
		reg1 ^= (idx & 0x3f);
4020462c:	e20c703f 	and	r7, ip, #63	; 0x3f

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
			reg3 ^= (u_char) j;
40204630:	10244003 	eorne	r4, r4, r3
			reg2 ^= ~((u_char) j);
40204634:	10225005 	eorne	r5, r2, r5
	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;
	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;

	/* Build up column parity */
	for(j = 0; j < 256; j++) {
40204638:	e2833001 	add	r3, r3, #1

		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[dat[j]];
		reg1 ^= (idx & 0x3f);
4020463c:	e0266007 	eor	r6, r6, r7

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
			reg3 ^= (u_char) j;
40204640:	16ef4074 	uxtbne	r4, r4
			reg2 ^= ~((u_char) j);
40204644:	16ef5075 	uxtbne	r5, r5
	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;
	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;

	/* Build up column parity */
	for(j = 0; j < 256; j++) {
40204648:	e3530c01 	cmp	r3, #256	; 0x100
4020464c:	e2422001 	sub	r2, r2, #1
40204650:	1afffff1 	bne	4020461c <nand_calculate_ecc+0x24>
40204654:	e3a0c000 	mov	ip, #0
40204658:	e3a02080 	mov	r2, #128	; 0x80
4020465c:	e1a0000c 	mov	r0, ip
40204660:	e1a03002 	mov	r3, r2
	/* Initialize variables */
	a = b = 0x80;
	tmp1 = tmp2 = 0;

	/* Calculate first ECC byte */
	for (i = 0; i < 4; i++) {
40204664:	e28cc001 	add	ip, ip, #1
		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
40204668:	e1130004 	tst	r3, r4
			tmp1 |= b;
4020466c:	11820000 	orrne	r0, r2, r0
		b >>= 1;
		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
40204670:	e1130005 	tst	r3, r5

	/* Calculate first ECC byte */
	for (i = 0; i < 4; i++) {
		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
40204674:	e1a020a2 	lsr	r2, r2, #1
	/* Initialize variables */
	a = b = 0x80;
	tmp1 = tmp2 = 0;

	/* Calculate first ECC byte */
	for (i = 0; i < 4; i++) {
40204678:	e6efc07c 	uxtb	ip, ip
		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
			tmp1 |= b;
4020467c:	11800002 	orrne	r0, r0, r2
	/* Initialize variables */
	a = b = 0x80;
	tmp1 = tmp2 = 0;

	/* Calculate first ECC byte */
	for (i = 0; i < 4; i++) {
40204680:	e35c0004 	cmp	ip, #4
			tmp1 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
		a >>= 1;
40204684:	e1a030a3 	lsr	r3, r3, #1
		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
40204688:	11a020a2 	lsrne	r2, r2, #1
4020468c:	1afffff4 	bne	40204664 <nand_calculate_ecc+0x6c>
40204690:	e3a0c000 	mov	ip, #0
40204694:	e3a07080 	mov	r7, #128	; 0x80
40204698:	e1a0200c 	mov	r2, ip
		a >>= 1;
	}

	/* Calculate second ECC byte */
	b = 0x80;
	for (i = 0; i < 4; i++) {
4020469c:	e28cc001 	add	ip, ip, #1
		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
402046a0:	e1130004 	tst	r3, r4
			tmp2 |= b;
402046a4:	11872002 	orrne	r2, r7, r2
		b >>= 1;
		if (reg2 & a)		/* LP6,4,2,0 --> ecc_code[1] */
402046a8:	e1130005 	tst	r3, r5
	/* Calculate second ECC byte */
	b = 0x80;
	for (i = 0; i < 4; i++) {
		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
			tmp2 |= b;
		b >>= 1;
402046ac:	e1a070a7 	lsr	r7, r7, #1
		a >>= 1;
	}

	/* Calculate second ECC byte */
	b = 0x80;
	for (i = 0; i < 4; i++) {
402046b0:	e6efc07c 	uxtb	ip, ip
		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
			tmp2 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP6,4,2,0 --> ecc_code[1] */
			tmp2 |= b;
402046b4:	11822007 	orrne	r2, r2, r7
		a >>= 1;
	}

	/* Calculate second ECC byte */
	b = 0x80;
	for (i = 0; i < 4; i++) {
402046b8:	e35c0004 	cmp	ip, #4
		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
			tmp2 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP6,4,2,0 --> ecc_code[1] */
			tmp2 |= b;
		b >>= 1;
402046bc:	11a070a7 	lsrne	r7, r7, #1
		a >>= 1;
402046c0:	11a030a3 	lsrne	r3, r3, #1
402046c4:	1afffff4 	bne	4020469c <nand_calculate_ecc+0xa4>
	nand_trans_result(reg2, reg3, ecc_code);

	/* Calculate final ECC code */
	ecc_code[0] = ~ecc_code[0];
	ecc_code[1] = ~ecc_code[1];
	ecc_code[2] = ((~reg1) << 2) | 0x03;
402046c8:	e1e06006 	mvn	r6, r6

	/* Create non-inverted ECC code from line parity */
	nand_trans_result(reg2, reg3, ecc_code);

	/* Calculate final ECC code */
	ecc_code[0] = ~ecc_code[0];
402046cc:	e1e00000 	mvn	r0, r0
	ecc_code[1] = ~ecc_code[1];
	ecc_code[2] = ((~reg1) << 2) | 0x03;
402046d0:	e1a06106 	lsl	r6, r6, #2
	/* Create non-inverted ECC code from line parity */
	nand_trans_result(reg2, reg3, ecc_code);

	/* Calculate final ECC code */
	ecc_code[0] = ~ecc_code[0];
	ecc_code[1] = ~ecc_code[1];
402046d4:	e1e02002 	mvn	r2, r2
	ecc_code[2] = ((~reg1) << 2) | 0x03;
402046d8:	e3866003 	orr	r6, r6, #3

	/* Create non-inverted ECC code from line parity */
	nand_trans_result(reg2, reg3, ecc_code);

	/* Calculate final ECC code */
	ecc_code[0] = ~ecc_code[0];
402046dc:	e5c10000 	strb	r0, [r1]
	ecc_code[1] = ~ecc_code[1];
402046e0:	e5c12001 	strb	r2, [r1, #1]
	ecc_code[2] = ((~reg1) << 2) | 0x03;
402046e4:	e5c16002 	strb	r6, [r1, #2]
}
402046e8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
402046ec:	40204978 	.word	0x40204978

402046f0 <nand_correct_data>:
#endif
/*
 * Detect and correct a 1 bit error for 256 byte block
 */
int nand_correct_data (u_char *dat, u_char *read_ecc, u_char *calc_ecc)
{
402046f0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	u_char a, b, c, d1, d2, d3, add, bit, i;

	/* Do error detection */
	d1 = calc_ecc[0] ^ read_ecc[0];
	d2 = calc_ecc[1] ^ read_ecc[1];
402046f4:	e5d1c001 	ldrb	ip, [r1, #1]
402046f8:	e5d24001 	ldrb	r4, [r2, #1]
	d3 = calc_ecc[2] ^ read_ecc[2];
402046fc:	e5d26002 	ldrb	r6, [r2, #2]
{
	u_char a, b, c, d1, d2, d3, add, bit, i;

	/* Do error detection */
	d1 = calc_ecc[0] ^ read_ecc[0];
	d2 = calc_ecc[1] ^ read_ecc[1];
40204700:	e024400c 	eor	r4, r4, ip
	d3 = calc_ecc[2] ^ read_ecc[2];
40204704:	e5d1c002 	ldrb	ip, [r1, #2]
int nand_correct_data (u_char *dat, u_char *read_ecc, u_char *calc_ecc)
{
	u_char a, b, c, d1, d2, d3, add, bit, i;

	/* Do error detection */
	d1 = calc_ecc[0] ^ read_ecc[0];
40204708:	e5d25000 	ldrb	r5, [r2]
4020470c:	e5d13000 	ldrb	r3, [r1]
	d2 = calc_ecc[1] ^ read_ecc[1];
	d3 = calc_ecc[2] ^ read_ecc[2];
40204710:	e026c00c 	eor	ip, r6, ip

	if ((d1 | d2 | d3) == 0) {
40204714:	e184600c 	orr	r6, r4, ip
int nand_correct_data (u_char *dat, u_char *read_ecc, u_char *calc_ecc)
{
	u_char a, b, c, d1, d2, d3, add, bit, i;

	/* Do error detection */
	d1 = calc_ecc[0] ^ read_ecc[0];
40204718:	e0253003 	eor	r3, r5, r3
	d2 = calc_ecc[1] ^ read_ecc[1];
	d3 = calc_ecc[2] ^ read_ecc[2];

	if ((d1 | d2 | d3) == 0) {
4020471c:	e1936006 	orrs	r6, r3, r6
40204720:	01a00006 	moveq	r0, r6
40204724:	08bd80f0 	popeq	{r4, r5, r6, r7, pc}
		a = (d1 ^ (d1 >> 1)) & 0x55;
		b = (d2 ^ (d2 >> 1)) & 0x55;
		c = (d3 ^ (d3 >> 1)) & 0x54;

		/* Found and will correct single bit error in the data */
		if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
40204728:	e02470a4 	eor	r7, r4, r4, lsr #1
4020472c:	e02360a3 	eor	r6, r3, r3, lsr #1
40204730:	e2077055 	and	r7, r7, #85	; 0x55
40204734:	e2066055 	and	r6, r6, #85	; 0x55
40204738:	e3570055 	cmp	r7, #85	; 0x55
4020473c:	03560055 	cmpeq	r6, #85	; 0x55
40204740:	1a000030 	bne	40204808 <nand_correct_data+0x118>
40204744:	e02c60ac 	eor	r6, ip, ip, lsr #1
40204748:	e2066054 	and	r6, r6, #84	; 0x54
4020474c:	e3560054 	cmp	r6, #84	; 0x54
40204750:	1a00002c 	bne	40204808 <nand_correct_data+0x118>
40204754:	e3a06000 	mov	r6, #0
40204758:	e3a05080 	mov	r5, #128	; 0x80
4020475c:	e1a02006 	mov	r2, r6
40204760:	e1a01005 	mov	r1, r5
			c = 0x80;
			add = 0;
			a = 0x80;
			for (i=0; i<4; i++) {
40204764:	e2866001 	add	r6, r6, #1
				if (d1 & c)
40204768:	e1150003 	tst	r5, r3
					add |= a;
4020476c:	11822001 	orrne	r2, r2, r1
				c >>= 2;
				a >>= 1;
40204770:	e1a010a1 	lsr	r1, r1, #1
		/* Found and will correct single bit error in the data */
		if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
			c = 0x80;
			add = 0;
			a = 0x80;
			for (i=0; i<4; i++) {
40204774:	e6ef6076 	uxtb	r6, r6
40204778:	e3560004 	cmp	r6, #4
				if (d1 & c)
					add |= a;
				c >>= 2;
4020477c:	11a05125 	lsrne	r5, r5, #2
40204780:	1afffff7 	bne	40204764 <nand_correct_data+0x74>
40204784:	e3a03000 	mov	r3, #0
40204788:	e3a05080 	mov	r5, #128	; 0x80
				a >>= 1;
			}
			c = 0x80;
			for (i=0; i<4; i++) {
4020478c:	e2833001 	add	r3, r3, #1
				if (d2 & c)
40204790:	e1150004 	tst	r5, r4
					add |= a;
40204794:	11812002 	orrne	r2, r1, r2
					add |= a;
				c >>= 2;
				a >>= 1;
			}
			c = 0x80;
			for (i=0; i<4; i++) {
40204798:	e6ef3073 	uxtb	r3, r3
4020479c:	e3530004 	cmp	r3, #4
				if (d2 & c)
					add |= a;
				c >>= 2;
402047a0:	11a05125 	lsrne	r5, r5, #2
				a >>= 1;
402047a4:	11a010a1 	lsrne	r1, r1, #1
402047a8:	1afffff7 	bne	4020478c <nand_correct_data+0x9c>
402047ac:	e3a01000 	mov	r1, #0
402047b0:	e3a05080 	mov	r5, #128	; 0x80
402047b4:	e1a04001 	mov	r4, r1
			}
			bit = 0;
			b = 0x04;
			c = 0x80;
			for (i=0; i<3; i++) {
				if (d3 & c)
402047b8:	e115000c 	tst	r5, ip
				a >>= 1;
			}
			bit = 0;
			b = 0x04;
			c = 0x80;
			for (i=0; i<3; i++) {
402047bc:	e2811001 	add	r1, r1, #1
				if (d3 & c)
					bit |= b;
402047c0:	11834004 	orrne	r4, r3, r4
				a >>= 1;
			}
			bit = 0;
			b = 0x04;
			c = 0x80;
			for (i=0; i<3; i++) {
402047c4:	e6ef1071 	uxtb	r1, r1
				if (d3 & c)
					bit |= b;
402047c8:	16ef4074 	uxtbne	r4, r4
				a >>= 1;
			}
			bit = 0;
			b = 0x04;
			c = 0x80;
			for (i=0; i<3; i++) {
402047cc:	e3510003 	cmp	r1, #3
				if (d3 & c)
					bit |= b;
				c >>= 2;
402047d0:	11a05125 	lsrne	r5, r5, #2
				b >>= 1;
402047d4:	17e730d3 	ubfxne	r3, r3, #1, #8
402047d8:	1afffff6 	bne	402047b8 <nand_correct_data+0xc8>
			}
			b = 0x01;
			a = dat[add];
			a ^= (b << bit);
402047dc:	e7d01002 	ldrb	r1, [r0, r2]
402047e0:	e3a03001 	mov	r3, #1
402047e4:	e0214413 	eor	r4, r1, r3, lsl r4
			dat[add] = a;
402047e8:	e7c04002 	strb	r4, [r0, r2]
402047ec:	e1a00003 	mov	r0, r3
			return 1;
402047f0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
		}
		else {
			i = 0;
			while (d1) {
				if (d1 & 0x01)
402047f4:	e3130001 	tst	r3, #1
					++i;
				d1 >>= 1;
402047f8:	e1a030a3 	lsr	r3, r3, #1
		}
		else {
			i = 0;
			while (d1) {
				if (d1 & 0x01)
					++i;
402047fc:	12800001 	addne	r0, r0, #1
40204800:	16ef0070 	uxtbne	r0, r0
40204804:	ea000000 	b	4020480c <nand_correct_data+0x11c>
				d1 >>= 1;
40204808:	e3a00000 	mov	r0, #0
			dat[add] = a;
			return 1;
		}
		else {
			i = 0;
			while (d1) {
4020480c:	e3530000 	cmp	r3, #0
40204810:	1afffff7 	bne	402047f4 <nand_correct_data+0x104>
40204814:	ea000003 	b	40204828 <nand_correct_data+0x138>
				if (d1 & 0x01)
					++i;
				d1 >>= 1;
			}
			while (d2) {
				if (d2 & 0x01)
40204818:	e3140001 	tst	r4, #1
					++i;
				d2 >>= 1;
4020481c:	e1a040a4 	lsr	r4, r4, #1
					++i;
				d1 >>= 1;
			}
			while (d2) {
				if (d2 & 0x01)
					++i;
40204820:	12800001 	addne	r0, r0, #1
40204824:	16ef0070 	uxtbne	r0, r0
			while (d1) {
				if (d1 & 0x01)
					++i;
				d1 >>= 1;
			}
			while (d2) {
40204828:	e3540000 	cmp	r4, #0
4020482c:	1afffff9 	bne	40204818 <nand_correct_data+0x128>
40204830:	ea000003 	b	40204844 <nand_correct_data+0x154>
				if (d2 & 0x01)
					++i;
				d2 >>= 1;
			}
			while (d3) {
				if (d3 & 0x01)
40204834:	e31c0001 	tst	ip, #1
					++i;
				d3 >>= 1;
40204838:	e1a0c0ac 	lsr	ip, ip, #1
					++i;
				d2 >>= 1;
			}
			while (d3) {
				if (d3 & 0x01)
					++i;
4020483c:	12800001 	addne	r0, r0, #1
40204840:	16ef0070 	uxtbne	r0, r0
			while (d2) {
				if (d2 & 0x01)
					++i;
				d2 >>= 1;
			}
			while (d3) {
40204844:	e35c0000 	cmp	ip, #0
40204848:	1afffff9 	bne	40204834 <nand_correct_data+0x144>
				if (d3 & 0x01)
					++i;
				d3 >>= 1;
			}
			if (i == 1) {
4020484c:	e3500001 	cmp	r0, #1
				/* ECC Code Error Correction */
				read_ecc[0] = calc_ecc[0];
40204850:	05c15000 	strbeq	r5, [r1]
				read_ecc[1] = calc_ecc[1];
40204854:	05d23001 	ldrbeq	r3, [r2, #1]
			while (d3) {
				if (d3 & 0x01)
					++i;
				d3 >>= 1;
			}
			if (i == 1) {
40204858:	13e00000 	mvnne	r0, #0
				/* ECC Code Error Correction */
				read_ecc[0] = calc_ecc[0];
				read_ecc[1] = calc_ecc[1];
				read_ecc[2] = calc_ecc[2];
4020485c:	03a00002 	moveq	r0, #2
				d3 >>= 1;
			}
			if (i == 1) {
				/* ECC Code Error Correction */
				read_ecc[0] = calc_ecc[0];
				read_ecc[1] = calc_ecc[1];
40204860:	05c13001 	strbeq	r3, [r1, #1]
				read_ecc[2] = calc_ecc[2];
40204864:	05d23002 	ldrbeq	r3, [r2, #2]
40204868:	05c13002 	strbeq	r3, [r1, #2]
		}
	}

	/* Should never happen */
	return -1;
}
4020486c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
